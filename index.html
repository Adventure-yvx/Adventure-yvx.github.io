
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>Adventure</title>
        <meta name="author" content="AdventureYX" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>ADVENTURE</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" @click="shouMenuItems = !shouMenuItems" v-show="shouMenuItems"></div>
        <div class="title" @click="shouMenuItems = !shouMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ADVENTURE</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="shouMenuItems">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

            <transition name="into">
            <div id="main" v-show="!loading">
                <div id="home-head">
    <div
        id="home-background"
        ref="homeBackground"
        data-images="/images/background.jpg"
    ></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Adventure</h1>
                <h3>心有所向。日复一日，必有精进</h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div id="home-posts-wrap"  ref="homePostsWrap">
    <div id="home-posts">
        

<div class="post">
    <a href="/2023/04/02/C++11/">
        <h2 class="post-title">C++11</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/C/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                C++
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/4/2
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="安全性——智能指针"><a href="#安全性——智能指针" class="headerlink" title="安全性——智能指针"></a>安全性——智能指针</h1><p><strong>内存泄漏：</strong>由于疏忽或错误导致的程序未能释放已经不再使用的内存。</p>
<p>进一步解释：</p>
<ul>
<li><p>并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。</p>
</li>
<li><p>常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。</p>
</li>
<li><p>使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete释放内存，否则这块内存就会造成内存泄漏。</p>
</li>
<li><p>指针重新赋值</p>
<pre><code class="cpp">char *p = (char *)malloc(10);
char *p1 = (char *)malloc(10);
p = np;
</code></pre>
<p>开始时，指针 p 和 p1 分别指向一块内存空间，但指针 p 被重新赋值，导致 p 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。</p>
</li>
</ul>
<p>解决内存泄漏最有效的方法是使用<strong>智能指针（smart pointer）</strong>。</p>
<p>智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在<strong>离开指针所在作用域时，自动地销毁动态分配的对象</strong>，防止内存泄露。</p>
<p>智能指针的核心实现技术是<strong>引用计数</strong>，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</p>
<p>C++11中提供了三种智能指针，使用这些智能指针时需要引用头文件<code> &lt;memory&gt;</code>:</p>
<ul>
<li><code> std::shared_ptr</code>：共享的智能指针</li>
<li><code> std::unique_ptr</code>：独占的智能指针</li>
<li><code> std::weak_ptr</code>：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视<code>shared_ptr</code>的。</li>
</ul>
<h2 id="共享智能指针（shared-ptr）"><a href="#共享智能指针（shared-ptr）" class="headerlink" title="共享智能指针（shared_ptr）"></a>共享智能指针（shared_ptr）</h2><h3 id="shared-ptr的初始化"><a href="#shared-ptr的初始化" class="headerlink" title="shared_ptr的初始化"></a>shared_ptr的初始化</h3><p>共享智能指针是指<strong>多个智能指针可以同时管理同一块有效的内存</strong>，共享智能指针 <code>shared_ptr</code> 是一个<strong>模板类</strong>，如果要进行初始化有三种方式：</p>
<ul>
<li>构造函数</li>
<li><code>std::make_shared</code> 辅助函数</li>
<li>reset 方法</li>
</ul>
<p>共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数 use_count，函数原型如下：</p>
<pre><code class="cpp">// 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。
long use_count() const noexcept;
</code></pre>
<h3 id="通过构造函数初始化"><a href="#通过构造函数初始化" class="headerlink" title="通过构造函数初始化"></a>通过构造函数初始化</h3><pre><code class="cpp">// shared_ptr&lt;T&gt; 类模板中，提供了多种实用的构造函数, 语法格式如下:
std::shared_ptr&lt;T&gt; 智能指针名字(创建堆内存);
</code></pre>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;

int main()
&#123;
    // 使用智能指针管理一块 int 型的堆内存
    shared_ptr&lt;int&gt; ptr1(new int(520));
    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;
    // 使用智能指针管理一块字符数组对应的堆内存
    shared_ptr&lt;char&gt; ptr2(new char[12]);
    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;
    // 创建智能指针对象, 不管理任何内存
    shared_ptr&lt;int&gt; ptr3;
    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;
    // 创建智能指针对象, 初始化为空
    shared_ptr&lt;int&gt; ptr4(nullptr);
    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;

    return 0;
&#125;
</code></pre>
<p>测试结果：</p>
<pre><code class="cpp">ptr1管理的内存引用计数: 1
ptr2管理的内存引用计数: 1
ptr3管理的内存引用计数: 0
ptr4管理的内存引用计数: 0
</code></pre>
<blockquote>
<p>如果智能指针被初始化了一块有效内存，那么这块内存的引用计数 + 1，如果智能指针没有被初始化或者被初始化为 nullptr 空指针，引用计数不会 + 1。另外，不要使用一个原始指针初始化多个 shared_ptr。</p>
</blockquote>
<pre><code class="cpp">int *p = new int;
shared_ptr&lt;int&gt; p1(p);
shared_ptr&lt;int&gt; p2(p);		// error, 编译不会报错, 运行会出错
</code></pre>
<h3 id="通过拷贝和移动构造函数初始化"><a href="#通过拷贝和移动构造函数初始化" class="headerlink" title="通过拷贝和移动构造函数初始化"></a>通过拷贝和移动构造函数初始化</h3><p>当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了。</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;

int main()
&#123;
    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1
    shared_ptr&lt;int&gt; ptr1(new int(520));
    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;
    //调用拷贝构造函数
    shared_ptr&lt;int&gt; ptr2(ptr1);
    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;
    shared_ptr&lt;int&gt; ptr3 = ptr1;
    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;
    //调用移动构造函数
    shared_ptr&lt;int&gt; ptr4(std::move(ptr1));
    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;
    std::shared_ptr&lt;int&gt; ptr5 = std::move(ptr2);
    cout &lt;&lt; &quot;ptr5管理的内存引用计数: &quot; &lt;&lt; ptr5.use_count() &lt;&lt; endl;

    return 0;
&#125;
</code></pre>
<p>测试结果：</p>
<pre><code class="cpp">ptr1管理的内存引用计数: 1
ptr2管理的内存引用计数: 2
ptr3管理的内存引用计数: 3
ptr4管理的内存引用计数: 3
ptr5管理的内存引用计数: 3
</code></pre>
<blockquote>
<p>如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加；如果使用移动的方式初始智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存的引用计数不会变化。</p>
</blockquote>
<h3 id="通过-std-make-shared-初始化"><a href="#通过-std-make-shared-初始化" class="headerlink" title="通过 std::make_shared 初始化"></a>通过 std::make_shared 初始化</h3><p>通过 C++ 提供的 std::make_shared() 就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：</p>
<pre><code class="cpp">template&lt; class T, class... Args &gt;
shared_ptr&lt;T&gt; make_shared( Args&amp;&amp;... args );
</code></pre>
<ul>
<li><code>T</code>：模板参数的数据类型</li>
<li><code>Args&amp;&amp;... args</code> ：要初始化的数据，如果是通过 make_shared 创建对象，需按照构造函数的参数列表指定</li>
</ul>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
using namespace std;

class Test
&#123;
public:
    Test() 
    &#123;
        cout &lt;&lt; &quot;construct Test...&quot; &lt;&lt; endl;
    &#125;
    Test(int x) 
    &#123;
        cout &lt;&lt; &quot;construct Test, x = &quot; &lt;&lt; x &lt;&lt; endl;
    &#125;
    Test(string str) 
    &#123;
        cout &lt;&lt; &quot;construct Test, str = &quot; &lt;&lt; str &lt;&lt; endl;
    &#125;
    ~Test()
    &#123;
        cout &lt;&lt; &quot;destruct Test ...&quot; &lt;&lt; endl;
    &#125;
&#125;;

int main()
&#123;
    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1
    shared_ptr&lt;int&gt; ptr1 = make_shared&lt;int&gt;(520);
    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;

    shared_ptr&lt;Test&gt; ptr2 = make_shared&lt;Test&gt;();
    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;

    shared_ptr&lt;Test&gt; ptr3 = make_shared&lt;Test&gt;(520);
    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;

    shared_ptr&lt;Test&gt; ptr4 = make_shared&lt;Test&gt;(&quot;ptr_test&quot;);
    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<blockquote>
<p>使用 std::make_shared() 模板函数可以完成内存地址的创建，并将最终得到的内存地址传递给共享智能指针对象管理。如果申请的内存是普通类型，通过函数的（）可完成地址的初始化，如果要创建一个类对象，函数的（）内部需要指定构造对象需要的参数，也就是类构造函数的参数。</p>
</blockquote>
<h3 id="通过-reset-方法初始化"><a href="#通过-reset-方法初始化" class="headerlink" title="通过 reset 方法初始化"></a>通过 reset 方法初始化</h3><p>共享智能指针类提供的 std::shared_ptr::reset 方法函数原型如下：</p>
<pre><code class="cpp">void reset() noexcept;

template&lt; class Y &gt;
void reset( Y* ptr );

template&lt; class Y, class Deleter &gt;
void reset( Y* ptr, Deleter d );

template&lt; class Y, class Deleter, class Alloc &gt;
void reset( Y* ptr, Deleter d, Alloc alloc );
</code></pre>
<ul>
<li>ptr：指向要取得所有权的对象的指针</li>
<li>d：指向要取得所有权的对象的指针</li>
<li>aloc：内部存储所用的分配器</li>
</ul>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
using namespace std;

int main()
&#123;
    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1
    shared_ptr&lt;int&gt; ptr1 = make_shared&lt;int&gt;(520);
    shared_ptr&lt;int&gt; ptr2 = ptr1;
    shared_ptr&lt;int&gt; ptr3 = ptr1;
    shared_ptr&lt;int&gt; ptr4 = ptr1;
    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;
    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;
    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;
    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;

    ptr4.reset();
    cout &lt;&lt; &quot;ptr1管理的内存引用计数: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;
    cout &lt;&lt; &quot;ptr2管理的内存引用计数: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;
    cout &lt;&lt; &quot;ptr3管理的内存引用计数: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;
    cout &lt;&lt; &quot;ptr4管理的内存引用计数: &quot; &lt;&lt; ptr4.use_count() &lt;&lt; endl;

    shared_ptr&lt;int&gt; ptr5;
    ptr5.reset(new int(250));
    cout &lt;&lt; &quot;ptr5管理的内存引用计数: &quot; &lt;&lt; ptr5.use_count() &lt;&lt; endl;

    return 0;
&#125;
</code></pre>
<p>测试结果：</p>
<pre><code class="cpp">ptr1管理的内存引用计数: 4
ptr2管理的内存引用计数: 4
ptr3管理的内存引用计数: 4
ptr4管理的内存引用计数: 4
    
ptr1管理的内存引用计数: 3
ptr2管理的内存引用计数: 3
ptr3管理的内存引用计数: 3
ptr4管理的内存引用计数: 0
    
ptr5管理的内存引用计数: 1
</code></pre>
<blockquote>
<p>对于一个未初始化的共享智能指针，可以通过 reset 方法来初始化，当智能指针中有值的时候，调用 reset 会使引用计数减 1。</p>
</blockquote>
<h3 id="获取原始指针"><a href="#获取原始指针" class="headerlink" title="获取原始指针"></a>获取原始指针</h3><h2 id="独占智能指针（unique-ptr）"><a href="#独占智能指针（unique-ptr）" class="headerlink" title="独占智能指针（unique_ptr）"></a>独占智能指针（unique_ptr）</h2><h3 id="unique-ptr的初始化"><a href="#unique-ptr的初始化" class="headerlink" title="unique_ptr的初始化"></a>unique_ptr的初始化</h3><p>std::unique_ptr 是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个 unique_ptr 赋值给另一个 unique_ptr。</p>
<pre><code class="cpp">// 通过构造函数初始化对象
unique_ptr&lt;int&gt; ptr1(new int(10));
// error, 不允许将一个unique_ptr赋值给另一个unique_ptr
unique_ptr&lt;int&gt; ptr2 = ptr1;
</code></pre>
<p>std::unique_ptr 不允许复制，但是可以通过函数返回给其他的 std::unique_ptr，还可以通过 <code>std::move</code> 来转译给其他的 std::unique_ptr，这样原始指针的所有权就被转移了，这个原始指针还是被独占的。</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;

unique_ptr&lt;int&gt; func()
&#123;
    return unique_ptr&lt;int&gt;(new int(520));
&#125;

int main()
&#123;
    // 通过构造函数初始化
    unique_ptr&lt;int&gt; ptr1(new int(10));
    // 通过转移所有权的方式初始化
    unique_ptr&lt;int&gt; ptr2 = move(ptr1);
    unique_ptr&lt;int&gt; ptr3 = func();

    return 0;
&#125;
</code></pre>
<h2 id="弱引用智能指针（weak-ptr）"><a href="#弱引用智能指针（weak-ptr）" class="headerlink" title="弱引用智能指针（weak_ptr）"></a>弱引用智能指针（weak_ptr）</h2><p>弱引用智能指针 std::weak_ptr 可以看做是 shared_ptr 的助手，它不管理 shared_ptr 内部的指针。std::weak_ptr 没有重载操作符 * 和 -&gt;，因为它不共享指针，不能操作资源，所以它的构造不会增加引用计数，析构也不会减少引用计数，它的主要作用就是作为一个旁观者监视 shared_ptr 中管理的资源是否存在。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #ffa2c4">
                C++
            </a>
        </span>
        
    </div>
    <a href="/2023/04/02/C++11/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/03/26/QML&QtQuick/">
        <h2 class="post-title">QML &amp; Qt Quick</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Qt/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Qt
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/26
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="QML-基础"><a href="#QML-基础" class="headerlink" title="QML 基础"></a>QML 基础</h1><p>QML（Qt Meta Language，Qt元语言）是一个用来描述应用程序界面的<strong>声明式</strong>脚本语言。QML具有良好的易读性，它以可视化组件及其交互和相互关联的方式来描述界面，使组件能在动态行为中互相连接，并支持在一个用户界面上很方便的复用和定制组件。</p>
<p>Qt Quick是Qt为QML提供的一套标准类库，由QML标准类型和功能组成，包括可视化类型、交互类型、动画类型、模型和视图、粒子系统和渲染效果等，编程时只需要一条import语句，就能访问所有这些功能。使用Qt Quick，能够很容易地用QML构建出高品质、流畅的UI界面，从而开发出具有视觉吸引力的应用程序。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li><code>import</code>语句导入一个模块。Qt6可以不写版本号，自动加载最高版本模块。</li>
<li>每个QML文件都需要有一个唯一的根元素（像HTML一样</li>
<li>元素声明形式：<code>type&#123;  &#125;</code></li>
<li>元素属性：<code>name:value</code></li>
<li>QML文档中的任意元素可以通过使用其id进行访问</li>
<li>元素可以嵌套，父元素可以有子元素。子元素可以使用parent关键字访问父元素。</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00a596">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Qt/" style="color: #00bcd4">
                Qt
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/QML/" style="color: #ffa2c4">
                QML
            </a>
        </span>
        
    </div>
    <a href="/2023/03/26/QML&QtQuick/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
        <h2 class="post-title">设计模式</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/C/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                C++
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/20
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00a596">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="color: #ff7d73">
                设计模式
            </a>
        </span>
        
    </div>
    <a href="/2023/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/03/12/QtStudy/">
        <h2 class="post-title">Qt Study</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Qt/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Qt
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/12
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="Qt-核心"><a href="#Qt-核心" class="headerlink" title="Qt 核心"></a>Qt 核心</h1><h2 id="元对象系统"><a href="#元对象系统" class="headerlink" title="元对象系统"></a>元对象系统</h2><p>Qt 元对象系统提供了对象间的通信机制（信号和槽）、运行时类型信息和动态属性系统的支持，是标准<code>C++</code>的一个扩展，它使Qt能够更好的实现GUI用户图形界面编程。Qt的元对象系统不支持C++模板。</p>
<p>Qt元对象系统基于以下三个事实：</p>
<ul>
<li>基类<code>QObject</code>：任何需要使用元对象系统功能的类必须继承自<code>QObject</code>。<code>QObject</code>是<code>Qt</code>中最基本的类，是所有<code>Qt</code>对象的基类。</li>
<li>Q_OBJECT宏：Q_OBJECT宏必须出现在类的私有声明区，用于启动元对象的特性。</li>
<li>元对象编译器（moc, Meta-Object Compiler）：为<code>QObject</code>子类实现元对象特性提供必要的代码实现。（将<code>Qt</code>对<code>C++</code>的语法拓展编译还原标准C++代码）</li>
</ul>
<h2 id="对象树"><a href="#对象树" class="headerlink" title="对象树"></a>对象树</h2><p>什么是Qt对象：定义一个类，继承于 <code>QObject</code> ，因此而产生的对象叫 Qt 对象</p>
<ul>
<li>对象通过对象树的形式组织。</li>
<li>对象树主要用来内存回收，对象树之间不一定是继承关系</li>
<li>Qt 对象间可以存在父子关系<ul>
<li>每一个对象都保存有它所有子对象的指针</li>
<li>每一个对象都有一个指向其父对象的指针</li>
<li>可以使用<code>findChild()</code>或<code>findChildren()</code>查找对象的子对象。</li>
</ul>
</li>
<li>当指定 Qt 对象的父对象时，该对象将自动将自己添加到父对象的<code>children()</code>列表中<ul>
<li>其父对象会在<strong>子对象链表</strong>中加入该对象的指针</li>
<li>该对象会保存指向其父对象的指针</li>
</ul>
</li>
<li>当Qt 对象被销毁时<ul>
<li>将自己从父对象的 Children List 移除</li>
<li>将自己的 Children List 中的所有对象销毁</li>
</ul>
</li>
</ul>
<h2 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h2><ul>
<li><p>信号（signal）和槽（slot）是Qt自行定义的一种通信机制，实现对象之间的数据交互。</p>
</li>
<li><p>当用户或系统触发了一个动作，导致某个控件的状态发生了改变，该控件就会发射一个信号，即调用其<strong>类中一个特定的成员函数（信号）</strong>，同时还能携带有必要的参数。</p>
</li>
<li><p>槽函数与普通成员函数没有太多区别，差别在于其功能。槽函数更多体现为对某种特定信号的处理，可以将槽和其他对象信号建立连接，这样当发射信号时，槽函数能将被触发和执行，进而来完成机体功能。</p>
</li>
<li><p>信号的定义</p>
<pre><code class="cpp">class XX: public QObject&#123;
    Q_OBJECT   //宏，moc链接工具，元对象编译器，处理QT语法扩展，还原成标准c++代码
signals:
    void signal_func(..);  //信号函数，只需声明，不能写定义。QT语法扩展，普通C++无法编译
&#125;
</code></pre>
</li>
<li><p>槽的定义</p>
<pre><code class="cpp">class XX: public QObject&#123;
    Q_OBJECT
public slots:
    void slot_func(..)&#123;..&#125; //槽函数可以连接到某个信号上，当信号被发射时，槽函数将被触发和执行。另外槽函数可以当作普通成员函数使用。
&#125;
</code></pre>
</li>
<li><p>信号和槽的链接</p>
<pre><code class="cpp">QObject::connect(const QObject* sender,      //信号发送对象指针
                 const char* signal, 		//要发送的的信号函数，可以使用“SIGNAL(..)”宏进行类型转换
                 const QObject* receiver, 	//信号的接收对象指针
                 const char* method);		//要执行的槽函数，使用“SLOT(..)”宏进行类型转换
                                         //信号函数连同参数类型转换为const char*
</code></pre>
</li>
<li><p>实例：</p>
<ul>
<li>按钮点击时发送信号：clicked()</li>
<li>实现标签关闭功能：close()</li>
</ul>
<pre><code class="cpp">int main(int argc, char *argv[])
&#123;
    QApplication a(argc, argv);

    MainWindow w;
    w.resize(640, 640);

    //创建标签控件
    QLabel label(&quot;我是标签&quot;, &amp;w);
    label.move(20, 40);

    //创建按钮空间，栈创建，系统自动销毁
    QPushButton btn(&quot;我是按钮&quot;, &amp;w);
    btn.move(20, 100);
    QPushButton btn2(&quot;退出&quot;, &amp;w);
    btn2.move(100, 100);
    w.show();

    //点击按钮关闭标签
    QObject::connect(&amp;btn, SIGNAL(clicked(bool)), &amp;label, SLOT(close()));

    //增加退出按钮，实现退出应用程序
    QObject::connect(&amp;btn2, SIGNAL(clicked(bool)), 
                     &amp;a, SLOT(quit()));
                  //&amp;a, SLOT(closeAllWindows())
                  //&amp;w, SLOT(close())
    return a.exec();
&#125;
</code></pre>
</li>
<li><p>信号和槽连接的语法要求与应用</p>
<ul>
<li><p>信号和槽参数要一致</p>
<pre><code class="cpp">QObject::connect(A, SIGNAL(sigfun(int)), B, SLOT(slotfun(int)));
QObject::connect(A, SIGNAL(sigfun(int)), B, SLOT(slotfun(int,int)));  //error
</code></pre>
</li>
<li><p>可以带有缺省参数</p>
<pre><code class="cpp">QObject::connect(A, SIGNAL(sigfun(int)), B, SLOT(slotfun(int,int=0)));
</code></pre>
</li>
<li><p>信号函数参数可以多于槽函数，多于参数将被忽略</p>
<pre><code class="cpp">QObject::connect(A, SIGNAL(sigfun(int,int)), B, SLOT(slotfun(int)));
</code></pre>
</li>
<li><p>信号和槽函数（一对多）</p>
<pre><code class="cpp">QObject::connect(A, SIGNAL(sigfun(int)), B1, SLOT(slotfun1(int)));
QObject::connect(A, SIGNAL(sigfun(int)), B2, SLOT(slotfun2(int)));
</code></pre>
</li>
<li><p>信号和槽函数（多对一）</p>
<pre><code class="cpp">QObject::connect(A1, SIGNAL(sigfun1(int)), B, SLOT(slotfun(int)));
QObject::connect(A2, SIGNAL(sigfun2(int)), B, SLOT(slotfun(int))); 
</code></pre>
</li>
<li><p>两个信号直接连接，信号级联</p>
<pre><code class="cpp">QObject::connect(A1, SIGNAL(sigfun1(int)), A2, SLOT(slotfun2(int)));
</code></pre>
</li>
</ul>
</li>
<li><p>实例：创建滑块（QSlider）和选值框（QSpinBox），通过信号和槽的机制，保持同步运行</p>
<ul>
<li>QSlider<ul>
<li><code>void setRange(int min, int max);//设置滑动范围</code></li>
<li><code>void setValue(int)[slot];//设置当前位置</code></li>
<li><code>void valueChange(int value)[signal];//滑动时发送信号</code></li>
</ul>
</li>
<li>QSpinBox<ul>
<li><code>void setRange(int min, int max);//设置数值改变范围</code></li>
<li><code>void setValue(int)[slot];//设置当前数值</code></li>
<li><code>void valueChange(int value)[signal];//选值框数值改变时发送信号</code></li>
</ul>
</li>
</ul>
<pre><code class="cpp">    QDialog parent;
    parent.resize(320, 240);

    //创建水平滑块
    QSlider slider(Qt::Horizontal, &amp;parent);
    slider.move(20, 100);
    slider.setRange(0,200);
    //创建选值框
    QSpinBox spin(&amp;parent);
    spin.move(220, 100);
    spin.setRange(0, 200);

    //滑块滑动让选值框数值改变
    QObject::connect(&amp;slider, SIGNAL(valueChanged(int)),
                     &amp;spin, SLOT(setValue(int)));
    //选值框数值改变让滑块随之滑动
    QObject::connect(&amp;spin, SIGNAL(valueChanged(int)),
                     &amp;slider, SLOT(setValue(int)));

    parent.show();
</code></pre>
</li>
<li><p>案例：获取系统时间</p>
</li>
<li><p>案例：实现计算器</p>
</li>
<li><p>通过Qt designer重构计算器案例</p>
<ul>
<li><p>使用转换器(uic)，将calculatordialog.ui(xml)转换为ui_calcculatordialog.h(c++)</p>
<p><code>uic calculatordialog.ui -o ui_calcculatordialog.h</code></p>
<p>(不手动转换，makefile中也会进行转化)</p>
</li>
<li><p>使用ui_calculatordialog.h里面已经自动生成的界面相关代码，完成代码编写</p>
<ol>
<li>通过继承方式，将界面代码继承过来直接使用</li>
<li>通过组合方式，添加一个界面类的成员变量(ui)，再通过该成员访问界面相关的代码，实际开发中，推荐使用这种方法。</li>
</ol>
</li>
<li><p>构建、测试</p>
</li>
</ul>
</li>
<li><p>案例：登录对话框</p>
</li>
</ul>
<h2 id="QObject基类"><a href="#QObject基类" class="headerlink" title="QObject基类"></a>QObject基类</h2><h2 id="Qt中使用到的设计模式"><a href="#Qt中使用到的设计模式" class="headerlink" title="Qt中使用到的设计模式"></a>Qt中使用到的设计模式</h2><ol>
<li><p>单例模式</p>
<p>qApp宏返回指向QApplication的单例</p>
<p>特点：单例模式确保一个类只有一个实例，并提供全局访问点。这样可以避免在系统中出现多个相同的对象，从而提高系统的性能和可维护性。</p>
<p>应用场景：单例模式常用于需要全局访问的对象，比如说日志记录器、数据库连接池等。</p>
<p>说明：常见用法是把类的构造函数设为私有，然后提供一个类的静态函数来获取单例对象</p>
<p>如下代码，通过宏aApp返回instance。可以看到，类QCoreApplication的构造函数是private。</p>
<p>时间和空间:懒汉式是典型的时间换出空间。饿汉式是典型的空间换时间。<br>线程安全:不加同步的懒汉式的线程不安全的。饿汉式是线程安全的。</p>
<pre><code class="cpp">#define qApp QCoreApplication::instance()

class Q_CORE_EXPORT QCoreApplication
#ifndef QT_NO_QOBJECT
    : public QObject
#endif
&#123;
#ifndef QT_NO_QOBJECT
    Q_OBJECT
    Q_PROPERTY(QString applicationName READ applicationName WRITE setApplicationName NOTIFY applicationNameChanged)
    Q_PROPERTY(QString applicationVersion READ applicationVersion WRITE setApplicationVersion NOTIFY applicationVersionChanged)
    Q_PROPERTY(QString organizationName READ organizationName WRITE setOrganizationName NOTIFY organizationNameChanged)
    Q_PROPERTY(QString organizationDomain READ organizationDomain WRITE setOrganizationDomain NOTIFY organizationDomainC
</code></pre>
</li>
<li><p>工厂模式</p>
<ul>
<li>创建一个新的类，可以将这个类称之为工厂类。对于简单工厂模式来说，需要的工厂类只有一个。</li>
<li>在这个工厂类中添加一个公共的成员函数，通过这个函数来创建我们需要的对象，关于这个函数一般将其称之为工厂函数。</li>
<li>关于使用，首先创建一个工厂类对象，然后通过这个对象调用工厂函数，这样就可以生产出一个指定类型的实例对象了。</li>
</ul>
</li>
<li><p>原型模式（Prototype Pattern）</p>
<p>特点：原型模式通过复制现有的对象来创建新的对象。这样可以避免重复创建对象，从而提高系统的性能。</p>
<p>应用场景：原型模式常用于创建复杂对象，尤其是当对象的创建过程很耗时、耗资源时。比如说，一个复杂的对象需要从数据库中读取数据并进行计算，这时可以使用原型模式来避免重复读取数据库，提高系统的性能。</p>
<p>说明：一般用法就是在类里定义一个clone方法，用来创建新的对象</p>
<p>**原型模式重点在于重载 operator &#x3D; ()**，实现拷贝构造实现快速生成一个当前类的副本目标<br>经常用在class拷贝，貌似好像没有怎么实现过，因为都是传Class地址。这个模式实现的可能就只有Qt中的QString class还有带有拷贝构造的容器类型</p>
</li>
<li><p>反射模式</p>
<p>反射就是指对象成员的自我说明。 Qt元对象模式就是反射模式。QObject拥有QMetaObject、QMetaProperty类就能实现反射模式。</p>
</li>
<li><p>命令模式</p>
<p>命令模式：把操作封装成具有公共执行接口的对象。这样就可以把操作放到一个队列中，可以实现取消已经执行的操作。 Qt中QUndoCommand、QRunnable、QAction可以看成是命令模式。</p>
<p>命令模式将一个请求封装成一个对象，从而可以对请求进行参数化、队列化、记录日志等操作。这样可以使得系统更加灵活、可扩展。</p>
<p>应用场景：命令模式常用于需要将请求进行参数化、队列化、记录日志等操作的情况下。比如说，一个系统需要对多个操作进行记录，这时可以使用命令模式来记录每个操作。</p>
<p>说明：命令模式实现了请求发送者和接收者之间的解耦，请求发送者把操作所需的信息封装成一个对象发给接收者，接收者不需要知道它具体怎么操作，只需要调用某个固定的方法就可以完成请求。</p>
</li>
<li><p>观察者模式</p>
<p>观察者模式（又被称为发布-订阅（Publish&#x2F;Subscribe）模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。 Qt中事件循环、信号和槽、视图模型都可以视为观察者模式。其实事件循环是真正的观察者模式，信号和槽由事件实现、视图模型由信号和槽实现。</p>
</li>
<li><p>组合模式</p>
<p>Qt中由QObject实现的父子类就是组合模式。</p>
<p>特点：组合模式将对象组合成树形结构，并以统一的方式处理这些对象。这样可以使得系统更加灵活、可扩展。</p>
<p>应用场景：组合模式常用于处理复杂的层次结构，比如说文件系统、GUI界面等。在这些系统中，通常需要对不同的对象进行统一处理，比如遍历、增加、删除等，这时可以使用组合模式来处理这些对象。</p>
<p>说明：Qt中的QWidget就用到了组合模式，每一个控件都由QWidget或其派生类派生，它们之间存在着树状的层级关系，并且都有一些共有的方法，比如QPaintEvent，setParent，move，resize等。</p>
</li>
</ol>
<h1 id="Qt-模板库、工具类及控件"><a href="#Qt-模板库、工具类及控件" class="headerlink" title="Qt 模板库、工具类及控件"></a>Qt 模板库、工具类及控件</h1><h1 id="Qt-窗口"><a href="#Qt-窗口" class="headerlink" title="Qt 窗口"></a>Qt 窗口</h1><ul>
<li><p>创建控件时，可以指定停靠在某个父窗口上面，这时控件将作为子窗口被束缚在其父窗口的内部，并伴随父窗口一起移动、隐藏、显示和关闭；否则该控件将作为独立窗口显示在屏幕上，且游离于其他窗口之外。</p>
</li>
<li><p>QWidget及其子类的对象可以作为其他控件的父窗口</p>
</li>
<li><p>常用的父窗口类有如下三个：</p>
<ul>
<li>QWidget</li>
<li>QMainWindow（主窗口）&#x2F;&#x2F;QWidget的直接子类</li>
<li>QDialog（对话框）&#x2F;&#x2F;QWidget的直接子类</li>
</ul>
</li>
<li><p>父窗口的析构函数会自动销毁其所有的子窗口对象，因此即使子窗口对象是通过new操作符动态创建的，可以不显式的执行delete操作，而且不用担心内存泄漏的问题，只要保证父窗口对象被正确销毁，其子窗口也将随之被销毁。</p>
</li>
<li><p>设置窗口的位置和大小</p>
<ul>
<li>void move(int x, int y);</li>
<li>void resize(int w, int h);</li>
</ul>
</li>
<li><pre><code class="cpp">#include &lt;QMainWindow&gt;
#include &lt;QWidget&gt;
#include &lt;QApplication&gt;
#include &lt;QLabel&gt;
#include &lt;QDialog&gt;
#include &lt;QPushButton&gt;

int main(int argc, char *argv[])
&#123;
    QApplication a(argc, argv);

    MainWindow w;
    w.resize(640, 640);

    //创建标签控件
    QLabel label(&quot;我是标签&quot;, &amp;w);
    label.move(20, 40);

    //创建按钮空间，栈创建，系统自动销毁
    QPushButton btn(&quot;我是按钮&quot;, &amp;w);
    btn.move(20, 100);
    btn.resize(80, 80);
    
    //堆创建，new对象如果指定了父窗口指针，可以不写delete，随父窗口销毁
    QPushButton* btn2 = new QPushButton(&quot;我也是按钮&quot;, &amp;w);
    btn2-&gt;move(170, 100);
    btn2-&gt;resize(80, 80);

    w.show();
    return a.exec();
&#125;
</code></pre>
</li>
<li></li>
</ul>
<h1 id="Qt-事件处理机制"><a href="#Qt-事件处理机制" class="headerlink" title="Qt 事件处理机制"></a>Qt 事件处理机制</h1><h2 id="什么是事件"><a href="#什么是事件" class="headerlink" title="什么是事件"></a>什么是事件</h2><ul>
<li><p>在Qt中，是以事件驱动UI工具集，包括信号和槽都依赖于Qt的事件处理机制。</p>
</li>
<li><p>通常事件是由窗口系统或者Qt自身产生的，用以响应所发生的各类事情，比如用户按下并释放了键盘或者鼠标、窗口因缩放而需要重绘、定时器到期而应有的动作。</p>
</li>
<li><p>事件比信号更原始，一个下压式按钮，首先感受到的是鼠标事件，在进行必要的处理以产生按钮下沉继而弹起的视觉效果之后，才会发射clicked()信号</p>
<p>按钮-&gt;事件emit clicked()-&gt;信号clicked()-&gt;槽onClicked()</p>
</li>
</ul>
<h2 id="如何处理事件"><a href="#如何处理事件" class="headerlink" title="如何处理事件"></a>如何处理事件</h2><ul>
<li><p>Qt中，事件被封装成对象，所有的事件对象类型都继承自抽象类QEvent</p>
</li>
<li><p>当事件发生时，首先被调用的是QObject类中的虚函数event()，其参数(QEvent)标识了具体的事件类型。</p>
</li>
<li><p>在Qt桌面应用（Qt Widgets Application）开发中，QWidget类覆盖了其基类中的event()虚函数，并根据具体事件调用具体事件处理函数：</p>
<ul>
<li><code>void QWidget::mousePressEvent(QMouseEvent* e);//鼠标按下事件</code></li>
<li><code>void QWidget::mouseReleaseEvent(QMouseEvent* e);//鼠标释放事件</code></li>
<li><code>void QWidget::mouseMoveEvent(QMouseEvent* e);//鼠标移动事件</code></li>
<li><code>void QWidget::paintEvent(QPaintEvent* e);//绘图事件</code></li>
</ul>
</li>
<li><p>所有的事件处理函数都是虚函数，可以被QWidget的子类覆盖，以提供针对不同窗口控件类型事件处理，控件的使用者所关心的往往是定义什么样的槽处理什么样的信号，而控件的实现者更关心覆盖哪些事件处理函数。</p>
</li>
<li><p>如果程序员希望在窗口中自定义的处理时间，可以继承QWidget或者其子类，比如QDialog、QMainWindow，在自定义的窗口子类中重写事件处理函数，当相应事件被触发时会利用多态的语法机制，所执行到的事件处理函数，将是子类中重写的版本，从而实现程序员想要的事件处理效果。</p>
</li>
</ul>
<h2 id="绘图事件"><a href="#绘图事件" class="headerlink" title="绘图事件"></a>绘图事件</h2><ul>
<li>通过绘图事件，可以实现自定义的图像绘制，当有下列情况之一发生时，将触发窗口的绘制事件，即QWidget类的paintEvent()虚函数会被调用：<ul>
<li>窗口被创建以后第一次显示出来</li>
<li>窗口由隐藏状态转变为可见状态</li>
<li>窗口由最小化状态转变为正常或最大化状态</li>
<li>窗口因尺寸大小的变化需要呈现更多的内容</li>
<li>QWidget类的update()&#x2F;repaint()成员函数被调用</li>
</ul>
</li>
<li>如果希望在自己的窗口中显示某个图像，在QWidget的窗口子类中可以重写绘图事件函数paintEvent，在其中可以用QPainter（Qt二位图形引擎）实现指定的图像绘制、渲染等操作。</li>
<li>案例：基于资源的图片浏览器</li>
</ul>
<h2 id="定时器事件"><a href="#定时器事件" class="headerlink" title="定时器事件"></a>定时器事件</h2><ul>
<li>Qt通过两套机制为应用程序提供定时功能<ul>
<li>定时器事件，由QObject提供</li>
<li>定时器信号，由QTimer提供</li>
</ul>
</li>
<li>通过定时器事件实现定时器<ul>
<li><code> int QObjectL::startTimer(int interval);</code>启动定时器，以后每隔interval毫秒触发一次定时器事件，返回定时器ID</li>
<li><code> void QObject::timerEvent(QTimerEvent* )[virtual];//定时器事件处理函数</code></li>
<li><code> void QObject::killTimer(int id);//关闭参数id所标识的定时器</code></li>
</ul>
</li>
<li>案例：基于定时器的摇奖机</li>
</ul>
<h2 id="鼠标和键盘事件"><a href="#鼠标和键盘事件" class="headerlink" title="鼠标和键盘事件"></a>鼠标和键盘事件</h2><p>鼠标事件</p>
<ul>
<li>QWidget类定义了以下虚函数提供对鼠标事件的处理，其参数QMouseEvent描述了鼠标事件的细节，如引发事件的鼠标按键、鼠标所在的位置等<ul>
<li><code> virtual void mousePressEvent(QMouseEvent* e);//鼠标按下</code></li>
<li><code> virtual void mouseReleaseEvent(QMouseEvent* e);//鼠标释放</code></li>
<li><code> virtual void mouseDoubleClickEvent(QMouseEvent* e);//鼠标双击</code></li>
<li><code> virtual void mouseMoveEvent(QMouseEvent* e);//鼠标移动</code></li>
</ul>
</li>
<li>案例：鼠标测试，通过鼠标左键拖拽label方块移动</li>
</ul>
<p>键盘事件</p>
<h1 id="Qt-模型-x2F-视图结构"><a href="#Qt-模型-x2F-视图结构" class="headerlink" title="Qt 模型&#x2F;视图结构"></a>Qt 模型&#x2F;视图结构</h1><p>MVC设计模式是起源于Smalltalk的一种与用户界面相关的设计模式。通过使用此模式，可以有效地分离数据和用户界面。</p>
<p>MVC设计模式包括三个元素：</p>
<ul>
<li>表示数据的模型（Model）</li>
<li>表示用户界面的视图（View）</li>
<li>定义了用户在界面上操作的控制器（Controller）</li>
</ul>
<p>Qt中将视图和控制器部件结合在一起，使得框架更为简洁。为了灵活的处理用户输入，Qt框架引入了代理（delegate）。通过使用代理，能够自定义数据条目（item）的显示和编辑方式。</p>
<p>Qt的模型&#x2F;视图结构分为三部分</p>
<ul>
<li><p><strong>模型（Model）</strong></p>
<p>模型与数据源通信，并为其他部件提供接口；</p>
</li>
<li><p><strong>视图（View）</strong></p>
<p>视图从模型中获得用来引用数据条目的模型索引(Model Index)。</p>
</li>
<li><p><strong>代理（Delegate）</strong></p>
<p>在视图中，代理负责绘制数据条目，当编辑条目时，代理和模型直接进行通信。</p>
</li>
</ul>
<p>Model&#x2F;View&#x2F;Delegate之间通过信号和槽进行通信，关系如下：</p>
<ul>
<li>数据发生改变时，模型发出信号通知视图。</li>
<li>用户对界面进行操作，视图发出信号。</li>
<li>代理发出信号告知模型和视图编辑器目前的状态。</li>
</ul>
<p><img src="/image-20230405120120465.png" alt="image-20230405120120465"></p>
<h1 id="Qt-数据库"><a href="#Qt-数据库" class="headerlink" title="Qt 数据库"></a>Qt 数据库</h1><ul>
<li><p>数据库是指以一定方式存储在一起，能为多个用户共享，具有尽可能小的冗余特性，是与应用程序彼此独立的数据集合。</p>
</li>
<li><p>商业数据库</p>
<ul>
<li>甲骨文Oracle</li>
<li>微软Sqlserver</li>
<li>IBM的DB2</li>
</ul>
</li>
<li><p>非商业数据库</p>
<ul>
<li>甲骨文Mysql</li>
<li>开源的SQLite</li>
</ul>
</li>
<li><p>SQLite是一个轻量级的开源数据库，源代码完全公开不受版权限制，实现了自给自足的、无服务器、零配置的SQL数据库引擎，也是最广泛使用的关系型数据库</p>
</li>
<li><p>SQLite引擎不是程序与之通信的独立进程，而是以静态库或共享库的方式连接到程序中，而不同于客户-服务器数据库连接方式，所以主要的使用方法是在编程语言内的直接API调用，当前主流编程语言都提供了sqlite操作的API接口</p>
</li>
<li><p>SQLite在资源消耗、实时性和可操作性有着出色的表现，整个数据库（定义、表、索引和数据本身）都在宿主主机上，存储在一个单一的文件中，通常SQLite的工作是在开始一个事物的时候，锁定整个数据文件而实现的。</p>
</li>
<li><p>SQLite主要特性</p>
<ul>
<li>无服务器的</li>
<li>可以不用配置，安装和管理十分简单</li>
<li>数据库存储在一个单一的跨平台的磁盘文件</li>
<li>轻量级，完全配置时小于400KiB，省略可选功能配置时小于250KiB</li>
<li>自给自足不需要外部依赖</li>
<li>支持SQL92标准的大多数查询语言的功能</li>
<li>事务兼容ACID，允许从多个进程或线程安全访问</li>
</ul>
</li>
<li><p>sqlite3常用命令</p>
<ul>
<li><code> .help</code></li>
<li><code> .database  //查看数据库的名字和对应的文件名</code></li>
<li><code> .open xxx.db</code></li>
<li><code> .table    //查看数据表的名字</code></li>
<li><code> .schema  //查看数据表创建时信息</code></li>
<li><code> .mode   //设置显示模式，如tab/list/column/csv</code></li>
<li><code> .nullvalue  //设置空白字段显示的字符串</code></li>
<li><code> .header on  //显示数据表的表头</code></li>
</ul>
</li>
</ul>
<h1 id="基于Qt框架实现学生成绩管理系统"><a href="#基于Qt框架实现学生成绩管理系统" class="headerlink" title="基于Qt框架实现学生成绩管理系统"></a>基于Qt框架实现学生成绩管理系统</h1><h1 id="Qt-网络编程"><a href="#Qt-网络编程" class="headerlink" title="Qt 网络编程"></a>Qt 网络编程</h1><p><img src="https://subingwen.cn/linux/socket/ip%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B.png" alt="img"></p>
<ul>
<li>物理层：负责最后将信息编码成电流脉冲或其它信号用于网上传输</li>
<li>数据链路层:<br>数据链路层通过物理网络链路供数据传输。<br>规定了 0 和 1 的分包形式，确定了网络数据包的形式；</li>
<li>网络层<br>网络层负责在源和终点之间建立连接；<br>此处需要确定计算机的位置，通过 IPv4，IPv6 格式的 IP 地址来找到对应的主机</li>
<li>传输层<br>传输层向高层提供可靠的端到端的网络数据流服务。<br>每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信</li>
<li>会话层<br>会话层建立、管理和终止表示层与实体之间的通信会话；<br>建立一个连接（自动的手机信息、自动的网络寻址）;</li>
<li>表示层:<br>对应用层数据编码和转化，确保以一个系统应用层发送的信息 可以被另一个系统应用层识别；</li>
</ul>
<p>TCP通信流程</p>
<p>TCP 是一个面向连接的，安全的，流式传输协议，这个协议是一个传输层协议。</p>
<ul>
<li>面向连接：是一个双向连接，通过三次握手完成，断开连接需要通过四次挥手完成。</li>
<li>安全：tcp 通信过程中，会对发送的每一数据包都会进行校验，如果发现数据丢失，会自动重传</li>
<li>流式传输：发送端和接收端处理数据的速度，数据的量都可以不一致</li>
</ul>
<p>服务器端通信流程</p>
<ol>
<li><p>创建用于监听的套接字，这个套接字是一个文件描述符(监听的)</p>
<p><code>int lfd = socket();</code></p>
</li>
<li><p>将得到的监听的文件描述符和本地的 IP 端口进行绑定</p>
<p><code>bind();</code></p>
</li>
<li><p>设置监听 (成功之后开始监听，监听的是客户端的连接)</p>
<p><code>listen();</code></p>
</li>
<li><p>等待并接受客户端的连接请求，建立新的连接，会得到一个新的文件描述符 (通信的)，没有新连接请求就阻塞</p>
<p><code>int cfd = accept();</code></p>
</li>
<li><p>通信，读写操作默认都是阻塞的</p>
<pre><code class="cpp">// 接收数据
read(); / recv();
// 发送数据
write(); / send();
</code></pre>
</li>
<li><p>断开连接，关闭套接字</p>
<p><code>close();</code></p>
</li>
</ol>
<blockquote>
<p>在 tcp 的服务器端，有两类文件描述符</p>
<p>监听的文件描述符<br>只需要有一个<br>不负责和客户端通信，负责检测客户端的连接请求，检测到之后调用 accept 就可以建立新的连接<br>通信的文件描述符<br>负责和建立连接的客户端通信<br>如果有 N 个客户端和服务器建立了新的连接，通信的文件描述符就有 N 个，每个客户端和服务器都对应一个通信的文件描述符</p>
</blockquote>
<p>客户端的通信流程</p>
<p>在单线程的情况下客户端通信的文件描述符有一个，没有监听的文件描述符</p>
<ol>
<li><p>创建一个通信的套接字</p>
<p><code>int cfd = socket();</code></p>
</li>
<li><p>连接服务器，需要知道服务器绑定的 IP 和端口</p>
<p><code>connect();</code></p>
</li>
<li><p>通信</p>
<pre><code class="cpp">// 接收数据
read(); / recv();
// 发送数据
write(); / send();
</code></pre>
</li>
<li><p>断开连接，关闭文件描述符 (套接字)</p>
<p><code>close();</code></p>
</li>
</ol>
<h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><p>在标准 C++ 没有提供专门用于套接字通信的类，所以只能使用操作系统提供的基于 C 的 API 函数，基于这些 C 的 API 函数我们也可以封装自己的 C++ 类。</p>
<p>但是 Qt 就不一样了，它是 C++ 的一个框架并且里边提供了用于套接字通信的类（TCP、UDP）这样就使得我们的操作变得更加简单了（当然，在Qt中使用标准C的API进行套接字通信也是完全没有问题的）。下面，给大家讲一下如果使用相关类的进行 TCP 通信。</p>
<p>使用 Qt 提供的类进行基于 TCP 的套接字通信需要用到两个类：</p>
<ul>
<li>QTcpServer：服务器类，用于监听客户端连接以及和客户端建立连接。</li>
<li>QTcpSocket：通信的套接字类，客户端、服务器端都需要使用。</li>
</ul>
<p>这两个套接字通信类都属于网络模块 network。</p>
<h2 id="QTcpServe"><a href="#QTcpServe" class="headerlink" title="QTcpServe"></a>QTcpServe</h2><p>QTcpServer 类用于监听客户端连接以及和客户端建立连接，在使用之前先介绍一下这个类提供的一些常用 API 函数：</p>
<ul>
<li><p>构造函数</p>
<pre><code class="cpp">QTcpServer::QTcpServer(QObject *parent = Q_NULLPTR);
</code></pre>
</li>
<li><p>给监听的套接字设置监听</p>
<pre><code class="cpp">bool QTcpServer::listen(const QHostAddress &amp;address = QHostAddress::Any, quint16 port = 0);
// 判断当前对象是否在监听, 是返回true，没有监听返回false
bool QTcpServer::isListening() const;
// 如果当前对象正在监听返回监听的服务器地址信息, 否则返回 QHostAddress::Null
QHostAddress QTcpServer::serverAddress() const;
// 如果服务器正在侦听连接，则返回服务器的端口; 否则返回0
quint16 QTcpServer::serverPort() const
</code></pre>
<p>参数：</p>
<ul>
<li>address：通过类 QHostAddress 可以封装 IPv4、IPv6 格式的 IP 地址，QHostAddress::Any 表示自动绑定</li>
<li>port：如果指定为 0 表示随机绑定一个可用端口。使用时要指定一个端口</li>
</ul>
<p>返回值：</p>
<ul>
<li>绑定成功返回 true，失败返回 false</li>
</ul>
</li>
<li><p>得到和客户端建立连接之后用于通信的 QTcpSocket 套接字对象，它是 QTcpServer 的一个子对象，当 QTcpServer 对象析构的时候会自动析构这个子对象，当然也可自己手动析构，建议用完之后自己手动析构这个通信的 QTcpSocket 对象。</p>
<pre><code class="cpp">QTcpSocket *QTcpServer::nextPendingConnection();
</code></pre>
</li>
<li><p>阻塞等待客户端发起的连接请求，不推荐在单线程程序中使用，建议使用非阻塞方式处理新连接，即使用信号 newConnection() 。</p>
<pre><code class="cpp">bool QTcpServer::waitForNewConnection(int msec = 0, bool *timedOut = Q_NULLPTR);
</code></pre>
<p>参数：</p>
<ul>
<li>msec：指定阻塞的最大时长，单位为毫秒（ms）</li>
<li>timeout：传出参数，如果操作超时 timeout 为 true，没有超时 timeout 为 false</li>
</ul>
</li>
<li><p>信号</p>
<ul>
<li><p>当接受新连接导致错误时，将发射如下信号。socketError 参数描述了发生的错误相关的信息。</p>
<pre><code class="cpp">[signal] void QTcpServer::acceptError(QAbstractSocket::SocketError socketError);
</code></pre>
</li>
<li><p>每次有新连接可用时都会发出 newConnection () 信号。</p>
<pre><code class="cpp">[signal] void QTcpServer::newConnection();
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="QTcpSocket"><a href="#QTcpSocket" class="headerlink" title="QTcpSocket"></a>QTcpSocket</h2><p>QTcpSocket 是一个套接字通信类，不管是客户端还是服务器端都需要使用。在 Qt 中发送和接收数据也属于 IO 操作（网络 IO），先来看一下这个类的继承关系：</p>
<p><img src="https://subingwen.cn/qt/socket-tcp/image-20210512174459252.png" alt="image-20210512174459252"></p>
<ul>
<li><p>构造函数</p>
<pre><code class="cpp">QTcpSocket::QTcpSocket(QObject *parent = Q_NULLPTR);
</code></pre>
</li>
<li><p>连接服务器，需要指定服务器端绑定的IP和端口信息。</p>
<pre><code class="cpp">[virtual] void QAbstractSocket::connectToHost(const QString &amp;hostName, quint16 port, OpenMode openMode = ReadWrite, NetworkLayerProtocol protocol = AnyIPProtocol);

[virtual] void QAbstractSocket::connectToHost(const QHostAddress &amp;address, quint16 port, OpenMode openMode = ReadWrite);
</code></pre>
<p>在 Qt 中不管调用读操作函数接收数据，还是调用写函数发送数据，操作的对象都是本地的由 Qt 框架维护的一块内存。因此，调用了发送函数数据不一定会马上被发送到网络中，调用了接收函数也不是直接从网络中接收数据，关于底层的相关操作是不需要使用者来维护的。</p>
</li>
<li><p>接收数据</p>
<pre><code class="cpp">// 指定可接收的最大字节数 maxSize 的数据到指针 data 指向的内存中
qint64 QIODevice::read(char *data, qint64 maxSize);
// 指定可接收的最大字节数 maxSize，返回接收的字符串
QByteArray QIODevice::read(qint64 maxSize);
// 将当前可用操作数据全部读出，通过返回值返回读出的字符串
QByteArray QIODevice::readAll();
</code></pre>
</li>
<li><p>发送数据</p>
<pre><code class="cpp">// 发送指针 data 指向的内存中的 maxSize 个字节的数据
qint64 QIODevice::write(const char *data, qint64 maxSize);
// 发送指针 data 指向的内存中的数据，字符串以 \0 作为结束标记
qint64 QIODevice::write(const char *data);
// 发送参数指定的字符串
qint64 QIODevice::write(const QByteArray &amp;byteArray);
</code></pre>
</li>
</ul>
<h2 id="描述Qt下Tcp通信的整个流程"><a href="#描述Qt下Tcp通信的整个流程" class="headerlink" title="描述Qt下Tcp通信的整个流程"></a>描述Qt下Tcp通信的整个流程</h2><p>具体解释 ：<a href="https://link.zhihu.com/?target=https://www.cnblogs.com/yuweifeng/p/9382841.html">https://www.cnblogs.com/yuweifeng/p/9382841.html</a></p>
<p>QT如果要进行<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22611735332%22%7D">网络编程</a>首先需要在.pro中添加如下代码：QT +&#x3D; network</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22611735332%22%7D">服务器端</a>:<br>\1. 创建用于监听的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%A5%97%E6%8E%A5%E5%AD%97&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22611735332%22%7D">套接字</a><br>\2. 给套接字设置监听<br>\3. 如果有连接到来, 监听的套接字会发出信号newConnected<br>\4. 接收连接, 通过nextPendingConnection()函数, 返回一个QTcpSocket类型的套接字对象(用于通信)<br>\5. 使用用于通信的套接字对象通信<br>1&gt;. 发送数据: write<br>2&gt;. 接收数据: readAll&#x2F;read<br>客户端:<br>\1. 创建用于通信的套接字<br>\2. 连接服务器: connectToHost<br>\3. 连接成功与服务器通信<br>1&gt;. 发送数据: write<br>2&gt;. 接收数据: readAll&#x2F;read</p>
<h2 id="描述QT下udp通信的整个流程"><a href="#描述QT下udp通信的整个流程" class="headerlink" title="描述QT下udp通信的整个流程"></a>描述QT下udp通信的整个流程</h2><p>QT下udp通信服务器端和客户端的关系是对等的, 做的处理也是一样的.<br>\1. 创建套接字对象<br>\2. 如果需要接收数据, 必须绑定端口<br>\3. 发送数据: writeDatagram<br>\4. 接收数据: readDatagram</p>
<h1 id="Qt-多线程"><a href="#Qt-多线程" class="headerlink" title="Qt 多线程"></a>Qt 多线程</h1><p>在进行桌面应用程序开发的时候， 假设应用程序在某些情况下需要处理比较复杂的逻辑， 如果只有一个线程去处理，就会导致窗口卡顿，无法处理用户的相关操作。这种情况下就需要使用多线程，其中<strong>一个线程处理窗口事件，其他线程进行逻辑运算，多个线程各司其职，不仅可以提高用户体验还可以提升程序的执行效率。</strong></p>
<p>在 qt 中使用了多线程，有些事项是需要额外注意的：</p>
<ul>
<li>默认的线程在Qt中称之为窗口(ui)线程，也叫主线程，负责<strong>窗口事件处理</strong>或者<strong>窗口控件数据的更新</strong>。</li>
<li>子线程负责<strong>后台的业务逻辑处理</strong>，子线程中不能对窗口对象做任何操作，这些事情需要交给窗口线程处理。</li>
<li>主线程和子线程之间如果要进行数据的传递，需要使用Qt中的信号槽机制。</li>
</ul>
<h2 id="线程类QThread"><a href="#线程类QThread" class="headerlink" title="线程类QThread"></a>线程类QThread</h2><p>Qt 中提供了一个线程类，通过这个类就可以创建子线程了，Qt 中一共提供了两种创建子线程的方式，后边会依次介绍其使用方式。先来看一下这个类中提供的一些常用 API 函数：</p>
<h3 id="常用公共成员函数"><a href="#常用公共成员函数" class="headerlink" title="常用公共成员函数"></a>常用公共成员函数</h3><pre><code class="cpp">// QThread 类常用 API
// 构造函数
QThread::QThread(QObject *parent = Q_NULLPTR);
// 判断线程中的任务是不是处理完毕了
bool QThread::isFinished() const;
// 判断子线程是不是在执行任务
bool QThread::isRunning() const;

// Qt中的线程可以设置优先级
// 得到当前线程的优先级
Priority QThread::priority() const;
void QThread::setPriority(Priority priority);
优先级:
    QThread::IdlePriority         --&gt; 最低的优先级
    QThread::LowestPriority
    QThread::LowPriority
    QThread::NormalPriority
    QThread::HighPriority
    QThread::HighestPriority
    QThread::TimeCriticalPriority --&gt; 最高的优先级
    QThread::InheritPriority      --&gt; 子线程和其父线程的优先级相同, 默认是这个
// 退出线程, 停止底层的事件循环
// 退出线程的工作函数
void QThread::exit(int returnCode = 0);
// 调用线程退出函数之后, 线程不会马上退出因为当前任务有可能还没有完成, 调回用这个函数是
// 等待任务完成, 然后退出线程, 一般情况下会在 exit() 后边调用这个函数
bool QThread::wait(unsigned long time = ULONG_MAX);
</code></pre>
<h3 id="信号槽"><a href="#信号槽" class="headerlink" title="信号槽"></a>信号槽</h3><pre><code class="cpp">// 和调用 exit() 效果是一样的
// 代用这个函数之后, 再调用 wait() 函数
[slot] void QThread::quit();
// 启动子线程
[slot] void QThread::start(Priority priority = InheritPriority);
// 线程退出, 可能是会马上终止线程, 一般情况下不使用这个函数
[slot] void QThread::terminate();

// 线程中执行的任务完成了, 发出该信号
// 任务函数中的处理逻辑执行完毕了
[signal] void QThread::finished();
// 开始工作之前发出这个信号, 一般不使用
[signal] void QThread::started();
</code></pre>
<h3 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h3><pre><code class="cpp">// 返回一个指向管理当前执行线程的QThread的指针
[static] QThread *QThread::currentThread();
// 返回可以在系统上运行的理想线程数 == 和当前电脑的 CPU 核心数相同
[static] int QThread::idealThreadCount();
// 线程休眠函数
[static] void QThread::msleep(unsigned long msecs);	// 单位: 毫秒
[static] void QThread::sleep(unsigned long secs);	// 单位: 秒
[static] void QThread::usleep(unsigned long usecs);	// 单位: 微秒
</code></pre>
<h3 id="任务处理函数"><a href="#任务处理函数" class="headerlink" title="任务处理函数"></a>任务处理函数</h3><pre><code class="cpp">// 子线程要处理什么任务, 需要写到 run() 中
[virtual protected] void QThread::run();
</code></pre>
<p>这个 run() 是一个虚函数，如果想让创建的子线程执行某个任务，需要写一个子类让其继承 QThread，并且在子类中重写父类的 run() 方法，函数体就是对应的任务处理流程。另外，这个函数是一个受保护的成员函数，不能够在类的外部调用，如果想要让线程执行这个函数中的业务流程，需要通过当前线程对象调用槽函数 start() 启动子线程，当子线程被启动，这个 run() 函数也就在线程内部被调用了。</p>
<h2 id="线程使用方式1"><a href="#线程使用方式1" class="headerlink" title="线程使用方式1"></a>线程使用方式1</h2><ul>
<li><p>需要创建一个线程类的子类，让其继承 QT 中的线程类 QThread</p>
<pre><code class="cpp">class MyThread:public QThread
&#123;
    ......
&#125;
</code></pre>
</li>
<li><p>重写父类的 run () 方法，在该函数内部编写子线程要处理的具体的业务流程</p>
<pre><code class="cpp">class MyThread:public QThread
&#123;
    ......
 protected:
    void run()
    &#123;
        ........
    &#125;
&#125;
</code></pre>
</li>
<li><p>在主线程中创建子线程对象，new 一个就可以了</p>
<pre><code class="cpp">MyThread * subThread = new MyThread;
</code></pre>
</li>
<li><p>启动子线程，调用 start () 方法</p>
<pre><code class="cpp">subThread-&gt;start();
</code></pre>
<p>不能在类的外部调用 run () 方法启动子线程，在外部调用 start () 相当于让 run () 开始运行</p>
</li>
</ul>
<p>当子线程别创建出来之后，父子线程之间的通信可以通过信号槽的方式，注意事项:</p>
<ul>
<li>在 Qt 中在子线程中不要操作程序中的窗口类型对象，不允许，如果操作了程序就挂了</li>
<li>只有主线程才能操作程序中的窗口对象，默认的线程就是主线程，自己创建的就是子线程</li>
</ul>
<p>这种在程序中添加子线程的方式是非常简单的，但是也有弊端，假设要在一个子线程中处理多个任务，所有的处理逻辑都需要写到run()函数中，这样该函数中的处理逻辑就会变得非常混乱，不太容易维护。</p>
<h2 id="线程使用方式2"><a href="#线程使用方式2" class="headerlink" title="线程使用方式2"></a>线程使用方式2</h2><p>Qt 提供的第二种线程的创建方式弥补了第一种方式的缺点，用起来更加灵活，但是这种方式写起来会相对复杂一些，其具体操作步骤如下：</p>
<ul>
<li><p>创建一个新的类，让这个类从 QObject 派生</p>
<pre><code class="cpp">class MyWork:public QObject
&#123;
    .......
&#125;
</code></pre>
</li>
<li><p>在这个类中添加一个公共的成员函数，函数体就是我们要子线程中执行的业务逻辑</p>
<pre><code class="cpp">class MyWork:public QObject
&#123;
public:
    .......
    // 函数名自己指定, 叫什么都可以, 参数可以根据实际需求添加
    void working();
&#125;
</code></pre>
</li>
<li><p>在主线程中创建一个 QThread 对象，这就是子线程的对象</p>
<pre><code class="cpp">QThread* sub = new QThread;
</code></pre>
</li>
<li><p>在主线程中创建工作的类对象（千万不要指定给创建的对象指定父对象）</p>
<pre><code class="cpp">MyWork* work = new MyWork(this);    // error
MyWork* work = new MyWork;          // ok
</code></pre>
</li>
<li><p>将 MyWork 对象移动到创建的子线程对象中，需要调用 QObject 类提供的 moveToThread() 方法。</p>
<pre><code class="cpp">// void QObject::moveToThread(QThread *targetThread);
// 如果给work指定了父对象, 这个函数调用就失败了
// 提示： QObject::moveToThread: Cannot move objects with a parent
work-&gt;moveToThread(sub);	// 移动到子线程中工作
</code></pre>
</li>
<li><p>启动子线程，调用 start(), 这时候线程启动了，但是移动到线程中的对象并没有工作</p>
</li>
<li><p>调用 MyWork 类对象的工作函数，让这个函数开始执行，这时候是在移动到的那个子线程中运行的</p>
</li>
</ul>
<p>使用这种多线程方式，假设有多个不相关的业务流程需要被处理，那么就可以创建多个类似于 MyWork 的类，将业务流程放多类的公共成员函数中，然后将这个业务类的实例对象移动到对应的子线程中 moveToThread() 就可以了，这样可以让编写的程序更加灵活，可读性更强，更易于维护。</p>
<h2 id="线程资源释放"><a href="#线程资源释放" class="headerlink" title="线程资源释放"></a>线程资源释放</h2><h2 id="Qt线程池"><a href="#Qt线程池" class="headerlink" title="Qt线程池"></a>Qt线程池</h2><h3 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h3><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？</p>
<p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）, 则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p>
<p>在各个编程语言的语种中都有线程池的概念，并且很多语言中直接提供了线程池，作为程序猿直接使用就可以了，下面给大家介绍一下线程池的实现原理：</p>
<p>线程池的组成主要分为 3 个部分，这三部分配合工作就可以得到一个完整的线程池：</p>
<ul>
<li><p>任务队列，存储需要处理的任务，由工作的线程来处理这些任务</p>
<ul>
<li>通过线程池提供的 API 函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除</li>
<li>已处理的任务会被从任务队列中删除</li>
<li>线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程</li>
</ul>
</li>
<li><p>工作的线程（任务队列任务的消费者） ，N 个</p>
<ul>
<li>线程池中维护了一定数量的工作线程，他们的作用是是不停的读任务队列，从里边取出任务并处理</li>
<li>工作的线程相当于是任务队列的消费者角色，</li>
<li>如果任务队列为空，工作的线程将会被阻塞 (使用条件变量 &#x2F; 信号量阻塞)</li>
<li>如果阻塞之后有了新的任务，由生产者将阻塞解除，工作线程开始工作</li>
</ul>
</li>
<li><p>管理者线程（不处理任务队列中的任务），1 个</p>
<p>它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测</p>
<ul>
<li>当任务过多的时候，可以适当的创建一些新的工作线程</li>
<li>当任务过少的时候，可以适当的销毁一些工作的线程</li>
</ul>
</li>
</ul>
<p><img src="https://subingwen.cn/qt/threadpool/R9c00030b842edb1ae3d6a2b286e53916" alt="查看源图像"></p>
<h3 id="QRunnable"><a href="#QRunnable" class="headerlink" title="QRunnable"></a>QRunnable</h3><p>在 Qt 中使用线程池需要先创建任务，<strong>添加到线程池中的每一个任务都需要是一个 QRunnable 类型</strong>，因此在程序中需要创建子类继承 QRunnable 这个类，然后重写 run() 方法，在这个函数中编写要在线程池中执行的任务，并将这个子类对象传递给线程池，这样任务就可以被线程池中的某个工作的线程处理掉了。</p>
<p>QRunnable 类 常用函数不多，主要是设置任务对象传给线程池后，是否需要自动析构。</p>
<pre><code class="c++">// 在子类中必须要重写的函数, 里边是任务的处理流程
[pure virtual] void QRunnable::run();

// 参数设置为 true: 这个任务对象在线程池中的线程中处理完毕, 这个任务对象就会自动销毁
// 参数设置为 false: 这个任务对象在线程池中的线程中处理完毕, 对象需要程序猿手动销毁
void QRunnable::setAutoDelete(bool autoDelete);
// 获取当前任务对象的析构方式,返回true-&gt;自动析构, 返回false-&gt;手动析构
bool QRunnable::autoDelete() const;
</code></pre>
<p>创建一个要添加到线程池中的任务类，处理方式如下：</p>
<pre><code class="c++">class MyWork : public QObject, public QRunnable
&#123;
    Q_OBJECT
public:
    explicit MyWork(QObject *parent = nullptr)
    &#123;
        // 任务执行完毕,该对象自动销毁
        setAutoDelete(true);
    &#125;
    ~MyWork();

    void run() override&#123;&#125;
&#125;
</code></pre>
<p>在上面的示例中 MyWork 类是一个多重继承，如果需要在这个任务中使用 Qt 的信号槽机制进行数据的传递就必须继承 QObject 这个类，如果不使用信号槽传递数据就可以不继承了，只继承 QRunnable 即可。</p>
<pre><code class="c++">class MyWork :public QRunnable
&#123;
    Q_OBJECT
public:
    explicit MyWork()
    &#123;
        // 任务执行完毕,该对象自动销毁
        setAutoDelete(true);
    &#125;
    ~MyWork();

    void run() override&#123;&#125;
&#125;
</code></pre>
<h3 id="QThreadPool"><a href="#QThreadPool" class="headerlink" title="QThreadPool"></a>QThreadPool</h3><p>Qt 中的 QThreadPool 类管理了一组 QThreads, 里边还维护了一个任务队列。QThreadPool 管理和回收各个 QThread 对象，以帮助减少使用线程的程序中的线程创建成本。每个Qt应用程序都有一个全局 QThreadPool 对象，可以通过调用 globalInstance() 来访问它。也可以单独创建一个 QThreadPool 对象使用。</p>
<p>线程池常用的 API 函数如下：</p>
<pre><code class="c++">// 获取和设置线程中的最大线程个数
int maxThreadCount() const;
void setMaxThreadCount(int maxThreadCount);

// 给线程池添加任务, 任务是一个 QRunnable 类型的对象
// 如果线程池中没有空闲的线程了, 任务会放到任务队列中, 等待线程处理
void QThreadPool::start(QRunnable * runnable, int priority = 0);
// 如果线程池中没有空闲的线程了, 直接返回值, 任务添加失败, 任务不会添加到任务队列中
bool QThreadPool::tryStart(QRunnable * runnable);

// 线程池中被激活的线程的个数(正在工作的线程个数)
int QThreadPool::activeThreadCount() const;

// 尝试性的将某一个任务从线程池的任务队列中删除, 如果任务已经开始执行就无法删除了
bool QThreadPool::tryTake(QRunnable *runnable);
// 将线程池中的任务队列里边没有开始处理的所有任务删除, 如果已经开始处理了就无法通过该函数删除了
void QThreadPool::clear();

// 在每个Qt应用程序中都有一个全局的线程池对象, 通过这个函数直接访问这个对象
static QThreadPool * QThreadPool::globalInstance();
</code></pre>
<p>一般情况下，我们不需要在 Qt 程序中创建线程池对象，直接使用 Qt 为每个应用程序提供的线程池全局对象即可。得到线程池对象之后，调用 start() 方法就可以将一个任务添加到线程池中，这个任务就可以被线程池内部的线程池处理掉了，使用线程池比自己创建线程的这种多种多线程方式更加简单和易于维护。</p>
<h1 id="基于Qt框架实现网络聊天室项目"><a href="#基于Qt框架实现网络聊天室项目" class="headerlink" title="基于Qt框架实现网络聊天室项目"></a>基于Qt框架实现网络聊天室项目</h1><p>服务器：基于TCP协议创建服务器</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #03a9f4">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Qt/" style="color: #ff7d73">
                Qt
            </a>
        </span>
        
    </div>
    <a href="/2023/03/12/QtStudy/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/03/12/STL%E5%87%BD%E6%95%B0/">
        <h2 class="post-title">STL函数</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/C/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                C++
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/12
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h1><ul>
<li><p><code> accumulate(beg, end, init)</code></p>
</li>
<li><p><strong>复杂度：</strong>O(N)</p>
</li>
<li><p>作用：对一个序列的元素求和</p>
</li>
<li><p><code>init</code>为对序列元素求和的<strong>初始值</strong></p>
</li>
<li><p>返回值类型：与<code>init</code>一致</p>
</li>
<li><p><strong>基础累加求和：</strong></p>
<pre><code class="cpp">int a[]=&#123;1,3,5,9,10&#125;;

//对[0,2]区间求和，初始值为0，结果为0+1+3+5=9
int res1 = accumulate(a, a + 3, 0);

//对[0,3]区间求和，初始值为5，结果为5+1+3+5+9=23
int res2 = accumulate(a, a + 4, 5);
</code></pre>
</li>
<li><p><strong>自定义二元对象求和：</strong>使用lambda表达式</p>
<pre><code class="cpp">typedef long long ll;
struct node
&#123;
    ll num;
&#125;st[10];

for(int i = 1; i &lt;= n; i++)
    st[i].num = i + 10000000000;
//返回值类型与init一致，同时注意参数类型（a）也要一样
//初始值为1，累加1+10000000001+10000000002+10000000003=30000000007
ll res = accumulate(st + 1, st + 4, 1ll, [](ll a,node b)&#123;
    return a + b.num;
&#125;);
</code></pre>
</li>
</ul>
<h1 id="atoi"><a href="#atoi" class="headerlink" title="atoi"></a>atoi</h1><ul>
<li><p><code>atoi(const char *)</code></p>
</li>
<li><p>将字符串转换为<code>int</code>类型</p>
</li>
<li><p>注意参数为<code>char</code>型数组，如果需要将string类型转换为int类型，可以使用<code>stoi</code>函数（参考下文），或者将<code>string</code>类型转换为<code>const char *</code>类型。</p>
</li>
<li><p>关于输出数字的范围：<br><code>atoi</code><strong>不做</strong>范围检查，如果超出上界，输出上界，超出下界，输出下界。<br><code>stoi</code><strong>会做</strong>范围检查，默认必须在<code>int</code>范围内，如果超出范围，会出现RE（Runtime Error）错误。</p>
</li>
<li><pre><code class="cpp">string s = &quot;1234&quot;;
int a = atoi(s.c_str());
cout &lt;&lt; a &lt;&lt; &quot;\n&quot;; // 1234
</code></pre>
<pre><code class="cpp">char s[] = &quot;1234&quot;;
int a = atoi(s);
cout &lt;&lt; a &lt;&lt; &quot;\n&quot;;
</code></pre>
</li>
</ul>
<h1 id="stoi"><a href="#stoi" class="headerlink" title="stoi"></a>stoi</h1><ul>
<li><p><code>stoi(const string*)</code></p>
</li>
<li><p>将对应string类型字符串转换为数字</p>
</li>
<li><p>注意参数为<code>string</code>字符串类型。</p>
<p>关于输出数字的范围：<br><code>stoi</code><strong>会做</strong>范围检查，默认必须在<code>int</code>范围内，如果超出范围，会出现RE（Runtime Error）错误。<br><code>atoi</code><strong>不做</strong>范围检查，如果超出上界，输出上界，超出下界，输出下界。</p>
</li>
<li><pre><code class="cpp">string s = &quot;1234&quot;;
int a = atoi(s);
cout &lt;&lt; a &lt;&lt; &quot;\n&quot;; // 1234
</code></pre>
</li>
</ul>
<h1 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h1><ul>
<li><p><code>iota(beg, end)</code></p>
</li>
<li><p>让序列递增赋值</p>
</li>
<li><pre><code class="cpp">vector&lt;int&gt; a(10);
iota(a.begin(), a.end(), 0);
for(auto i : a)
    cout &lt;&lt; i &lt;&lt; &quot; &quot;;
// 0 1 2 3 4 5 6 7 8 9
</code></pre>
</li>
</ul>
<h1 id="to-string"><a href="#to-string" class="headerlink" title="to_string"></a>to_string</h1><ul>
<li><p>将数字转化为字符串,支持小数（double）</p>
</li>
<li><pre><code class="cpp">int a = 12345678;
cout &lt;&lt; to_string(a) &lt;&lt; &#39;\n&#39;;
</code></pre>
</li>
</ul>
<h1 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h1><ul>
<li><p><code>fill(beg,end,num)</code></p>
</li>
<li><p>对一个序列进行初始化赋值</p>
</li>
<li><p><strong>复杂度：</strong> O(N)</p>
</li>
<li><pre><code class="cpp">//对a数组的所有元素赋1
int a[5];
fill(a,a+5,1);
for(int i=0;i&lt;5;i++)
    cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;
//1 1 1 1 1
</code></pre>
</li>
<li><p>注意区分memset：</p>
<p><code>memset()</code>是按<strong>字节</strong>进行赋值，对于初始化赋<code>0</code>或<code>-1</code>有比较好的效果.</p>
<p>如果赋某个特定的数会<strong>出错</strong>，赋值特定的数建议使用<code>fill()</code></p>
</li>
</ul>
<h1 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h1><ul>
<li><p><code>reverse(beg,end)</code></p>
</li>
<li><p>对序列进行翻转</p>
</li>
<li><p><strong>复杂度：</strong> O(N)</p>
</li>
<li><pre><code class="cpp">string s = &quot;abcde&quot;;
reverse(s.begin(), s.end());//对s进行翻转
cout &lt;&lt; s &lt;&lt; &#39;\n&#39;;//edcba

//对a数组进行翻转
int a[] = &#123;1, 2, 3, 4&#125;;
reverse(a, a + 4);
cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3];//4321
</code></pre>
</li>
</ul>
<h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><ul>
<li><p><code>sort(beg, end)</code></p>
</li>
<li><p>&#96;&#96;sort(beg, end, cmp)&#96;</p>
<p>再定义一个比较函数，通常对条件筛选进行排序，一般与结构体连用。</p>
</li>
<li><p>对一个序列进行排序</p>
</li>
<li><p><strong>复杂度：</strong> O(NlogN)</p>
</li>
<li><pre><code class="cpp">//对a数组的[1,n]位置进行从小到大排序
sort(a + 1, a + 1 + n);

//对a数组的[0,n-1]位置从大到小排序
sort(a, a + n, greater&lt;int&gt;());
//对a数组的[0,n-1]位置从小到大排序
sort(a, a + n, less&lt;int&gt;());

//自定义排序，定义比较函数
bool cmp(node a,node b)
&#123;
    //按结构体里面的x值降序排列
    return a.x &gt; b.x;
&#125;
sort(node, node + n, cmp); // 只能接受 以函数为形式的自定义排序规则，无法接受以结构体为形式的自定义排序规则
</code></pre>
</li>
</ul>
<h1 id="stable-sort"><a href="#stable-sort" class="headerlink" title="stable_sort"></a>stable_sort</h1><h1 id="is-sorted"><a href="#is-sorted" class="headerlink" title="is_sorted"></a>is_sorted</h1><h1 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h1><h1 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h1><h1 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound + upper_bound"></a>lower_bound + upper_bound</h1><ul>
<li><p>二分查找</p>
</li>
<li><p><strong>复杂度：</strong> O(logN)</p>
</li>
<li><pre><code class="cpp">//在a数组中查找第一个大于等于x的元素，返回该元素的地址
lower_bound(a, a + n, x);
//在a数组中查找第一个大于x的元素，返回该元素的地址
upper_bound(a, a + n, x);

//如果未找到，返回尾地址的下一个位置的地址
</code></pre>
</li>
</ul>
<h1 id="max-element-min-element"><a href="#max-element-min-element" class="headerlink" title="max_element+min_element"></a>max_element+min_element</h1><h1 id="max-min"><a href="#max-min" class="headerlink" title="max+min"></a>max+min</h1><h1 id="minmax"><a href="#minmax" class="headerlink" title="minmax"></a>minmax</h1><h1 id="minmax-element"><a href="#minmax-element" class="headerlink" title="minmax_element"></a>minmax_element</h1><h1 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h1><h1 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h1><h1 id="partial-sort"><a href="#partial-sort" class="headerlink" title="partial_sort"></a>partial_sort</h1><h1 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h1><h1 id="gcd"><a href="#gcd" class="headerlink" title="__gcd"></a>__gcd</h1><h1 id="lg"><a href="#lg" class="headerlink" title="__lg"></a>__lg</h1><h1 id="builtin-内置位运算函数"><a href="#builtin-内置位运算函数" class="headerlink" title="_builtin 内置位运算函数"></a>_<em>builtin</em> 内置位运算函数</h1><h2 id="builtin-ffs"><a href="#builtin-ffs" class="headerlink" title="__builtin_ffs"></a>__builtin_ffs</h2><h2 id="builtin-popcount"><a href="#builtin-popcount" class="headerlink" title="__builtin_popcount"></a>__builtin_popcount</h2><h2 id="builtin-ctz"><a href="#builtin-ctz" class="headerlink" title="__builtin_ctz"></a>__builtin_ctz</h2><h2 id="builtin-clz"><a href="#builtin-clz" class="headerlink" title="__builtin_clz"></a>__builtin_clz</h2><h2 id="builtin-parity"><a href="#builtin-parity" class="headerlink" title="__builtin_parity"></a>__builtin_parity</h2>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00a596">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/STL/" style="color: #ffa2c4">
                STL
            </a>
        </span>
        
    </div>
    <a href="/2023/03/12/STL%E5%87%BD%E6%95%B0/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/03/10/STL%E5%AE%B9%E5%99%A8/">
        <h2 class="post-title">STL容器</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/C/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                C++
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/10
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>vector为可变长数组（动态数组），定义的vector数组可以随时添加数值和删除元素。</p>
<p>在局部函数中开vector数组，是在堆空间里面开的，与开全局变量比较类似，所以经常见到在局部函数中开大容量数组。</p>
<ul>
<li><p>头文件</p>
<pre><code class="cpp">#include &lt;vector&gt;
</code></pre>
</li>
<li><p>初始化</p>
<ul>
<li><p>一维初始化</p>
<pre><code class="cpp">vector&lt;int&gt; a; //定义了一个名为num的存int数据的一维数组
vector&lt;double&gt; b;//定义了一个名为num的存double数据的一维数组
vector&lt;node&gt; c;//node是结构体类型
</code></pre>
<p>指定长度和初始值的初始化</p>
<pre><code class="cpp">vector&lt;int&gt; v(n);//定义一个长度为n的数组，初始值默认为0
vector&lt;int&gt; v(n, 1);//所有的元素初始值均为1
//注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了）
//就不能使用push_back()操作了
</code></pre>
<p>初始化中有多个元素</p>
<pre><code class="cpp">vector&lt;int&gt; a&#123;1, 2, 3, 4, 5&#125;;// 数组a中有五个元素
</code></pre>
<p>拷贝初始化</p>
<pre><code class="cpp">vector&lt;int&gt; a(n + 1, 0);
vector&lt;int&gt; b(a);//两个数组中的类型必须相同,a和b都是长度为n+1，所有值都为0的数组
</code></pre>
</li>
<li><p>二维初始化</p>
<p>定义第一维固定长度为5，第二维可变化的二维数组</p>
<pre><code class="cpp">vector&lt;int&gt; v[5];//定义可变长二维数组
//注意：行不可变（只有5行）, 而列可变,可以在指定行添加元素
//第一维固定长度为5，第二维长度可以改变
</code></pre>
<p>行列均可变</p>
<pre><code class="cpp">//初始化二维均可变长数组
vector&lt;vectot&lt;int&gt; &gt; v;//定义一个行和列均可变的二维数组
</code></pre>
<p>行列长度均固定 n + 1行 m + 1列初始值为0</p>
<pre><code class="cpp">vector&lt;vector&lt;int&gt; &gt; a(n + 1, vector&lt;int&gt;(m + 1, 0));
</code></pre>
<p><code>c++17</code>或者<code>c++20</code>支持的形式（不常用）</p>
<pre><code class="cpp">vector a(n + 1, vector(m + 1, 0));
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="方法函数"><a href="#方法函数" class="headerlink" title="方法函数"></a>方法函数</h2><p>知道了如何定义初始化可变数组，下面就需要知道如何添加，删除，修改数据。</p>
<p><strong>c指定为数组名称</strong>，含义中会注明算法复杂度。</p>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>c.front()</code></td>
<td align="left">返回第一个数据O(1)</td>
</tr>
<tr>
<td align="left"><code>c.pop_back()</code></td>
<td align="left">删除最后一个数据O(1)</td>
</tr>
<tr>
<td align="left"><code>c.push_back(element)</code></td>
<td align="left">在尾部加一个数据O(1)</td>
</tr>
<tr>
<td align="left"><code>c.size()</code></td>
<td align="left">返回实际数据个数（unsigned类型）O(1)</td>
</tr>
<tr>
<td align="left"><code>c.clear()</code></td>
<td align="left">清除元素个数O(N)，N为元素个数</td>
</tr>
<tr>
<td align="left"><code>c.resize(n, v)</code></td>
<td align="left">改变数组大小为<code>n</code>,<code>n</code>个空间数值赋为<code>v</code>，如果没有默认赋值为<code>0</code></td>
</tr>
<tr>
<td align="left"><code>c.insert(it, x)</code></td>
<td align="left">向任意迭代器<code>it</code>插入一个元素<code>x</code> ，O(N)</td>
</tr>
<tr>
<td align="left">例：<code>c.insert(c.begin()+2,-1)</code></td>
<td align="left">将<code>-1</code>插入<code>c[2]</code>的位置</td>
</tr>
<tr>
<td align="left"><code>c.erase(first,last)</code></td>
<td align="left">删除<code>[first,last)</code>的所有元素，O(N)</td>
</tr>
<tr>
<td align="left"><code>c.begin()</code></td>
<td align="left">返回首元素的迭代器（通俗来说就是地址）O(1)</td>
</tr>
<tr>
<td align="left"><code>c.end()</code></td>
<td align="left">返回最后一个元素后一个位置的迭代器（地址）O(1)</td>
</tr>
<tr>
<td align="left"><code>c.empty()</code></td>
<td align="left">判断是否为空，为空返回真，反之返回假 O(1)</td>
</tr>
</tbody></table>
<p>注意： <code>end()</code>返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，<strong>所有STL容器均是如此</strong></p>
<p>排序</p>
<p>使用sort排序要： <code>sort(c.begin(),c.end())</code>;</p>
<p>对所有元素进行排序，如果要对指定区间进行排序，可以对sort()里面的参数进行加减改动。</p>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p><strong>下标法</strong>： 和普通数组一样</p>
<p>注意：一维数组的下标是从0到v.size( ) − 1，访问之外的数会出现越界错误</p>
<p>迭代器法： 类似指针一样的访问 ，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码进行理解（附有注释）。</p>
<p>代码如下：</p>
<pre><code class="cpp">vector&lt;int&gt; vi; //定义一个vi数组
vector&lt;int&gt;::iterator it = vi.begin();//声明一个迭代器指向vi的初始位置
</code></pre>
<p><strong>下标访问</strong></p>
<pre><code class="cpp">//添加元素
for(int i = 0; i &lt; 5; i++)
    vi.push_back(i);
    
//下标访问 
for(int i = 0; i &lt; 5; i++)
    cout &lt;&lt; vi[i] &lt;&lt; &quot; &quot;;
cout &lt;&lt; &quot;\n&quot;;
</code></pre>
<p><strong>迭代器访问</strong></p>
<p>类似指针。</p>
<pre><code class="cpp">//迭代器访问
vector&lt;int&gt;::iterator it;   
//相当于声明了一个迭代器类型的变量it
//通俗来说就是声明了一个指针变量

//方式一：
vector&lt;int&gt;::iterator it = vi.begin(); 
for(int i = 0; i &lt; 5; i++)
    cout &lt;&lt; *(it + i) &lt;&lt; &quot; &quot;;
cout &lt;&lt; &quot;\n&quot;;

//方式二：
vector&lt;int&gt;::iterator it;
for(it = vi.begin(); it != vi.end();it ++)
    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
//vi.end()指向尾元素地址的下一个地址
</code></pre>
<p><strong>智能指针</strong></p>
<p><strong>只能遍历完数组</strong>，如果要指定的内容进行遍历，需要另选方法。<br><strong>auto</strong> 能够自动识别并获取类型。</p>
<pre><code class="cpp">vector&lt;int&gt; v;
v.push_back(12);
v.push_back(241);
for(auto val : v) 
    cout &lt;&lt; val &lt;&lt; &quot; &quot;; // 12 241
</code></pre>
<p><code>vector</code>注意：</p>
<ul>
<li><code>vi[i]</code> 和 <code>*(vi.begin() + i)</code> 等价</li>
<li><code>vector</code>和<code>string</code>的<code>STL</code>容器支持<code>*(it + i)</code>的元素访问，其它容器可能也可以支持这种方式访问，但用的不多，可自行尝试。</li>
</ul>
<h2 id="Vector原理"><a href="#Vector原理" class="headerlink" title="Vector原理"></a>Vector原理</h2><ul>
<li>vector是动态数组，所以和数组一样拥有一段连续的内存空间，并且起始地址不变。</li>
<li>因为vector地址空间是连续的，所以能高效的进行随机访问，时间复杂度为o(1)。</li>
<li>在vector中插入和删除元素，需要对现有元素进行复制、移动，时间复杂度为o(n)。</li>
<li>如果vector中存储的对象很大，或者构造函数复杂，那么插入等开销会很大。因为拷贝现有对象时需要调用拷贝构造函数。</li>
<li>vector扩容原理<ul>
<li>新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就会分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。注意不是在原来空间后直接增加空间</li>
<li>对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。</li>
<li>不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。</li>
</ul>
</li>
</ul>
<h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p>栈为数据结构的一种，是STL中实现的一个先进后出，后进先出的容器。</p>
<pre><code class="cpp">//头文件需要添加
#include&lt;stack&gt;

//声明
stack&lt;int&gt; s;
stack&lt;string&gt; s;
stack&lt;node&gt; s;//node是结构体类型
</code></pre>
<h2 id="方法函数-1"><a href="#方法函数-1" class="headerlink" title="方法函数"></a>方法函数</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>s.push(ele)</code></td>
<td align="left">元素<code>ele</code>入栈，增加元素 O(1)</td>
</tr>
<tr>
<td align="left"><code>s.pop()</code></td>
<td align="left">移除栈顶元素 O(1)</td>
</tr>
<tr>
<td align="left"><code>s.top()</code></td>
<td align="left">取得栈顶元素（但不删除）O(1)</td>
</tr>
<tr>
<td align="left"><code>s.empty()</code></td>
<td align="left">检测栈内是否为空，空为真 O(1)</td>
</tr>
<tr>
<td align="left"><code>s.size()</code></td>
<td align="left">返回栈内元素的个数 O(1)</td>
</tr>
</tbody></table>
<h2 id="栈遍历"><a href="#栈遍历" class="headerlink" title="栈遍历"></a>栈遍历</h2><p><strong>栈遍历</strong></p>
<p>栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中</p>
<p><strong>数组模拟栈进行遍历</strong></p>
<p>通过一个<strong>数组</strong>对栈进行模拟，一个存放下标的变量<code>top</code>模拟指向栈顶的指针。</p>
<p><strong>特点：</strong> 比<code>STL</code>的<code>stack</code>速度更快，遍历元素方便</p>
<pre><code class="cpp">int s[100]; // 栈 从左至右为栈底到栈顶
int tt = -1; // tt 代表栈顶指针,初始栈内无元素，tt为-1

for(int i = 0; i &lt;= 5; i++)
&#123;
    //入栈 
    s[++tt] = i;
&#125;
// 出栈
int top_element = s[tt--]; 

//入栈操作示意
//  0  1  2  3  4  5  
//                tt
//出栈后示意
//  0  1  2  3  4 
//              tt
</code></pre>
<h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><p>队列是一种先进先出的数据结构。</p>
<pre><code class="cpp">//头文件
#include&lt;queue&gt;
//定义初始化
queue&lt;int&gt; q;
</code></pre>
<h2 id="方法函数-2"><a href="#方法函数-2" class="headerlink" title="方法函数"></a>方法函数</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>q.front()</code></td>
<td align="left">返回队首元素 O(1)</td>
</tr>
<tr>
<td align="left"><code>q.back()</code></td>
<td align="left">返回队尾元素 O(1)</td>
</tr>
<tr>
<td align="left"><code>q.push(element)</code></td>
<td align="left">尾部添加一个元素<code>element</code> 进队O(1)</td>
</tr>
<tr>
<td align="left"><code>q.pop()</code></td>
<td align="left">删除第一个元素 出队 O(1)</td>
</tr>
<tr>
<td align="left"><code>q.size()</code></td>
<td align="left">返回队列中元素个数，返回值类型<code>unsigned int</code> O(1)</td>
</tr>
<tr>
<td align="left"><code>q.empty()</code></td>
<td align="left">判断是否为空，队列为空，返回<code>true</code> O(1)</td>
</tr>
</tbody></table>
<h2 id="队列模拟"><a href="#队列模拟" class="headerlink" title="队列模拟"></a>队列模拟</h2><p>使用<code>q[]</code>数组模拟队列<br><code>hh</code>表示队首元素的下标，初始值为<code>0</code><br><code>tt</code>表示队尾元素的下标，初始值为<code>-1</code>，表示刚<strong>开始队列为空</strong></p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5+5;
int q[N];

int main()
&#123;
    int hh = 0,tt = -1;
//    入队 
    q[++tt] = 1;
    q[++tt] = 2; 
//    将所有元素出队 
    while(hh &lt;= tt)
    &#123;
        int t = q[hh++];
        printf(&quot;%d &quot;,t);
    &#125;
    return 0;
 &#125; 
</code></pre>
<h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><p>首尾都可插入和删除的队列为双端队列。</p>
<pre><code class="cpp">//添加头文件
#include &lt;deque&gt;
//初始化定义
deque&lt;int&gt; dq;
</code></pre>
<h2 id="方法函数-3"><a href="#方法函数-3" class="headerlink" title="方法函数"></a>方法函数</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>push_back(x)/push_front(x)</code></td>
<td align="left">把<code>x</code>插入队尾后 &#x2F; 队首 O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>back()/front()</code></td>
<td align="left">返回队尾 &#x2F; 队首元素 O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>pop_back() / pop_front()</code></td>
<td align="left">删除队尾 &#x2F; 队首元素 O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>erase(iterator it)</code></td>
<td align="left">删除双端队列中的某一个元素</td>
</tr>
<tr>
<td align="left"><code>erase(iterator first,iterator last)</code></td>
<td align="left">删除双端队列中<code>[first,last)</code>中的元素</td>
</tr>
<tr>
<td align="left"><code>empty()</code></td>
<td align="left">判断deque是否空 O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>size()</code></td>
<td align="left">返回deque的元素数量 O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>clear()</code></td>
<td align="left">清空deque</td>
</tr>
</tbody></table>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>deque可以进行排序</p>
<pre><code class="cpp">//从小到大
sort(q.begin(), q.end())
//从大到小排序
sort(q.begin(), q.end(), greater&lt;int&gt;());//deque里面的类型需要是int型
sort(q.begin(), q.end(), greater());//高版本C++才可以用
</code></pre>
<h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><p>优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。</p>
<p>可以实现每次从优先队列中取出的元素都是队列中<strong>优先级最大</strong>的一个。</p>
<p>它的底层是通过<strong>堆</strong>来实现的。</p>
<pre><code class="cpp">//头文件
#include&lt;queue&gt;
//初始化定义
priority_queue&lt;int&gt; q;
</code></pre>
<h2 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>q.top()</code></td>
<td align="left">访问队首元素</td>
</tr>
<tr>
<td align="left"><code>q.push()</code></td>
<td align="left">入队</td>
</tr>
<tr>
<td align="left"><code>q.pop()</code></td>
<td align="left">堆顶（队首）元素出队</td>
</tr>
<tr>
<td align="left"><code>q.size()</code></td>
<td align="left">队列元素个数</td>
</tr>
<tr>
<td align="left"><code>q.empty()</code></td>
<td align="left">是否为空</td>
</tr>
<tr>
<td align="left"><strong>注意</strong>没有<code>clear()</code>！</td>
<td align="left">不提供该方法</td>
</tr>
<tr>
<td align="left">优先队列只能通过<code>top()</code>访问队首元素（优先级最高的元素）</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="设置优先级"><a href="#设置优先级" class="headerlink" title="设置优先级"></a>设置优先级</h2><h3 id="基本数据类型的优先级"><a href="#基本数据类型的优先级" class="headerlink" title="基本数据类型的优先级"></a>基本数据类型的优先级</h3><pre><code class="cpp">priority_queue&lt;int&gt; pq; // 默认大根堆, 即每次取出的元素是队列中的最大值
priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; // 小根堆, 每次取出的元素是队列中的最小值
</code></pre>
<p><strong>参数解释：</strong></p>
<ul>
<li><strong>第二个参数：</strong><br><code>vector&lt; int &gt;</code> 是用来承载底层数据结构堆的容器，若优先队列中存放的是<code>double</code>型数据，就要填<code>vector&lt; double &gt;</code><br><strong>总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。</strong></li>
<li><strong>第三个参数：</strong><br><code>less&lt; int &gt;</code> 表示数字大的优先级大，堆顶为最大的数字<br><code>greater&lt; int &gt;</code>表示数字小的优先级大，堆顶为最小的数字<br><strong>int代表的是数据类型，也要填优先队列中存储的数据类型</strong></li>
</ul>
<p>下面介绍基础数据类型优先级设置的写法。</p>
<p><strong>1. 基础写法（非常常用）</strong></p>
<pre><code class="cpp">priority_queue&lt;int&gt; q1; // 默认大根堆, 即每次取出的元素是队列中的最大值
priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q2; // 大根堆, 每次取出的元素是队列中的最大值，同第一行

priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q3; // 小根堆, 每次取出的元素是队列中的最小值
</code></pre>
<p><strong>2. 自定义排序（不常见，主要是写着麻烦）</strong></p>
<p>下面的代码比较长，基础类型优先级写着太麻烦，用第一种即可。</p>
<pre><code class="cpp">struct cmp1
&#123;
    bool operator()(int x,int y)
    &#123;
        return x &gt; y;
    &#125;
&#125;;
struct cmp2
&#123;
    bool operator()(const int x,const int y)
    &#123;
        return x &lt; y;
    &#125;
&#125;;
priority_queue&lt;int, vector&lt;int&gt;, cmp1&gt; q1; // 小根堆
priority_queue&lt;int, vector&lt;int&gt;, cmp2&gt; q2; // 大根堆
</code></pre>
<h3 id="结构体优先级设置"><a href="#结构体优先级设置" class="headerlink" title="结构体优先级设置"></a>结构体优先级设置</h3><blockquote>
<p>即优先队列中存储结构体类型，必须要设置优先级，即结构体的比较运算（因为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶）。</p>
</blockquote>
<p>优先级设置可以定义在<strong>结构体内</strong>进行小于号重载，也可以定义在<strong>结构体外</strong>。</p>
<h3 id="存储特殊类型的优先级"><a href="#存储特殊类型的优先级" class="headerlink" title="存储特殊类型的优先级"></a>存储特殊类型的优先级</h3><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>映射类似于函数的对应关系，每个<code>x</code>对应一个<code>y</code>，而<code>map</code>是每个键对应一个值。会python的朋友学习后就会知道这和python的字典非常类似。</p>
<blockquote>
<p>比如说：学习 对应 看书，学习 是键，看书 是值。<br>学习-&gt;看书<br>玩耍 对应 打游戏，玩耍 是键，打游戏 是值。<br>玩耍-&gt;打游戏</p>
</blockquote>
<pre><code class="cpp">//头文件
#include&lt;map&gt;
//初始化定义
map&lt;string,string&gt; mp;
map&lt;string,int&gt; mp;
map&lt;int,node&gt; mp;//node是结构体类型
</code></pre>
<blockquote>
<p>map特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小</p>
</blockquote>
<h2 id="函数方法-1"><a href="#函数方法-1" class="headerlink" title="函数方法"></a>函数方法</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>mp.find(key)</code></td>
<td align="left">返回键为key的映射的迭代器 O(logN)注意：用find函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end()</td>
</tr>
<tr>
<td align="left"><code>mp.erase(it)</code></td>
<td align="left">删除迭代器对应的键和值O(1)</td>
</tr>
<tr>
<td align="left"><code>mp.erase(key)</code></td>
<td align="left">根据映射的键删除键和值 O(logN)</td>
</tr>
<tr>
<td align="left"><code>mp.erase(first,last)</code></td>
<td align="left">删除左闭右开区间迭代器对应的键和值 O(last−first)</td>
</tr>
<tr>
<td align="left"><code>mp.size()</code></td>
<td align="left">返回映射的对数O(1)</td>
</tr>
<tr>
<td align="left"><code>mp.clear()</code></td>
<td align="left">清空map中的所有元素O(N)</td>
</tr>
<tr>
<td align="left"><code>mp.insert()</code></td>
<td align="left">插入元素，插入时要构造键值对</td>
</tr>
<tr>
<td align="left"><code>mp.empty()</code></td>
<td align="left">如果map为空，返回true，否则返回false</td>
</tr>
<tr>
<td align="left"><code>mp.begin()</code></td>
<td align="left">返回指向map第一个元素的迭代器（地址）</td>
</tr>
<tr>
<td align="left"><code>mp.end()</code></td>
<td align="left">返回指向map尾部的迭代器（最后一个元素的<strong>下一个</strong>地址）</td>
</tr>
<tr>
<td align="left"><code>mp.rbegin()</code></td>
<td align="left">返回指向map最后一个元素的迭代器（地址）</td>
</tr>
<tr>
<td align="left"><code>mp.rend()</code></td>
<td align="left">返回指向map第一个元素前面(上一个）的逆向迭代器（地址）</td>
</tr>
<tr>
<td align="left"><code>mp.count(key)</code></td>
<td align="left">查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0</td>
</tr>
<tr>
<td align="left"><code>mp.lower_bound()</code></td>
<td align="left">返回一个迭代器，指向键值&gt;&#x3D; <strong>key</strong>的第一个元素</td>
</tr>
<tr>
<td align="left"><code>mp.upper_bound()</code></td>
<td align="left">返回一个迭代器，指向键值&gt; key的第一个元素</td>
</tr>
</tbody></table>
<p><strong>下面说明部分函数方法的注意点</strong></p>
<blockquote>
<p>注意：<br>查找元素是否存在时，可以使用<br>①<code>mp.find()</code> ② <code>mp.count()</code> ③ <code>mp[key]</code><br>但是第三种情况，如果不存在对应的<code>key</code>时，会自动创建一个键值对（产生一个额外的键值对空间）<br>所以为了不增加额外的空间负担，最好使用前两种方法</p>
</blockquote>
<hr>
<p><strong>使用迭代器进行正反向遍历：</strong></p>
<p><code>mp.begin()</code>和<code>mp.end()</code>用法：<br><strong>用于正向遍历map</strong></p>
<pre><code class="cpp">map&lt;int,int&gt; mp;
mp[1] = 2;
mp[2] = 3;
mp[3] = 4;
auto it = mp.begin();
while(it != mp.end())
&#123;
    cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\n&quot;;
    it ++;
&#125;

/*输出
1 2
2 3
3 4
*/
</code></pre>
<p><code>mp.rbegin()</code>和<code>mp.rend()</code><br><strong>用于逆向遍历map</strong></p>
<pre><code class="cpp">map&lt;int,int&gt; mp;
mp[1] = 2;
mp[2] = 3;
mp[3] = 4;
auto it = mp.rbegin();
while(it != mp.rend())
&#123;
    cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\n&quot;;
    it ++;
&#125;

/*输出
3 4
2 3
1 2
*/
</code></pre>
<p>二分查找<code>lower_bound() upper_bound()</code></p>
<blockquote>
<p>map的二分查找以第一个元素（即键为准），对<strong>键</strong>进行二分查找<br>返回值为map迭代器类型</p>
</blockquote>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

int main()
&#123;
    map&lt;int, int&gt; m&#123;&#123;1, 2&#125;, &#123;2, 2&#125;, &#123;1, 2&#125;, &#123;8, 2&#125;, &#123;6, 2&#125;&#125;;//有序
    map&lt;int, int&gt;::iterator it1 = m.lower_bound(2);
    cout &lt;&lt; it1-&gt;first &lt;&lt; &quot;\n&quot;;//it1-&gt;first=2
    map&lt;int, int&gt;::iterator it2 = m.upper_bound(2);
    cout &lt;&lt; it2-&gt;first &lt;&lt; &quot;\n&quot;;//it2-&gt;first=6
    return 0;
&#125;
</code></pre>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><pre><code class="cpp">//先声明
map&lt;string,string&gt; mp;

//方式一
mp[&quot;学习&quot;] = &quot;看书&quot;;
mp[&quot;玩耍&quot;] = &quot;打游戏&quot;;

//方式二：插入元素构造键值对
mp.insert(make_pair(&quot;vegetable&quot;,&quot;蔬菜&quot;));

//方式三
mp.insert(pair&lt;string,string&gt;(&quot;fruit&quot;,&quot;水果&quot;));

//方式四
mp.insert(&#123;&quot;hahaha&quot;,&quot;wawawa&quot;&#125;);
</code></pre>
<h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><p><strong>6.4.1 下标访问：</strong>大部分情况用于访问单个元素</p>
<pre><code class="cpp">mp[&quot;菜哇菜&quot;] = &quot;强哇强&quot;;
cout &lt;&lt; mp[&quot;菜哇菜&quot;] &lt;&lt; &quot;\n&quot;;//只是简写的一个例子，程序并不完整
</code></pre>
<p><strong>6.4.2 遍历访问：</strong></p>
<p><strong>方式一：迭代器访问</strong></p>
<pre><code class="cpp">map&lt;string,string&gt;::iterator it;
for(it = mp.begin(); it != mp.end(); it++)
&#123;
    //      键                 值 
    // it是结构体指针访问所以要用 -&gt; 访问
    cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\n&quot;;
    //*it是结构体变量 访问要用 . 访问
    //cout&lt;&lt;(*it).first&lt;&lt;&quot; &quot;&lt;&lt;(*it).second;
&#125;
</code></pre>
<p><strong>方式二：智能指针访问</strong></p>
<pre><code class="cpp">for(auto i : mp)
cout &lt;&lt; i.first &lt;&lt; &quot; &quot; &lt;&lt; i.second &lt;&lt; endl;//键，值
</code></pre>
<p><strong>方式三：对指定单个元素访问</strong></p>
<pre><code class="cpp">map&lt;char,int&gt;::iterator it = mp.find(&#39;a&#39;);
cout &lt;&lt; it -&gt; first &lt;&lt; &quot; &quot; &lt;&lt;  it-&gt;second &lt;&lt; &quot;\n&quot;;
</code></pre>
<p><strong>方式四：c++17特性才具有</strong></p>
<pre><code class="cpp">for(auto [x, y] : mp)
    cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;;
//x,y对应键和值
</code></pre>
<h2 id="与unordered-map的比较"><a href="#与unordered-map的比较" class="headerlink" title="与unordered_map的比较"></a>与unordered_map的比较</h2><p>这里就不单开一个大目录讲unordered_map了，直接在map里面讲了。</p>
<h3 id="内部实现原理"><a href="#内部实现原理" class="headerlink" title="内部实现原理"></a>内部实现原理</h3><p><strong>map</strong>：内部用<strong>红黑树</strong>实现，具有<strong>自动排序</strong>（按键从小到大）功能。</p>
<p><strong>unordered_map</strong>：内部用<strong>哈希表</strong>实现，内部元素无序杂乱。</p>
<h3 id="效率比较"><a href="#效率比较" class="headerlink" title="效率比较"></a>效率比较</h3><p><strong>map</strong>：</p>
<ul>
<li>优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为O(logN)</li>
<li>缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。</li>
</ul>
<p><strong>unordered_map</strong>：</p>
<ul>
<li>优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。</li>
<li>缺点：建立哈希表比较耗时。</li>
</ul>
<blockquote>
<p>两者方法函数基本一样，差别不大。</p>
<p>注意：</p>
<ul>
<li><p>随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。</p>
</li>
<li><p>使用<code>[]</code>查找元素时，如果元素不存在，两种容器<strong>都是</strong>创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会<strong>大大降低</strong>。</p>
</li>
<li><p>查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）</p>
<pre><code class="cpp">// 以 map 为例
map&lt;int, int&gt; mp;
int x = 999999999;
if(mp.count(x)) // 此处判断是否存在x这个键
    cout &lt;&lt; mp[x] &lt;&lt; &quot;\n&quot;;   // 只有存在才会索引对应的值，避免不存在x时多余空元素的创建
</code></pre>
</li>
</ul>
</blockquote>
<p>还有一种映射：</p>
<p><a target="_blank" rel="noopener" href="https://wyqz.top/p/870124582.html">multimap</a><br>键可以重复，即一个键对应多个值，如要了解，可以自行搜索。</p>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。</p>
<p>即：set里面的元素<strong>不重复 且有序</strong></p>
<pre><code class="cpp">//头文件
#include&lt;set&gt;
//初始化定义
set&lt;int&gt; s;
</code></pre>
<h2 id="函数方法-2"><a href="#函数方法-2" class="headerlink" title="函数方法"></a>函数方法</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>s.begin()</code></td>
<td align="left">返回set容器的第一个元素的地址（迭代器）O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>s.end()</code></td>
<td align="left">返回set容器的最后一个元素的下一个地址（迭代器）O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>s.rbegin()</code></td>
<td align="left">返回逆序迭代器，指向容器元素最后一个位置O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>s.rend()</code></td>
<td align="left">返回逆序迭代器，指向容器第一个元素前面的位置O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>s.clear()</code></td>
<td align="left">删除set容器中的所有的元素,返回unsigned int类型O(N)�(�)</td>
</tr>
<tr>
<td align="left"><code>s.empty()</code></td>
<td align="left">判断set容器是否为空O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>s.insert()</code></td>
<td align="left">插入一个元素</td>
</tr>
<tr>
<td align="left"><code>s.size()</code></td>
<td align="left">返回当前set容器中的元素个数O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>erase(iterator)</code></td>
<td align="left">删除定位器iterator指向的值</td>
</tr>
<tr>
<td align="left"><code>erase(first,second）</code></td>
<td align="left">删除定位器first和second之间的值</td>
</tr>
<tr>
<td align="left"><code>erase(key_value)</code></td>
<td align="left">删除键值key_value的值</td>
</tr>
<tr>
<td align="left">查找</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s.find(element)</code></td>
<td align="left">查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器</td>
</tr>
<tr>
<td align="left"><code>s.count(element)</code></td>
<td align="left">查找set中的元素出现的个数，由于set中元素唯一，此函数相当于查询element是否出现</td>
</tr>
<tr>
<td align="left"><code>s.lower_bound(k)</code></td>
<td align="left">返回大于等于k的第一个元素的迭代器O(logN)�(����)</td>
</tr>
<tr>
<td align="left"><code>s.upper_bound(k)</code></td>
<td align="left">返回大于k的第一个元素的迭代器O(logN)�(����)</td>
</tr>
</tbody></table>
<h2 id="访问-1"><a href="#访问-1" class="headerlink" title="访问"></a>访问</h2><h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><p>pair只含有两个元素，可以看作是只有两个元素的结构体。<br><strong>应用：</strong></p>
<ul>
<li>代替二元结构体</li>
<li>作为map键值对进行插入（代码如下）</li>
</ul>
<pre><code class="cpp">map&lt;string,int&gt;mp;
mp.insert(pair&lt;string,int&gt;(&quot;xingmaqi&quot;,1));
</code></pre>
<pre><code class="cpp">//头文件
#include&lt;utility&gt;

//1.初始化定义
pair&lt;string,int&gt; p(&quot;wangyaqi&quot;,1);//带初始值的
pair&lt;string,int&gt; p;//不带初始值的

//2.赋值
p = &#123;&quot;wang&quot;,18&#125;;
</code></pre>
<h2 id="访问-2"><a href="#访问-2" class="headerlink" title="访问"></a>访问</h2><pre><code class="cpp">//定义结构体数组
pair&lt;int,int&gt;p[20];
for(int i = 0; i &lt; 20; i++)
&#123;
    //和结构体类似，first代表第一个元素，second代表第二个元素
    cout &lt;&lt; p[i].first &lt;&lt; &quot; &quot; &lt;&lt; p[i].second;
&#125;
</code></pre>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>string是一个字符串类，和<code>char</code>型字符串类似。</p>
<p>可以把string理解为一个字符串类型，像int一样可以定义</p>
<h2 id="初始化及定义"><a href="#初始化及定义" class="headerlink" title="初始化及定义"></a>初始化及定义</h2><pre><code class="cpp">//头文件
#include&lt;string&gt;

//1.
string str1; //生成空字符串

//2.
string str2(&quot;123456789&quot;); //生成&quot;1234456789&quot;的复制品 

//3.
string str3(&quot;12345&quot;, 0, 3);//结果为&quot;123&quot; ，从0位置开始，长度为3

//4.
string str4(&quot;123456&quot;, 5); //结果为&quot;12345&quot; ，长度为5

//5.
string str5(5, &#39;2&#39;); //结果为&quot;22222&quot; ,构造5个字符&#39;2&#39;连接而成的字符串

//6.
string str6(str2, 2); //结果为&quot;3456789&quot;，截取第三个元素（2对应第三位）到最后
</code></pre>
<p><strong>简单使用</strong></p>
<ul>
<li><p>访问单个字符：</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
&#123;
    string s = &quot;xing ma qi!!!&quot;;
    for(int i = 0; i &lt; s.size(); i++)
        cout &lt;&lt; s[i] &lt;&lt; &quot; &quot;;
    return 0;
&#125;
</code></pre>
</li>
</ul>
<ul>
<li><p>string数组使用：</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
&#123;
    string s[10];
    for(int i = 1; i &lt; 10; i++)
    &#123;
        s[i] = &quot;loading...  &quot; ;
        cout &lt;&lt; s[i] &lt;&lt; i &lt;&lt; &quot;\n&quot;;
    &#125; 
    return 0;
&#125;
</code></pre>
<p>结果：</p>
<pre><code class="cpp">loading...  1
loading...  2
loading...  3
loading...  4
loading...  5
loading...  6
loading...  7
loading...  8
loading...  9
</code></pre>
</li>
</ul>
<h2 id="string-特性"><a href="#string-特性" class="headerlink" title="string 特性"></a>string 特性</h2><ul>
<li><p>支持<strong>比较</strong>运算符<br>string字符串支持常见的比较操作符<code>（&gt;,&gt;=,&lt;,&lt;=,==,!=）</code>，支持<code>string</code>与<code>C-string</code>的比较（如 <code>str &lt; &quot;hello&quot;</code>）。<br>在使用<code>&gt;,&gt;=,&lt;,&lt;=</code>这些操作符的时候是根据“当前字符特性”将字符按 <code>字典顺序</code> 进行逐一得 比较。字典排序靠前的字符小， 比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。</p>
<p>同时，&#96;string (“aaaa”) 。</p>
<ul>
<li><p>支持<code>+</code><strong>运算</strong>符，代表拼接字符串<br>string字符串可以拼接，通过”+”运算符进行拼接。</p>
<pre><code class="cpp">string s1 = &quot;123&quot;;
string s2 = &quot;456&quot;;
string s = s1 + s2;
cout &lt;&lt; s;   //123456
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="读入详解"><a href="#读入详解" class="headerlink" title="读入详解"></a>读入详解</h2><p><strong>读入字符串，遇空格，回车结束</strong></p>
<pre><code class="cpp">string s;
cin &gt;&gt; s;
</code></pre>
<p><strong>读入一行字符串（包括空格），遇回车结束</strong></p>
<pre><code class="cpp">string s;
getline(cin, s);
</code></pre>
<p>注意: <code>getline(cin, s)</code>会获取前一个输入的换行符，需要在前面添加读取换行符的语句。如：<code>getchar()</code> 或<code>cin.get()</code></p>
<p>错误读取：</p>
<pre><code class="cpp">int n;
string s;
cin &gt;&gt; n;
getline(cin, s); //此时读取相当于读取了前一个回车字符
</code></pre>
<p>正确读取：</p>
<pre><code class="cpp">int n;
string s;
cin &gt;&gt; n;
getchar(); //cin.get()
getline(cin, s);//可正确读入下一行的输入
</code></pre>
<blockquote>
<p><code>cin</code>与<code>cin.getline()</code>混用</p>
<p>cin输入完后，回车，cin遇到回车结束输入，但回车还在输入流中，cin并不会清除，导致<code>getline()</code>读取回车，结束。<br>需要在cin后面加<code>cin.ignore()</code>；主动删除输入流中的换行符。（不常用）</p>
</blockquote>
<p><strong>cin和cout解锁</strong></p>
<p>代码（写在main函数开头）：</p>
<pre><code class="cpp">ios::sync_with_stdio(false);
cin.tie(0),cout.tie(0);
</code></pre>
<blockquote>
<p>为什么要进行<code>cin</code>和<code>cout</code>的解锁，原因是：</p>
<p>在一些题目中，读入的<strong>数据量很大</strong>，往往超过了1e5（10^5^）的数据量,而<code>cin</code>和<code>cout</code>的读入输出的速度<strong>很慢</strong>（是因为<code>cin</code>和<code>cout</code>为了兼容C语言的读入输出在性能上做了妥协），远不如<code>scanf</code>和<code>printf</code>的速度，具体原因可以搜索相关的博客进行了解。</p>
<p><strong>所以</strong>对<code>cin</code>和<code>cout</code>进行解锁使<code>cin</code>和<code>cout</code>的速度几乎接近<code>scanf</code>和<code>printf</code>，避免输入输出超时。</p>
</blockquote>
<p><strong>注意</strong>：<code>cin cout</code>解锁使用时，不能与 <code>scanf,getchar, printf,cin.getline()</code>混用，一定要注意，会出错。</p>
<blockquote>
<p><strong>string与C语言字符串（C-string）的区别</strong></p>
<ul>
<li>string<br>是C++的一个类，专门实现字符串的相关操作。具有丰富的操作方法，数据类型为<code>string</code>，字符串结尾没有<code>\0</code>字符</li>
<li>C-string<br>C语言中的字符串，用char数组实现，类型为<code>const char *</code>,字符串结尾以<code>\0</code>结尾</li>
</ul>
</blockquote>
<p>一般来说string向char数组转换会出现一些问题，所以为了能够实现转换，string有一个方法<code>c_str()</code>实现string向char数组的转换。</p>
<pre><code class="cpp">string s = &quot;xing ma qi&quot;;
char s2[] = s.c_str();
</code></pre>
<h2 id="函数方法-3"><a href="#函数方法-3" class="headerlink" title="函数方法"></a>函数方法</h2><ul>
<li><strong>获取字符串长度</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>s.size()</code>和<code>s.length()</code></td>
<td align="left">返回string对象的字符个数，他们执行效果相同。</td>
</tr>
<tr>
<td align="left"><code>s.max_size()</code></td>
<td align="left">返回string对象最多包含的字符数，超出会抛出length_error异常</td>
</tr>
<tr>
<td align="left"><code>s.capacity()</code></td>
<td align="left">重新分配内存之前，string对象能包含的最大字符数</td>
</tr>
</tbody></table>
<ul>
<li><strong>插入</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>s.push_back()</code></td>
<td align="left">在末尾插入</td>
</tr>
<tr>
<td align="left">例：<code>s.push_back(&#39;a&#39;)</code></td>
<td align="left">末尾插入一个字符a</td>
</tr>
<tr>
<td align="left"><code>s.insert(pos,element)</code></td>
<td align="left">在pos位置插入element</td>
</tr>
<tr>
<td align="left">例：<code>s.insert(s.begin(),&#39;1&#39;)</code></td>
<td align="left">在第一个位置插入1字符</td>
</tr>
<tr>
<td align="left"><code>s.append(str)</code></td>
<td align="left">在s字符串结尾添加str字符串</td>
</tr>
<tr>
<td align="left">例：<code>s.append(&quot;abc&quot;)</code></td>
<td align="left">在s字符串末尾添加字符串“abc”</td>
</tr>
</tbody></table>
<ul>
<li><strong>删除</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>erase(iterator p)</code></td>
<td align="left">删除字符串中p所指的字符</td>
</tr>
<tr>
<td align="left"><code>erase(iterator first, iterator last)</code></td>
<td align="left">删除字符串中迭代器区间<code>[first,last)</code>上所有字符</td>
</tr>
<tr>
<td align="left"><code>erase(pos, len)</code></td>
<td align="left">删除字符串中从索引位置pos开始的len个字符</td>
</tr>
<tr>
<td align="left"><code>clear()</code></td>
<td align="left">删除字符串中所有字符</td>
</tr>
</tbody></table>
<ul>
<li><strong>字符替换</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>s.replace(pos,n,str)</code></td>
<td align="left">把当前字符串从索引pos开始的n个字符替换为str</td>
</tr>
<tr>
<td align="left"><code>s.replace(pos,n,n1,c)</code></td>
<td align="left">把当前字符串从索引pos开始的n个字符替换为n1个字符c</td>
</tr>
<tr>
<td align="left"><code>s.replace(it1,it2,str)</code></td>
<td align="left">把当前字符串<code>[it1,it2)</code>区间替换为str <strong>it1 ,it2为迭代器哦</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong>大小写转换</strong></li>
</ul>
<p>法一：</p>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>tolower(s[i])</code></td>
<td align="left">转换为小写</td>
</tr>
<tr>
<td align="left"><code>toupper(s[i])</code></td>
<td align="left">转换为大写</td>
</tr>
</tbody></table>
<p>法二：</p>
<p>通过stl的transform算法配合tolower 和toupper 实现。<br>有4个参数，前2个指定要转换的容器的起止范围，第3个参数是结果存放容器的起始位置，第4个参数是一元运算。</p>
<pre><code class="cpp">string s;
transform(s.begin(),s.end(),s.begin(),::tolower);//转换小写
transform(s.begin(),s.end(),s.begin(),::toupper);//转换大写
</code></pre>
<ul>
<li><strong>分割</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>s.substr(pos,n)</code></td>
<td align="left">截取从pos索引开始的n个字符</td>
</tr>
</tbody></table>
<ul>
<li><strong>查找</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>s.find (str, pos)</code></td>
<td align="left">在当前字符串的pos索引位置（默认为0）开始，查找子串str，返回找到的位置索引，-1表示查找不到子串</td>
</tr>
<tr>
<td align="left"><code>s.find (c, pos)</code></td>
<td align="left">在当前字符串的pos索引位置（默认为0）开始，查找字符c，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td align="left"><code>s.rfind (str, pos)</code></td>
<td align="left">在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串</td>
</tr>
<tr>
<td align="left"><code>s.rfind (c,pos)</code></td>
<td align="left">在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td align="left"><code>s.find_first_of (str, pos)</code></td>
<td align="left">在当前字符串的pos索引位置（默认为0）开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td align="left"><code>s.find_first_not_of (str,pos)</code></td>
<td align="left">在当前字符串的pos索引位置（默认为0）开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td align="left"><code>s.find_last_of(str, pos)</code></td>
<td align="left">在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td align="left"><code>s.find_last_not_of ( str, pos)</code></td>
<td align="left">在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串</td>
</tr>
</tbody></table>
<pre><code class="cpp">#include&lt;string&gt;
#include&lt;iostream&gt;
int main()
&#123;
    string s(&quot;dog bird chicken bird cat&quot;);
//字符串查找-----找到后返回首字母在字符串中的下标
// 1. 查找一个字符串
    cout &lt;&lt; s.find(&quot;chicken&quot;) &lt;&lt; endl;// 结果是：9

// 2. 从下标为6开始找字符&#39;i&#39;，返回找到的第一个i的下标
    cout &lt;&lt; s.find(&#39;i&#39;,6) &lt;&lt; endl;// 结果是：11

// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标
    cout &lt;&lt; s.rfind(&quot;chicken&quot;) &lt;&lt; endl;// 结果是：9

// 4. 从字符串的末尾开始查找字符
    cout &lt;&lt; s.rfind(&#39;i&#39;) &lt;&lt; endl;// 结果是：18因为是从末尾开始查找，所以返回第一次找到的字符

// 5. 在该字符串中查找第一个属于字符串s的字符
    cout &lt;&lt; s.find_first_of(&quot;13br98&quot;) &lt;&lt; endl;// 结果是：4---b

// 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4
    cout &lt;&lt; s.find_first_not_of(&quot;hello dog 2006&quot;) &lt;&lt; endl; // 结果是：4
    cout &lt;&lt; s.find_first_not_of(&quot;dog bird 2006&quot;) &lt;&lt; endl;  // 结果是：9

// 7. 在该字符串最后中查找第一个属于字符串s的字符
    cout &lt;&lt; s.find_last_of(&quot;13r98&quot;) &lt;&lt; endl;// 结果是：19

// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21
    cout &lt;&lt; s.find_last_not_of(&quot;teac&quot;) &lt;&lt; endl;// 结果是：21
&#125;
</code></pre>
<ul>
<li><strong>排序</strong></li>
</ul>
<pre><code class="cpp">sort(s.begin(),s.end());  //按ASCII码排序
</code></pre>
<h1 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h1><p>bitset 在 bitset 头文件中，它类似数组，并且每一个元素只能是０或１，每个元素只用１bit空间</p>
<pre><code class="cpp">//头文件
#include&lt;bitset&gt;
</code></pre>
<h2 id="初始化定义"><a href="#初始化定义" class="headerlink" title="初始化定义"></a>初始化定义</h2><p>初始化方法</p>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>bitset &lt; n &gt;a</code></td>
<td align="left">a有n位，每位都为0</td>
</tr>
<tr>
<td align="left"><code>bitset &lt; n &gt;a(b)</code></td>
<td align="left">a是unsigned long型u的一个副本</td>
</tr>
<tr>
<td align="left"><code>bitset &lt; n &gt;a(s)</code></td>
<td align="left">a是string对象s中含有的位串的副本</td>
</tr>
<tr>
<td align="left"><code>bitset &lt; n &gt;a(s,pos,n)</code></td>
<td align="left">a是s中从位置pos开始的n个位的副本</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：<code>n</code>必须为常量表达式</p>
</blockquote>
<p>演示代码：</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
&#123;
    bitset&lt;4&gt; bitset1;　　  //无参构造，长度为４，默认每一位为０

    bitset&lt;9&gt; bitset2(12);　//长度为9，二进制保存，前面用０补充

    string s = &quot;100101&quot;;
    bitset&lt;10&gt; bitset3(s);　　//长度为10，前面用０补充

    char s2[] = &quot;10101&quot;;
    bitset&lt;13&gt; bitset4(s2);　　//长度为13，前面用０补充

    cout &lt;&lt; bitset1 &lt;&lt; endl;　　//0000
    cout &lt;&lt; bitset2 &lt;&lt; endl;　　//000001100
    cout &lt;&lt; bitset3 &lt;&lt; endl;　　//0000100101
    cout &lt;&lt; bitset4 &lt;&lt; endl;　//0000000010101
    return 0;
&#125;
</code></pre>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><code>bitset</code>可以进行<strong>位操作</strong></p>
<pre><code class="cpp">bitset&lt;4&gt; foo (string(&quot;1001&quot;));
bitset&lt;4&gt; bar (string(&quot;0011&quot;));

cout &lt;&lt; (foo ^= bar) &lt;&lt; endl;// 1010 (foo对bar按位异或后赋值给foo)

cout &lt;&lt; (foo &amp;= bar) &lt;&lt; endl;// 0010 (按位与后赋值给foo)

cout &lt;&lt; (foo |= bar) &lt;&lt; endl;// 0011 (按位或后赋值给foo)

cout &lt;&lt; (foo &lt;&lt;= 2) &lt;&lt; endl;// 1100 (左移２位，低位补０，有自身赋值)

cout &lt;&lt; (foo &gt;&gt;= 1) &lt;&lt; endl;// 0110 (右移１位，高位补０，有自身赋值)

cout &lt;&lt; (~bar) &lt;&lt; endl;// 1100 (按位取反)

cout &lt;&lt; (bar &lt;&lt; 1) &lt;&lt; endl;// 0110 (左移，不赋值)

cout &lt;&lt; (bar &gt;&gt; 1) &lt;&lt; endl;// 0001 (右移，不赋值)

cout &lt;&lt; (foo == bar) &lt;&lt; endl;// false (0110==0011为false)

cout &lt;&lt; (foo != bar) &lt;&lt; endl;// true  (0110!=0011为true)

cout &lt;&lt; (foo &amp; bar) &lt;&lt; endl;// 0010 (按位与，不赋值)

cout &lt;&lt; (foo | bar) &lt;&lt; endl;// 0111 (按位或，不赋值)

cout &lt;&lt; (foo ^ bar) &lt;&lt; endl;// 0101 (按位异或，不赋值)
</code></pre>
<p><strong>访问</strong></p>
<pre><code class="cpp">//可以通过 [ ] 访问元素(类似数组)，注意最低位下标为０，如下：
bitset&lt;4&gt; foo (&quot;1011&quot;); 

cout &lt;&lt; foo[0] &lt;&lt; endl;　　//1
cout &lt;&lt; foo[1] &lt;&lt; endl;　　//1
cout &lt;&lt; foo[2] &lt;&lt; endl;　　//0
</code></pre>
<h2 id="方法函数-4"><a href="#方法函数-4" class="headerlink" title="方法函数"></a>方法函数</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>b.any()</code></td>
<td align="left">b中是否存在置为1的二进制位，有 返回true</td>
</tr>
<tr>
<td align="left"><code>b.none()</code></td>
<td align="left">b中是否没有1，没有 返回true</td>
</tr>
<tr>
<td align="left"><code>b.count()</code></td>
<td align="left">b中为1的个数</td>
</tr>
<tr>
<td align="left"><code>b.size()</code></td>
<td align="left">b中二进制位的个数</td>
</tr>
<tr>
<td align="left"><code>b.test(pos)</code></td>
<td align="left">测试b在pos位置是否为1，是 返回true</td>
</tr>
<tr>
<td align="left"><code>b[pos]</code></td>
<td align="left">返回b在pos处的二进制位</td>
</tr>
<tr>
<td align="left"><code>b.set()</code></td>
<td align="left">把b中所有位都置为1</td>
</tr>
<tr>
<td align="left"><code>b.set(pos)</code></td>
<td align="left">把b中pos位置置为1</td>
</tr>
<tr>
<td align="left"><code>b.reset()</code></td>
<td align="left">把b中所有位都置为0</td>
</tr>
<tr>
<td align="left"><code>b.reset(pos)</code></td>
<td align="left">把b中pos位置置为0</td>
</tr>
<tr>
<td align="left"><code>b.flip()</code></td>
<td align="left">把b中所有二进制位取反</td>
</tr>
<tr>
<td align="left"><code>b.flip(pos)</code></td>
<td align="left">把b中pos位置取反</td>
</tr>
<tr>
<td align="left"><code>b.to_ulong()</code></td>
<td align="left">用b中同样的二进制位返回一个unsigned long值</td>
</tr>
</tbody></table>
<h1 id="array"><a href="#array" class="headerlink" title="array"></a>array</h1><p>头文件</p>
<pre><code class="cpp">#include&lt;array&gt;
</code></pre>
<p><code>array</code>是C++11新增的容器，效率与普通数据相差无几，比<code>vector</code>效率要高，自身添加了一些成员函数。</p>
<p>和其它容器不同，array 容器的大小是<strong>固定</strong>的，无法动态的扩展或收缩，<strong>只允许访问或者替换存储的元素。</strong></p>
<p><strong>注意：</strong></p>
<p><code>array</code>的使用要在<code>std</code>命名空间里</p>
<h2 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h2><p><strong>基础数据类型</strong></p>
<pre><code class="cpp">//声明一个大小为100的`int`型数组，元素的值不确定
array&lt;int, 100&gt; a;

//声明一个大小为100的int型数组，初始值均为0初始值与默认元素类型等效
array&lt;int, 100&gt; a&#123;&#125;;

//声明一个大小为100的int型数组，初始化部分值，其余全部为0
array&lt;int, 100&gt; a&#123;1, 2, 3&#125;;

//或者可以用等号
array&lt;int, 100&gt; a = &#123;1, 2, 3&#125;;
</code></pre>
<p><strong>高级数据类型</strong></p>
<p>不同于数组的是对元素类型不做要求，可以套结构体</p>
<pre><code class="cpp">array&lt;string, 2&gt; s = &#123;&quot;ha&quot;, string(&quot;haha&quot;)&#125;;
array&lt;node, 2&gt; a;
</code></pre>
<h2 id="存取元素"><a href="#存取元素" class="headerlink" title="存取元素"></a>存取元素</h2><ul>
<li><p>修改元素</p>
<pre><code class="cpp">array&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;
a[0] = 4;
</code></pre>
</li>
<li><p>访问元素</p>
<p>下标访问</p>
<pre><code class="cpp">array&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;
for(int i = 0; i &lt; 4; i++) 
    cout &lt;&lt; a[i] &lt;&lt; &quot; \n&quot;[i == 3];
</code></pre>
<p>利用<code>auto</code>访问</p>
<pre><code class="cpp">for(auto i : a)
    cout &lt;&lt; i &lt;&lt; &quot; &quot;;
</code></pre>
<p>迭代器访问</p>
<pre><code class="cpp">auto it = a.begin();
for(; it != a.end(); it++) 
    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
</code></pre>
<p><code>at()</code>函数访问</p>
<p>下标为<code>1</code>的元素加上下标为<code>2</code>的元素，答案为<code>5</code></p>
<pre><code class="cpp">array&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;
int res = a.at(1) + a.at(2);
cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
</code></pre>
<p><code>get</code>方法访问</p>
<p>将<code>a</code>数组下标为<code>1</code>位置处的值改为<code>x</code></p>
<p>注意：获取的下标只能写数字，不能填变量</p>
<pre><code class="cpp">get&lt;1&gt;(a) = x;
</code></pre>
</li>
</ul>
<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><table>
<thead>
<tr>
<th align="left">成员函数</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>begin()</code></td>
<td align="left">返回容器中第一个元素的访问迭代器（地址）</td>
</tr>
<tr>
<td align="left"><code>end()</code></td>
<td align="left">返回容器最后一个元素之后一个位置的访问迭代器（地址）</td>
</tr>
<tr>
<td align="left"><code>rbegin()</code></td>
<td align="left">返回最后一个元素的访问迭代器（地址）</td>
</tr>
<tr>
<td align="left"><code>rend()</code></td>
<td align="left">返回第一个元素之前一个位置的访问迭代器（地址）</td>
</tr>
<tr>
<td align="left"><code>size()</code></td>
<td align="left">返回容器中元素的数量，其值等于初始化 array 类的第二个模板参数<code>N</code></td>
</tr>
<tr>
<td align="left"><code>max_size()</code></td>
<td align="left">返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N</td>
</tr>
<tr>
<td align="left"><code>empty()</code></td>
<td align="left">判断容器是否为空</td>
</tr>
<tr>
<td align="left"><code>at(n)</code></td>
<td align="left">返回容器中 n 位置处元素的引用，函数会自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常</td>
</tr>
<tr>
<td align="left"><code>front()</code></td>
<td align="left">返回容器中第一个元素的直接引用，函数不适用于空的 array 容器</td>
</tr>
<tr>
<td align="left"><code>back()</code></td>
<td align="left">返回容器中最后一个元素的直接引用，函数不适用于空的 array 容器。</td>
</tr>
<tr>
<td align="left"><code>data()</code></td>
<td align="left">返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能</td>
</tr>
<tr>
<td align="left"><code>fill(x)</code></td>
<td align="left">将 <code>x</code> 这个值赋值给容器中的每个元素,相当于初始化</td>
</tr>
<tr>
<td align="left"><code>array1.swap(array2)</code></td>
<td align="left">交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型</td>
</tr>
</tbody></table>
<h2 id="部分用法示例"><a href="#部分用法示例" class="headerlink" title="部分用法示例"></a>部分用法示例</h2><p><code>data()</code></p>
<p>指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。</p>
<p><code>at()</code></p>
<p>下标为<code>1</code>的元素加上下标为<code>2</code>的元素，答案为<code>5</code></p>
<pre><code class="cpp">array&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;
int res = a.at(1) + a.at(2);
cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
</code></pre>
<p><code>fill()</code></p>
<p>array的<code>fill()</code>函数，将<code>a</code>数组全部元素值变为<code>x</code></p>
<pre><code class="cpp">a.fill(x);
</code></pre>
<p>另外还有其它的<code>fill()</code>函数:将<code>a</code>数组[begin,end)全部值变为<code>x</code></p>
<pre><code class="cpp">fill(a.begin(), a.end(), x);
</code></pre>
<p><strong>get方法获取元素值</strong></p>
<p>将<code>a</code>数组下标为<code>1</code>位置处的值改为<code>x</code></p>
<p>注意:获取的下标只能写数字，不能填变量</p>
<pre><code class="cpp">get&lt;1&gt;(a) = x;
</code></pre>
<p><strong>排序</strong></p>
<pre><code class="cpp">sort(a.begin(), a.end());
</code></pre>
<h1 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h1><p>tuple模板是pair的泛化，可以封装不同类型任意数量的对象。</p>
<p>可以把tuple理解为pair的扩展，tuple可以声明二元组，也可以声明三元组。</p>
<p>tuple可以等价为<strong>结构体</strong>使用</p>
<p><strong>头文件</strong></p>
<pre><code class="cpp">#include &lt;tuple&gt;
</code></pre>
<h2 id="声明初始化"><a href="#声明初始化" class="headerlink" title="声明初始化"></a>声明初始化</h2><p>声明一个空的<code>tuple</code>三元组</p>
<pre><code class="cpp">tuple&lt;int, int, string&gt; t1;
</code></pre>
<p>赋值</p>
<pre><code class="cpp">t1 = make_tuple(1, 1, &quot;hahaha&quot;);
</code></pre>
<p>创建的同时初始化</p>
<pre><code class="cpp">tuple&lt;int, int, int, int&gt; t2(1, 2, 3, 4);
</code></pre>
<p>可以使用pair对象构造tuple对象，但tuple对象必须是两个元素</p>
<pre><code class="cpp">auto p = make_pair(&quot;wang&quot;, 1);
tuple&lt;string, int&gt; t3 &#123;p&#125;; //将pair对象赋给tuple对象
</code></pre>
<h2 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h2><p>获取tuple对象<code>t</code>的第一个元素</p>
<pre><code class="cpp">int first = get&lt;0&gt;(t);
</code></pre>
<p>修改tuple对象<code>t</code>的第一个元素</p>
<pre><code class="cpp">get&lt;0&gt;(t) = 1;
</code></pre>
<h2 id="函数操作"><a href="#函数操作" class="headerlink" title="函数操作"></a>函数操作</h2><p>获取元素个数</p>
<pre><code class="cpp">tuple&lt;int, int, int&gt; t(1, 2, 3);
cout &lt;&lt; tuple_size&lt;decltype(t)&gt;::value &lt;&lt; &quot;\n&quot;; // 3
</code></pre>
<p>获取对应元素的值</p>
<p>通过<code>get(obj)</code>方法获取,<code>n</code>必须为数字不能是变量</p>
<pre><code class="cpp">tuple&lt;int, int, int&gt; t(1, 2, 3);
cout &lt;&lt; get&lt;0&gt;(t) &lt;&lt; &#39;\n&#39;; // 1
cout &lt;&lt; get&lt;1&gt;(t) &lt;&lt; &#39;\n&#39;; // 2
cout &lt;&lt; get&lt;2&gt;(t) &lt;&lt; &#39;\n&#39;; // 3
</code></pre>
<p>通过<code>tie</code>解包 获取元素值</p>
<p><code>tie</code>可以让tuple变量中的三个值依次赋到tie中的三个变量中</p>
<pre><code class="cpp">int one, three;
string two; 
tuple&lt;int, string, int&gt; t(1, &quot;hahaha&quot;, 3);
tie(one, two, three) = t;
cout &lt;&lt; one &lt;&lt; two &lt;&lt; three &lt;&lt; &quot;\n&quot;; // 1hahaha3
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00bcd4">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/STL/" style="color: #ff7d73">
                STL
            </a>
        </span>
        
    </div>
    <a href="/2023/03/10/STL%E5%AE%B9%E5%99%A8/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/03/10/CMU15-445/">
        <h2 class="post-title">CMU15-445</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/DataBase/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                DataBase
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/10
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>Schedule | CMU 15-445&#x2F;645 :: Intro to Database Systems (Fall 2022)](<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2022/schedule.html">https://15445.courses.cs.cmu.edu/fall2022/schedule.html</a>)</p>
<h1 id="Lesson-01-关系模型-amp-关系代数（Relational-Model-amp-Relational-Algebra）"><a href="#Lesson-01-关系模型-amp-关系代数（Relational-Model-amp-Relational-Algebra）" class="headerlink" title="Lesson#01. 关系模型&amp;关系代数（Relational Model &amp; Relational Algebra）"></a>Lesson#01. 关系模型&amp;关系代数（Relational Model &amp; Relational Algebra）</h1><h2 id="1-Database"><a href="#1-Database" class="headerlink" title="1. Database"></a>1. Database</h2><p>数据库(Database,DB) 是一个有组织的、互相关联的、对现实世界的某些方面进行建模的集合。</p>
<p>严格来讲，数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度()、较高的数据独立性()和易扩展性()，并可为各种用户共享。</p>
<p>本笔记中，用一个存储着艺术家和对应的专辑信息的数据库作为例子，亦即数字音乐商店(A database that models a digital music store)。</p>
<h2 id="2-Flat-File-Strawman"><a href="#2-Flat-File-Strawman" class="headerlink" title="2. Flat File Strawman"></a>2. Flat File Strawman</h2><p>数据库常常以CSV(comma-separated value)文件的形式存储，由DBMS进行管理。每次应用程序要读取或者更新记录时，都必须解析文件(parse files)。</p>
<p>以数字音乐商店的例子，会有两个文件，一是艺术家，二是专辑。</p>
<p>每个实体都有自己的属性集，所以在每个文件中，不同的记录都用新的行来划分，而一条记录中的每个相应属性都用逗号隔开。</p>
<p>例子：</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Year</th>
<th align="left">Country</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Wu-Tang Clan</td>
<td align="left">1992</td>
<td align="left">USA</td>
</tr>
<tr>
<td align="left">Notorious BIG</td>
<td align="left">1992</td>
<td align="left">USA</td>
</tr>
<tr>
<td align="left">GZE</td>
<td align="left">1990</td>
<td align="left">USA</td>
</tr>
</tbody></table>
<p><strong>Issues with Flat File</strong></p>
<ul>
<li><p>Data Integrity</p>
<p>数据完整性</p>
</li>
<li><p>Implementation<br>执行</p>
</li>
<li><p>Durability<br>耐受性</p>
</li>
</ul>
<h2 id="3-Database-Management-System-DBMS"><a href="#3-Database-Management-System-DBMS" class="headerlink" title="3. Database Management System(DBMS)"></a>3. Database Management System(DBMS)</h2><p>一个DBMS是一个能让应用在数据库中保存与分析数据的软件</p>
<p>通常，DBMS设计的目的是允许定义、创建、查询、更新和管理符合某种数据模型的数据库。</p>
<ul>
<li><p><strong>Data model：</strong><br>数据模型是描述数据库中数据的概念的集合。A data model is a collection of concepts for describing the data in database.</p>
<p>Example: Relational (most common), NoSQL (key&#x2F;value, graph, Document, Column-family), array&#x2F;matrix&#x2F;vectors</p>
<ul>
<li><strong>Relational</strong></li>
<li>Key&#x2F;Value (Redis)</li>
<li>Graph</li>
<li>Document</li>
<li>Column-family 列族数据库</li>
<li>Array&#x2F;Matrix (machine learning)</li>
</ul>
</li>
<li><p><strong>Schema：</strong><br>模式是对基于数据模型的特定数据集合的描述。</p>
</li>
</ul>
<p>Early DBMSs</p>
<p>早期，数据库应用很难建立和维护，因为逻辑层和物理层之间存在着高度耦合(a tight coupling between logical and physical layers)。</p>
<ul>
<li>逻辑层：<br>描述了数据库有哪些实体和属性。</li>
<li>物理层：<br>是这些实体和属性的存储方式。</li>
</ul>
<p>所以早期的数据库，一旦改变了物理层，逻辑层也得跟着变。</p>
<h2 id="4-Relational-Model"><a href="#4-Relational-Model" class="headerlink" title="4. Relational Model"></a>4. Relational Model</h2><p>人们每次改变物理层都要重新写数据管理系统，故Ted Codd注意到后提出了关系模型。</p>
<ul>
<li><p><strong>Relational Model：</strong></p>
<p>关系模型定义了一个基于关系的数据库抽象概念，有3个关键点：</p>
<ul>
<li>Store database in simple data structures (relations).</li>
<li>Access data through high-level language, DBMS figures out best execution strategy.</li>
<li>Physical storage left up to the DBMS implementation.</li>
</ul>
<p>简单来说就是：用简单的数据结构保存，用高级语言来访问，并让DBMS来执行最优策略以及处理物理层存储。</p>
</li>
<li><p><strong>关系模型定义的三个概念：</strong></p>
<ul>
<li><strong>Structure：</strong><br>关系定义和内容。也就是关系具有的属性以及可以有的值。</li>
<li><strong>Integrity：</strong><br>确保数据库的内容满足约束条件。比如：年份必须是数字。</li>
<li><strong>Manipulation：</strong><br>如何访问和修改数据库的内容。</li>
</ul>
</li>
<li><p><strong>关系(relation)：</strong><br>关系是一个**无序的集合(an unordered set)**，包含代表的实体的属性关系。因为是无序的，所以DBMS可以用它想要的任何方式存储它们，并允许优化。</p>
</li>
<li><p><strong>元组(tuple)：</strong><br>元组指的是**关系中的一组属性值(a set of attribute values in the relation, also known as its domain)**。</p>
<p>Originally, values had to be atomic or scalar, but now values can also be lists or nested data structures. Every attribute can be a special value, NULL, which means for a given tuple the attribute is undefined.</p>
<p>起初，值必须是**原子的(atomic)<strong>或者</strong>标量(scalar)**，但现在值也可以是一个特殊的值<code>NULL</code>，表示为定义。</p>
</li>
<li><p><strong>有n个属性的关系，叫做：n-ary relation</strong>。</p>
</li>
<li><p>一张二维表，每行对应一个元组，每列对应一个域。</p>
</li>
<li><p><strong>Keys：</strong><br>一个关系的<strong>primary key</strong>唯一的定义了单个元组。很多DBMS都支持auto-generated keys，所以程序就不需要手动增加了，但primary key还是在某些DBMS是需要的。</p>
<ul>
<li>Primary key&#x2F;主键：唯一的定义了单个元组。</li>
<li>Foreign key&#x2F;外键：指定一个关系中的属性必须映射到另一个关系中的元组。</li>
</ul>
<p><img src="C:\Users\satori\AppData\Roaming\Typora\typora-user-images\image-20230312011848991.png" alt="image-20230312011848991"></p>
</li>
</ul>
<h2 id="5-Data-Manipulation-Languages-DML"><a href="#5-Data-Manipulation-Languages-DML" class="headerlink" title="5. Data Manipulation Languages (DML)"></a>5. Data Manipulation Languages (DML)</h2><p>DML（data manipulation language）是数据操纵语言：它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言。</p>
<p>DDL（data definition language）是数据定义语言：DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。</p>
<p>DCL（Data Control Language）是数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。</p>
<p>有两类语言去保存和检索在数据库中的信息。</p>
<ul>
<li>Procedural：<br>The query specifies the (high-level) strategy the DBMS should use to find the desired result based on sets &#x2F; bags. (<strong>relational algebra</strong>)</li>
<li>Non-Procedural(Declarative 声明式的)：<br>The query specifies only what data is wanted and not how to find it. (<strong>relational calculus</strong>)</li>
</ul>
<p>一般现在都是用第二种的，我不管DBMS用什么策略，我只需要你给我我想要的数据。</p>
<h2 id="6-Relational-Algebra"><a href="#6-Relational-Algebra" class="headerlink" title="6. Relational Algebra"></a>6. Relational Algebra</h2><p>关系代数(Relational Algebra)就是一组基本操作，用于检索和操作关系中的图元。</p>
<p>每个操作符都需要一个或多个关系作为输入，并输出一个新的关系。为了编写查询，我们可以把这些运算符 “链 “在一起，以创建更复杂的操作。</p>
<p><img src="C:\Users\satori\AppData\Roaming\Typora\typora-user-images\image-20230312012338736.png" alt="image-20230312012338736"></p>
<p><strong>Select</strong> takes in a relation and outputs a subset of the tuples from that relation that satisfy a selection predicate. The predicate acts like a filter, and we can combine multiple predicates using conjunctions and disjunctions.</p>
<p><img src="C:\Users\satori\AppData\Roaming\Typora\typora-user-images\image-20230312012550025.png" alt="image-20230312012550025"></p>
<p><strong>Projection</strong> takes in a relation and outputs a relation with tuples that contain only specified attributes. You can rearrange the ordering of the attributes in the input relation as well as manipulate the values.</p>
<p><img src="C:\Users\satori\AppData\Roaming\Typora\typora-user-images\image-20230312012612509.png" alt="image-20230312012612509"></p>
<p><strong>Union</strong> takes in two relations and outputs a relation that contains all tuples that appear in at least one of the input relations. Note: The two input relations have to have the exact same attributes.</p>
<p><img src="C:\Users\satori\AppData\Roaming\Typora\typora-user-images\image-20230312012638191.png" alt="image-20230312012638191"></p>
<p><strong>Intersection</strong> takes in two relations and outputs a relation that contains all tuples that appear in both of the input relations. Note: The two input relations have to have the exact same attributes.</p>
<p><img src="C:\Users\satori\AppData\Roaming\Typora\typora-user-images\image-20230312012655770.png" alt="image-20230312012655770"></p>
<p><strong>Difference</strong> takes in two relations and outputs a relation that contains all tuples that appear in the first relation but not the second relation. Note: The two input relations have to have the exact same attributes.</p>
<p><img src="C:\Users\satori\AppData\Roaming\Typora\typora-user-images\image-20230312012712525.png" alt="image-20230312012712525"></p>
<p><strong>Product</strong>(笛卡尔积) takes in two relations and outputs a relation that contains all possible combinations for tuples from the input relations.</p>
<p><img src="C:\Users\satori\AppData\Roaming\Typora\typora-user-images\image-20230312012728132.png" alt="image-20230312012728132"></p>
<p><strong>Join</strong> takes in two relations and outputs a relation that contains all the tuples that are a combination of two tuples where for each attribute that the two relations share, the values for that attribute of both tuples is the same.</p>
<p><img src="C:\Users\satori\AppData\Roaming\Typora\typora-user-images\image-20230312012750042.png" alt="image-20230312012750042"></p>
<h1 id="Lesson-02-高级SQL（Advanced-SQL）"><a href="#Lesson-02-高级SQL（Advanced-SQL）" class="headerlink" title="Lesson#02. 高级SQL（Advanced SQL）"></a>Lesson#02. 高级SQL（Advanced SQL）</h1><p><strong>SQL</strong> (Structured Query Language:结构化查询语言) 是用于管理关系数据库管理系统（RDBMS）。 SQL 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。</p>
<p>DML（data manipulation language）是数据操纵语言：它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言。</p>
<p>DDL（data definition language）是数据定义语言：DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。</p>
<p>DCL（Data Control Language）是数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。</p>
<p>用户只需要使用声明性语言（即SQL）来指定他们想要的结果。DBMS负责确定产生该答案的最有效计划。</p>
<p>关系代数基于sets (unordered, no duplicates)。<br>SQL基于 bags (unordered, allows duplicates)</p>
<h2 id="1-SQL基础语法"><a href="#1-SQL基础语法" class="headerlink" title="1.SQL基础语法"></a>1.SQL基础语法</h2><ul>
<li><p><strong>SELECT 语句</strong></p>
<p>SELECT 语句用于从数据库中选取数据。</p>
<pre><code class="sql">SELECT column1, column2, ...
FROM table_name;

SELECT * FROM table_name;
</code></pre>
<p>SELECT DISTINCT 语句用于返回唯一不同的值。在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。</p>
<p><strong>DISTINCT 关键词</strong>用于返回唯一不同的值。</p>
<pre><code class="sql">SELECT DISTINCT column1, column2, ...
FROM table_name;
</code></pre>
</li>
<li><p><strong>WHERE 子句</strong></p>
<p>WHERE 子句用于提取那些满足指定条件的记录。</p>
<pre><code class="sql">SELECT column1, column2, ...
FROM table_name
WHERE condition;

SELECT * FROM Websites WHERE country=&#39;CN&#39;;
</code></pre>
<p>WHERE 子句中的运算符</p>
<p>下面的运算符可以在 WHERE 子句中使用：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;</td>
<td align="left">等于</td>
</tr>
<tr>
<td align="left">&lt;&gt;</td>
<td align="left">不等于。注释：在 SQL 的一些版本中，该操作符可被写成 !&#x3D;</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">大于</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于</td>
</tr>
<tr>
<td align="left">&gt;&#x3D;</td>
<td align="left">大于等于</td>
</tr>
<tr>
<td align="left">&lt;&#x3D;</td>
<td align="left">小于等于</td>
</tr>
<tr>
<td align="left">BETWEEN</td>
<td align="left">在某个范围内</td>
</tr>
<tr>
<td align="left">LIKE</td>
<td align="left">搜索某种模式</td>
</tr>
<tr>
<td align="left">IN</td>
<td align="left">指定针对某个列的多个可能值</td>
</tr>
</tbody></table>
</li>
<li><p><strong>AND &amp; OR 运算符</strong></p>
<p>AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。</p>
<p>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</p>
<p>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p>
<pre><code class="sql">SELECT * FROM Websites
WHERE alexa &gt; 15
AND (country=&#39;CN&#39; OR country=&#39;USA&#39;);
</code></pre>
</li>
<li><p><strong>ORDER BY 关键字</strong></p>
<p>ORDER BY 关键字用于对结果集进行排序,对结果集按照一个列或者多个列进行排序。</p>
<p>默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。</p>
<pre><code class="sql">SELECT * FROM table_name
ORDER BY column1, column2, ... ASC;

ORDER BY column1, column2, ... DESC;
</code></pre>
</li>
<li><p><strong>INSERT INTO 语句</strong></p>
<p>INSERT INTO 语句用于向表中插入新记录。</p>
<p>第一种形式无需指定要插入数据的列名，只需提供被插入的值即可（<strong>需要列出插入行的每一列数据</strong>）：</p>
<pre><code class="sql">INSERT INTO table_name
VALUES (value1,value2,value3,...);
</code></pre>
<p>第二种形式需要指定列名及被插入的值：</p>
<pre><code class="sql">INSERT INTO table_name (column1,column2,column3,...)
VALUES (value1,value2,value3,...);
</code></pre>
</li>
<li><p><strong>UPDATE 语句</strong></p>
<p>UPDATE 语句用于更新表中已存在的记录。</p>
<pre><code class="sql">UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;

UPDATE Websites 
SET alexa=&#39;5000&#39;, country=&#39;USA&#39; 
WHERE name=&#39;菜鸟教程&#39;;
</code></pre>
<p>如果我们省略了 WHERE 子句，执行以上代码会将 Websites 表中所有数据的 alexa 改为 5000，country 改为 USA。</p>
</li>
<li><p><strong>DELETE 语句</strong></p>
<p>DELETE 语句用于删除表中的行。</p>
<pre><code class="sql">DELETE FROM table_name
WHERE condition;
</code></pre>
<p>删除所有数据</p>
<p>您可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变：</p>
<pre><code class="sql">DELETE FROM table_name;
</code></pre>
<p><strong>注释：</strong>在删除记录时要格外小心！因为您不能重来！</p>
</li>
</ul>
<h2 id="2-Joins"><a href="#2-Joins" class="headerlink" title="2. Joins"></a>2. Joins</h2><p>结合一个或多个表的列，产生一个新的表。用来表达涉及跨越多个表的数据的查询，</p>
<ul>
<li><p>本节课举例用的例子：</p>
<pre><code class="sql">CREATE TABLE student (
    sid INT PRIMARY KEY,
    name VARCHAR(16),
    login VARCHAR(32) UNIQUE,
    age SMALLINT,
    gpa FLOAT
);
CREATE TABLE course (
    cid VARCHAR(32) PRIMARY KEY,
    name VARCHAR(32) NOT NULL
);
CREATE TABLE enrolled (
    sid INT REFERENCES student (sid),
    cid VARCHAR(32) REFERENCES course (cid),
    grade CHAR(1)
);
</code></pre>
</li>
<li><p>哪个学生在15-721拿到了A?</p>
<pre><code class="sql">SELECT s.name
FROM enrolled AS e, student AS s
WHERE e.grade = &#39;A&#39; AND e.cid = &#39;15-721&#39;
AND e.sid = s.sid;
</code></pre>
</li>
</ul>
<h2 id="3-Aggregate函数"><a href="#3-Aggregate函数" class="headerlink" title="3. Aggregate函数"></a>3. Aggregate函数</h2><p>聚合函数接受一组列表，然后产生一个单一的标量值作为其输出。基本上只能在SELECT输出列表中使用！</p>
<ul>
<li><p>AVG(COL): The average of the values in COL</p>
</li>
<li><p>MIN(COL): The minimum value in COL</p>
</li>
<li><p>MAX(COL): The maximum value in COL</p>
</li>
<li><p>SUM(COL)</p>
</li>
<li><p>COUNT(COL): The number of tuples in the relation</p>
</li>
<li><p>例子1：</p>
<p>Get # of students with a ‘@cs’ login.</p>
<pre><code class="sql">SELECT COUNT(*) FROM student WHERE login LIKE &#39;%@cs&#39;;
SELECT COUNT(login) FROM student WHERE login LIKE &#39;%@cs&#39;;
SELECT COUNT(1) FROM student WHERE login LIKE &#39;%@cs&#39;;
</code></pre>
</li>
<li><p>例子2：</p>
<p>Get # of students and their average GPA with a ‘@cs’ login. </p>
<p>得到<code>@cs</code>登录的学生的人数和平均GPA</p>
<pre><code class="SQL">SELECT AVG(gpa), COUNT(sid)
  FROM student WHERE login LIKE &#39;%@cs&#39;;
</code></pre>
<p>有些聚合函数支持<code>DISTINCT</code>关键字</p>
<p>Get # of unique students and their average GPA with a ‘@cs’ login.</p>
<p>得到通过<code>@cs</code>登录的学生数量，以及他们的GPA, 要求学生不能重复！</p>
<pre><code class="SQL">SELECT COUNT(DISTINCT login)
  FROM student WHERE login LIKE &#39;%@cs&#39;;
</code></pre>
</li>
<li><p>Non-aggregated values in SELECT output clause must appear in GROUP BY clause</p>
<p>例子3：Get the average GPA of students in each course.</p>
<p>得到在每个课上的学生的平均GPA</p>
<pre><code class="SQL">SELECT AVG(s.gpa), e.cid
  FROM enrolled AS e, student AS s
 WHERE e.sid = s.sid
 GROUP BY e.cid;
</code></pre>
</li>
<li><p>HAVING子句在聚合计算的基础上过滤输出结果。这使得HAVING的行为像一个GROUP BY的WHERE子句。</p>
<p>The HAVING clause filters output results based on aggregation computation. </p>
<p>This make HAVING behave like a WHERE clause for a GROUP BY.</p>
<p>例子5：获取学生平均GPA大于3.9的课程。</p>
<pre><code class="SQL">SELECT AVG(s.gpa) AS avg_gpa, e.cid
  FROM enrolled AS e, student AS s
 WHERE e.sid = s.sid
 GROUP BY e.cid
HAVING avg_gpa &gt; 3.9;
</code></pre>
<p>上述查询语法被许多主要的数据库系统所支持，但不符合SQL标准。</p>
<p>为了使查询符合标准，我们必须在AVG(S.GPA)的主体中重复使用HAVING子句</p>
<pre><code class="SQL">SELECT AVG(s.gpa), e.cid
FROM enrolled AS e, student AS s
WHERE e.sid = s.sid
GROUP BY e.cid
HAVING AVG(s.gpa) &gt; 3.9;
</code></pre>
</li>
</ul>
<h2 id="4-String-Operations"><a href="#4-String-Operations" class="headerlink" title="4. String Operations"></a>4. String Operations</h2><p>SQL标准是区分大小写的，而且只能是单引号！有一些函数可以处理字符串，可以在查询的任何部分使用。</p>
<ul>
<li><p>Pattern Matching:</p>
<p><strong>LIKE 操作符</strong>用于在 WHERE 子句中搜索列中的指定模式。</p>
<pre><code class="SQL">SELECT column1, column2, ...
FROM table_name
WHERE column LIKE pattern;
</code></pre>
</li>
<li><p>通配符</p>
<ul>
<li><code>%</code> 替代 0 个或多个字符</li>
<li><code>_</code>替代一个字符</li>
</ul>
</li>
<li><p><strong>String Function:</strong><br><code>SUBSTRING(S, B, E)</code><br><code>UPPER(S)</code></p>
</li>
<li><p><strong>Concatenation:</strong><br><img src="C:\Users\satori\AppData\Roaming\Typora\typora-user-images\image-20230313134548756.png" alt="image-20230313134548756"></p>
</li>
</ul>
<h2 id="5-Date-and-Time"><a href="#5-Date-and-Time" class="headerlink" title="5. Date and Time"></a>5. Date and Time</h2><ul>
<li><p>时间函数</p>
<ol>
<li>当前日期时间<br><code>NOW()</code>, <code>CURRENT_TIMESTAMP()</code></li>
<li>当前UNIX时间戳<br><code>UNIX_TIMESTAMP()</code></li>
<li>当前日期<br><code>CURRENT_DATE()</code></li>
<li>当前时间<br><code>CURRENT_TIME()</code></li>
</ol>
</li>
<li><p>日期时间转换函数</p>
<ol>
<li><p>当前时间戳转换为北京时间<br><code>FROM_UNIXTIME()</code></p>
</li>
<li><p>北京时间转换为时间戳<br><code>UNIX_TIMESTAMP()</code></p>
</li>
<li><p>时间中解析年月日时间<br><code>DATE_FORMAT(date, format)</code></p>
<pre><code>select DATE_FORMAT(&#39;2021-01-01 08:30:50&#39;,&#39;%Y-%m-%d&#39;)
</code></pre>
</li>
</ol>
</li>
<li><p>日期时间运算函数</p>
<ol>
<li><p>在某个时间的基础上加上或者减去某个时间<br><code>DATE_ADD(date,INTERVAL expr unit)</code><br><code>DATE_SUB(date,INTERVAL expr unit)</code></p>
</li>
<li><p>返回两个日期值之间的天数<br><code>DATEDIFF(expr1,expr2))</code></p>
<pre><code>select DATEDIFF(&#39;2021-01-02&#39;,&#39;2021-01-01&#39;)
</code></pre>
</li>
<li><p>时间差函数<br><code>TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)</code></p>
<p>unit：天(DAY)、小时(HOUR），分钟(MINUTE)和秒(SECOND)，TIMESTAMPDIFF函数比DATEDIFF函数用起来更加灵活</p>
</li>
</ol>
</li>
</ul>
<h2 id="6-Output-Redirection-输出重定向"><a href="#6-Output-Redirection-输出重定向" class="headerlink" title="6. Output Redirection(输出重定向)"></a>6. Output Redirection(输出重定向)</h2><p>你可以告诉DBMS将查询结果存储到另一个表中，而不是将查询结果返回给客户端（例如，终端）。结果存储到另一个表中。然后你可以在随后的查询中访问这些数据</p>
<ul>
<li><p>New Table: 将查询的输出存储到一个新的（永久）表中</p>
<pre><code>SELECT DISTINCT cid INTO CourseIds FROM enrolled;
</code></pre>
</li>
<li><p>Exustubg Table:</p>
<p>将查询的输出存储到数据库中已经存在的表中。该表 目标表必须有与目标表相同数量和相同类型的列，但输出查询中的列名不需要匹配。</p>
<pre><code>INSERT INTO CourseIds (SELECT DISTINCT cid FROM enrolled)
</code></pre>
</li>
</ul>
<h2 id="7-Output-Control"><a href="#7-Output-Control" class="headerlink" title="7. Output Control"></a>7. Output Control</h2><p>因为SQL是无序的，我们可以用ORDER BY来对输出进行排序</p>
<pre><code class="sql">SELECT sid, grade FROM enrolled WHERE cid = &#39;15-721&#39;
ORDER BY grade;
</code></pre>
<p>后面可以加<code>DESC</code>, <code>ASC</code>来指定排序策略</p>
<p>输出的数量可以用<code>LIMIT n</code> 进行指定</p>
<p>当然也可以用<code>OFFSET</code> 来提供一个bias。</p>
<pre><code class="sql">SELECT sid, name FROM student WHERE login LIKE &#39;%@cs&#39;
LIMIT 20 OFFSET 10;
</code></pre>
<h2 id="8-Nested-Queries（内部查询-x2F-查询嵌套）"><a href="#8-Nested-Queries（内部查询-x2F-查询嵌套）" class="headerlink" title="8. Nested Queries（内部查询&#x2F;查询嵌套）"></a>8. Nested Queries（内部查询&#x2F;查询嵌套）</h2><p>在其他查询中调用查询，在单个查询中执行更复杂的逻辑。嵌套查询往往难以优化。</p>
<p>外部查询的范围包括在内部查询中（即内部查询可以访问来自外部<br>查询），反之不行。</p>
<ul>
<li><p>内部查询几乎可以出现在一个查询的任何部分。</p>
<p><code>SELECT</code> Output Targets</p>
<pre><code class="sql">SELECT (SELECT 1) AS one FROM student;
</code></pre>
<p><code>FROM</code> Clause:</p>
<pre><code class="sql">SELECT name
    FROM student AS s, (SELECT sid FROM enrolled) AS e
    WHERE s.sid = e.sid;
</code></pre>
<p><code>WHERE</code> Clause</p>
<pre><code class="sql">SELECT name FROM student
    WHERE sid IN ( SELECT sid FROM enrolled );
</code></pre>
</li>
<li><p>例子： 获取在15-445中注册的学生名字</p>
<pre><code class="sql">SELECT name FROM student
    WHERE sid IN (
        SELECT sid FROM enrolled
        WHERE cid = &#39;15-445&#39;
);
</code></pre>
</li>
</ul>
<p>请注意，根据它在查询中出现的位置，sid有不同的范围。</p>
<ul>
<li><p>例子：<br>找到注册了至少一门课的最大的学生id</p>
<pre><code class="sql">SELECT student.sid, name
  FROM student
  JOIN (SELECT MAX(sid) AS sid
        FROM enrolled) AS max_e
    ON student.sid = max_e.sid;
</code></pre>
</li>
</ul>
<p>Nested Query Results Expressions:</p>
<ul>
<li><p>关键字：</p>
<ul>
<li><code>ALL</code><br>Must satisfy expression for all rows in sub-query</li>
<li><code>ANY</code><br>Must satisfy expression for at least one row in sub-query.</li>
<li><code>IN</code><br>Equivalent to &#x3D;ANY().</li>
<li><code>EXISTS</code><br>At least one row is returned.</li>
</ul>
</li>
<li><p>例子：</p>
<p>找到所有没有学生注册的课</p>
<pre><code class="sql">SELECT * FROM course
    WHERE NOT EXISTS(
        SELECT * FROM enrolled
        WHERE course.cid = enrolled.cid
);
</code></pre>
</li>
</ul>
<h2 id="10-Window-Function"><a href="#10-Window-Function" class="headerlink" title="10. Window Function"></a>10. Window Function</h2><p>A window function perform “sliding” calculation across a set of tuples that are related. Like an aggregation but tuples are not grouped into a single output tuple.</p>
<ul>
<li><p>函数： 窗口函数可以是我们上面讨论的任何一个聚合函数。也有一些特殊的窗口函数。</p>
<ol>
<li><code>ROW_NUMBER</code>: 当前列的数字</li>
<li><code>RANK</code>: 当前列的顺序</li>
</ol>
</li>
<li><p>Grouping: <strong>OVER子句指定了在计算窗口函数时如何对图元进行分组</strong>。使用PARTITION BY来指定分组</p>
<pre><code class="sql">SELECT cid, sid, ROW_NUMBER() OVER (PARTITION BY cid)
  FROM enrolled ORDER BY cid;
</code></pre>
<p>我们也可以在OVER中放入ORDER BY，以确保结果的确定性排序，即使数据库内部发生变化。</p>
<pre><code class="sql">SELECT *, ROW_NUMBER() OVER (ORDER BY cid)
    FROM enrolled ORDER BY cid;
</code></pre>
</li>
<li><p><strong>重要提示：</strong></p>
</li>
<li><p>DBMS在窗函数排序后计算<code>RANK</code>，而在排序前计算<code>ROW_NUMBER</code>。</p>
<ul>
<li><p>找到每门课程中成绩第二高的学生</p>
<pre><code class="sql">SELECT * FROM (
    SELECT *, RANK() OVER (PARTITION BY cid
        ORDER BY grade ASC) AS rank
    FROM enrolled) AS ranking
WHERE ranking.rank = 2;
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="11-Commom-Table-Expressions"><a href="#11-Commom-Table-Expressions" class="headerlink" title="11. Commom Table Expressions"></a>11. Commom Table Expressions</h2><p>在编写更复杂的查询时，通用表表达式（CTE）是窗口或嵌套查询的一种替代方法。复杂的查询时，可以替代窗口或嵌套查询。它们提供了一种方法来为用户在一个更大的查询中编写辅助语句.</p>
<p>可以理解为一个辅助表。</p>
<p><code>WITH</code>子句将内部查询的输出与一个具有该名称的临时结果绑定。</p>
<ul>
<li><p>例子：<br>生成一个名为cteName的CTE，其中包含一个单一属性设置为 “1 “的元组。从这个CTE中选择所有属性。</p>
<pre><code class="sql">WITH cteName AS (
    SELECT 1
)
SELECT * FROM cteName;
</code></pre>
<p>我们可以在AS之前将输出列绑定到名称上</p>
<pre><code class="sql">WITH cteName (col1, col2) AS (
    SELECT 1, 2
)
SELECT col1 + col2 FROM cteName;
</code></pre>
<p>一个查询可能包含多个CTE声明</p>
<pre><code>WITH cte1 (col1) AS (SELECT 1), cte2 (col2) AS (SELECT 2)
SELECT * FROM cte1, cte2;
</code></pre>
</li>
<li><p>递归能力<br>在WITH后面添加RECURSIVE关键字允许CTE引用自己。这使得在SQL查询中可以实现递归。有了递归的CTE，SQL被证明是图灵完备的，这意味着它在计算上的表现力不亚于更多的通用编程语言</p>
</li>
<li><p>例子：打印从1到10的数字</p>
<pre><code>WITH RECURSIVE cteSource (counter) AS (
    ( SELECT 1 )
    UNION
    ( SELECT counter + 1 FROM cteSource
        WHERE counter &lt; 10 )
)
SELECT * FROM cteSource;
</code></pre>
</li>
</ul>
<h1 id="Lesson-03-amp-04-存储引擎"><a href="#Lesson-03-amp-04-存储引擎" class="headerlink" title="Lesson#03&amp;04. 存储引擎"></a>Lesson#03&amp;04. 存储引擎</h1><h2 id="1-Storage"><a href="#1-Storage" class="headerlink" title="1. Storage"></a>1. Storage</h2><ul>
<li><p>我们将关注一个”面向磁盘(disk-oriented)”的DBMS架构，它假定数据库的主要存储位置是在非易失性磁盘上。越接近CPU，存储就越快，容量越小，也更贵。</p>
<ul>
<li>Volatile Devices （MEMORY）</li>
<li>Non-Volatile Devices （DISK）</li>
</ul>
</li>
<li><p>注意：<br>这课不讨论NVMe SSD – non-volatile memory express.</p>
</li>
<li><p>We will focus on hiding the latency of the disk rather than optimizations with registers and caches since getting data from disk is so slow. 我们将专注于隐藏磁盘的延迟，而不是使用寄存器和缓存进行优化，因为从磁盘获取数据非常缓慢。</p>
<p><img src="C:\Users\satori\AppData\Roaming\Typora\typora-user-images\image-20230313140745881.png" alt="image-20230313140745881"></p>
</li>
</ul>
<h2 id="2-Disk-Oriented-DBMS-Overview"><a href="#2-Disk-Oriented-DBMS-Overview" class="headerlink" title="2. Disk-Oriented DBMS Overview"></a>2. Disk-Oriented DBMS Overview</h2><ul>
<li>数据库都在磁盘上，数据库文件中的数据被组织成页，第一页是目录页。为了对数据进行操作，DBMS需要将数据引入内存。<ul>
<li>它通过拥有<strong>一个缓冲池来管理数据在磁盘和内存之间的交换</strong></li>
<li>DBMS也有一个执行查询的执行引擎。执行引擎将要求缓冲池提供一个特定的页面，而缓冲池将负责把该页面带入内存，并给执行引擎一个指向内存中该页面的指针<br>缓冲池管理器将确保在执行引擎对该部分内存进行操作时，该页就在那里。</li>
</ul>
</li>
</ul>
<h2 id="3-DBMS-vs-OS"><a href="#3-DBMS-vs-OS" class="headerlink" title="3. DBMS vs. OS"></a>3. DBMS vs. OS</h2><ul>
<li>DBMS的一个高级设计目标是支持超过可用内存量的数据库。因为访问disk的代价很大，所以使用disk应该要小心。我们不希望从磁盘上访问数据时停顿太久，从而拖慢其他一切。我们希望DBMS能够处理在等待从磁盘获取数据时，能够处理其他查询。</li>
<li>这个高层次的设计目标就像虚拟内存一样，有一个大的地址空间和一个供操作系统从磁盘引入页面的地方。</li>
<li>实现这种虚拟内存的方法之一是使用mmap来映射进程地址空间中的文件内容，这使得操作系统负责在磁盘和内存之间来回移动页面。<br>但不幸的是，如果mmap遇到页面故障，进程将会被阻塞。<ul>
<li>如果你需要写入，你永远不想在你的DBMS中使用mmap。</li>
<li>DBMS（几乎）总是想自己控制事情，而且可以做得更好，因为它知道更多关于被访问的数据和被处理的查询。</li>
<li>操作系统不是你的朋友。</li>
</ul>
</li>
<li>可以通过使用操作系统：<ul>
<li><code>madvise</code>: 告诉操作系统你打算何时读某些页面。</li>
<li><code>mlock</code>: 告诉操作系统不要把内存范围换到磁盘上。</li>
<li><code>msync</code>: 告诉操作系统将内存范围刷新到磁盘。</li>
</ul>
</li>
</ul>
<p><strong>出于正确性和性能的考虑，我们不建议在DBMS中使用<code>mmap</code>。</strong></p>
<blockquote>
<p>Even though the system will have functionalities that seem like something the OS can provide, having the DBMS implement these procedures itself gives it better control and performance</p>
</blockquote>
<h2 id="4-File-Storage"><a href="#4-File-Storage" class="headerlink" title="4. File Storage"></a>4. File Storage</h2><ul>
<li>在其最基本的形式中，DBMS将数据库存储为磁盘上的文件。有些可能使用文件层次结构，有些则可能使用单个文件</li>
<li>操作系统对这些文件的内容一无所知。只有DBMS知道如何解读它们的内容，因为它是以DBMS特有的方式编码的。</li>
<li>DBMS的存储管理器负责管理数据库的文件。它将文件表示为一个 页的集合。它还跟踪哪些数据被读和写到了页面上，以及这些页面有多少可用空间。这些页面中还有多少可用空间。</li>
</ul>
<h2 id="5-Database-Pages"><a href="#5-Database-Pages" class="headerlink" title="5. Database Pages"></a>5. Database Pages</h2><ul>
<li><p>DBMS将数据库组织在一个或多个文件中的固定大小的数据块，称为页。页面可以包含不同种类的数据（tuple、indexes等）。</p>
</li>
<li><p>大多数系统不会将这些类型混合在一页中。<br>有些系统会要求页面是自成一体（self-contained）的，也就是说，阅读每个页面所需的所有信息都在页面本身。读取每一页的所有信息都在页面本身</p>
</li>
<li><p>每个页面都有一个独特的标识符identifier</p>
<ul>
<li><p>如果数据库是一个单一的文件，那么页面ID可以是文件的偏移量。</p>
</li>
<li><p>大多数DBMS有一个中介层（indirection layer），将页面ID映射到文件路径和偏移量。 系统的上层会要求提供一个特定的页号。然后，存储管理程序将把这个页号变成一个文件和一个偏移量以找到该页。</p>
</li>
<li><p>大多数DBMS使用固定大小的页面，以避免支持可变大小页面所需的工程开销。</p>
<p>因为，对于可变大小的页面，删除一个页面会在文件中产生一个hole，而DBMS难以用新的页面来填补。</p>
</li>
</ul>
</li>
<li><p>页在DBMS的3个概念</p>
<ol>
<li>Hardware page (usually 4 KB).</li>
<li>OS page (4 KB).</li>
<li>Database page (1-16 KB）</li>
</ol>
</li>
<li><p>存储设备保证写的操作是atomic 原子的。<br>这意味着，如果我们的数据库页面比我们的硬件页面大，DBMS将不得不采取额外的措施 以确保数据被安全地写出来。 因为当系统崩溃时，程序可能已经完成了将数据库页面写入磁盘的一部分</p>
</li>
</ul>
<h2 id="6-Database-Heap"><a href="#6-Database-Heap" class="headerlink" title="6. Database Heap"></a>6. Database Heap</h2><ul>
<li><p>有几种方法可以找到DBMS在磁盘上想要的页面的位置，堆文件组织是其中一种方法<br>堆文件是一个无序的页面集合，其中的图元是按照 随机顺序存储。</p>
</li>
<li><p>DBMS可以通过使用页面的链接列表或页面目录在磁盘上找到一个给定的页面ID</p>
<ol>
<li><p>Linked List:<br>Header page持有指向自由页列表和数据页列表的指针。然而，如果 DBMS正在寻找一个特定的页面，它必须在数据页列表上进行顺序扫描，直到它找到它要找的页面。</p>
</li>
<li><p>Page Directory:</p>
<p>DBMS维护特殊的页面，跟踪数据页的位置以及每页的可用空间。</p>
</li>
</ol>
</li>
</ul>
<h2 id="7-Page-Layout"><a href="#7-Page-Layout" class="headerlink" title="7. Page Layout"></a>7. Page Layout</h2><ul>
<li><p>每个页面都包括一个header，记录关于页面内容的元数据。</p>
<ul>
<li>Page size</li>
<li>Checksum</li>
<li>DBMS version</li>
<li>Transaction visibility</li>
<li>Self-containment (Some systems like Oracle require this.)</li>
</ul>
</li>
<li><p>放置数据的一个strawman方法是 追踪DBMS在一个页面中存储了多少个tuples，然后在每次添加新的tuples 的时候追加到最后面。然而，问题出现在当tuples被删除或者是变长 variable-length属性的时候</p>
</li>
<li><p>有2个主流方法去在一个page中放置数据：</p>
<ol>
<li><p><strong>slotted-page</strong><br>页面将slots映射到offsets</p>
<ul>
<li>Most common approach used in DBMSs today.</li>
<li>Header keeps track of the number of used slots, the offset of the starting location of the last used slot, and a slot array, which keeps track of the location of the start of each tuple.</li>
<li>To add a tuple, the slot array will grow from the beginning to the end, and the data of the tuples will grow from end to the beginning. The page is considered full when the slot array and the tuple data meet</li>
</ul>
</li>
<li><p><strong>log-structured</strong></p>
<p>下一课介绍。</p>
</li>
</ol>
</li>
</ul>
<h2 id="8-Tuple-Layout"><a href="#8-Tuple-Layout" class="headerlink" title="8. Tuple Layout"></a>8. Tuple Layout</h2><p>tuples本质上是一个字节序列。DBMS的工作是将这些字节解释为属性类型和值。</p>
<ul>
<li><p>Tuple Header：包含了tuple的元数据</p>
<ul>
<li>DBMS的并发控制协议的可见性信息。关于哪个事务创建&#x2F;修改了该元组</li>
<li>NULL值的位图。</li>
<li>注意，DBMS不需要在这里存储关于数据库模式的元数据。</li>
</ul>
</li>
<li><p>Tuple Data：数据的实际属性</p>
<ul>
<li>属性通常按照你创建表时指定的顺序存储</li>
<li>大多数DBMS不允许一个tuple超过一个页面的大小。</li>
</ul>
</li>
<li><p>Unique Identifier</p>
<ul>
<li>数据库中的每个tuple都被分配一个唯一的标识符</li>
<li>一般是：<code>page_id + (offset or slow)</code></li>
<li>一个应用程序<strong>不能</strong>依赖这些ID来表示任何东西</li>
</ul>
</li>
<li><p>De-normalized Tuple Data:</p>
<p>如果两个表是相关的，DBMS可以 “pre-join”它们，所以这些表最终会出现在<br>在同一个页面上。这使得读取速度加快，因为DBMS只需要加载一个页面而不是两个<br>独立的页面。然而，这使得更新更加昂贵，因为DBMS需要更多的空间给每个<br>tuples</p>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/DataBase/" style="color: #ffa2c4">
                DataBase
            </a>
        </span>
        
    </div>
    <a href="/2023/03/10/CMU15-445/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/03/09/STL/">
        <h2 class="post-title">STL</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/C/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                C++
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/9
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。</p>
<blockquote>
<p>STL从广义上讲分为三类: algorithm(算法) 、container(容器)、iterator(迭代器)。容器和算法可以通过迭代器进行无缝的连接。</p>
</blockquote>
<p>STL 提供了六大组件，彼此组合套用协同工作。这六大组件分别是：</p>
<ul>
<li>容器（Containers）：各种数据结构，如 vector、list、deque、set、map 等。从实现的角度来看，容器是一种 class template。</li>
<li>算法（Algorithms）：各种常用算法，提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作，比如 sort、search、copy、erase。从实现的角度来看，<strong>STL 算法是一种 function template</strong>。</li>
<li>迭代器（Iterators）：迭代器用于遍历对象集合的元素，扮演容器与算法之间的胶合剂，是所谓的“泛型指针”，共有 5 种类型，以及其他衍生变化。从实现角度来看，迭代器是一种将 operator*、operator-&gt;、operator++、operator– 等指针操作予以重载的 class template。所有的 STL 容器附带有自己专属的迭代器，因为只有容器设计者才知道如何遍历自己的元素。</li>
<li>仿函数（Functors）：也称为函数对象（Function object），行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了 operator() 的 class 或者 class template。</li>
<li>适配器（Adaptors）：一种用来修饰容器或者仿函数或迭代器接口的东西。例如 STL 提供的 queue 和 stack，就是一种空间配接器，因为它们的底部完全借助于 deque。</li>
<li>分配器（Allocators）：也称为空间配置器，负责空间的配置与管理。从实现的角度来看，配置器是一个实现了动态配置空间、空间管理、空间释放的 class template。</li>
</ul>
<p>STL 六大组件的交互关系</p>
<p><img src="/picturestl1.png" alt="img"></p>
<p>使用STL的好处：</p>
<ul>
<li>STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</li>
<li>STL的一个重要特点是数据结构和算法的分离。(内部使用的模板，或者说泛型编程)</li>
<li>程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL。比精力用在开发上</li>
<li>STL具有高可重用性、高性能、高移植性、跨平台等优点<ul>
<li>高可重用性: STL中几乎所有的代码的采用了模板类和模板函数的方式实现，这相当于传统的由函数和类组成的库来说提供了更好的代码重用机会。</li>
<li>高性能：底层使用的数据结构和算法比较优秀，如map的红黑树</li>
<li>高移植性：因为是内建在编译器之内，项目A中用STL编写的模块可以直接移植到项目B上。</li>
<li>跨平台：windows上写的可以在Linux上运行(反之一同)</li>
</ul>
</li>
</ul>
<p>一．</p>
<p>二 vector扩容原理<br>1新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就会分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。注意不是在原来空间后直接增加空间<br>2对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。<br>3不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。</p>
<p>三 vector扩容为什么以2倍增长<br>1时间和空间的权衡，简单来说， 空间分配的多，平摊时间复杂度低，但浪费空间也多。<br>2 均摊添加每个元素的开销最小。</p>
<p>四 vector扩容为什么以1.5倍增长<br>理想分配方案是是在第N次分配的时候能重用之前N-1次释放的内存，如果按照1.5分配，1，1.5，3，4.5……当你需要分配4.5时，前面已分配5.5，你可以直接利用，把旧数据move过去。但选择两倍的增长比如像这样：1，2，4，8，16，32，… 每次需要申请的空间都大于用到前面释放的内存(4&gt;2+1)，无法重用。</p>
<p>五 vector常用接口：<br>• 清空vector可以使用成员函数c.clear()<br>• 判断vector是否为空，可以使用成员函数empty()，如果为空返回true，否则返回false<br>• vector输出最后一个元素的引用可以用back()成员函数，如果容器为空，则行为未定义<br>• vector输出第一个元素的引用可以用front()成员函数，如果容器为空，则行为未定义<br>• vector支持用下标访问元素，类似数组一样c[n]其中n是一个无符号整数，如果n大于容器的长度，那么行为未定义<br>• vector为了防止越界访问，其中有成员函数c.at(n)，返回下标为n的元素的引用。如果下标越界，那么抛出out_of_range的异常<br>• pop_back()成员函数用来删除vector中的最后一个元素，如果容器为空会出现未定义行为。<br>• c.erase(it)成员函数，删除迭代器it所指向的元素，返回一个指向被删除元素之后的迭代器，如果it指向最后一个元素，那么返回以为尾后迭代器（通常是end()）。若it就是end()，那么行为未定义。<br>• c.erase(beg,ed)删除[beg,ed)范围的元素，同时返回最后一个元素的后面的迭代器，如果ed就是尾后迭代器，那么还返回一个尾后迭代器。<br>• vector中begin和end函数返回的是什么？<br>begin返回的是第一个元素的迭代器，end返回的是最后一个元素后面位置的迭代器。前闭后开区间【）<br>• vector中的reserve和resize的区别<br>reserve是直接扩充到已经确定的大小，可以减少多次开辟、释放空间的问题（优化push_back），就可以 提高效率，其次还可以减少多次要拷贝数据的问题。reserve只是保证vector中的空间大小（capacity）最少 达到参数所指定的大小n。reserve()只有一个参数。<br>resize()可以改变有效空间的大小，也有改变默认值的功能。capacity的大小也会随着改变。resize()可以有 多个参数。<br>• vector中的size和capacity的区别<br>size表示当前vector中有多少个元素（finish - start）;<br>capacity函数则表示它已经分配的内存中可以容纳多少元素（end_of_storage - start）;<br>• vector迭代器失效的情况<br>当插入一个元素到vector中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。 当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。erase方法会返回下 一个有效的迭代器，所以当我们要删除某个元素时，需要it&#x3D;vec.erase(it)。<br>• 正确释放vector的内存(clear(), swap(), shrink_to_fit())<br>vec.clear()：清空内容，但是不释放内存。<br>vector().swap(vec)：清空内容，且释放内存，想得到一个全新的vector。 vec.shrink_to_fit()：请求容器降低其capacity和size匹配。 vec.clear();vec.shrink_to_fit();：清空内容，且释放内存。<br>• vector中erase方法与algorithn中的remove方法区别<br>vector中erase方法真正删除了元素，迭代器不能访问了。<br>remove只是简单地将元素移到了容器的最后面，迭代器还是可以访问到。因为algorithm通过迭代器进行操作，不知道容器的内部结构，所以无法进行真正的删除。</p>
<p>六 List原理</p>
<p>list是由双向链表实现的，因此内存空间是不连续的。<br>list的随机访问效率不好，需要遍历元素，时间复杂度为o(n)。<br>3.底层是双向链表，所以每个元素有两个指针的额外空间开销。<br>4.在任何位置都能高效地插入和删除元素。只要改变元素的指针值，不需要拷贝元素。<br>七 vector、list、queue选择原则：<br>1需要对数据高效地随机访问(存取)，而不在乎插入和删除的效率，采用vector<br>2需要大量插入、删除数据，而不关心随机访问数据，采用list<br>3需要随机访问数据，而且关心前后增删数据的能力，采用deque<br>4对数据中间的增删操作比较多:采用list，建议在排序的基础上，批量进行增删可以对运行效率提供最大的保证</p>
<p>八 map的底层实现<br>容器的数据结构是采用红黑树进行管理，插入的元素健位不允许重复，所使用的节点元素的比较函数，只对元素的健值进行比较，元素的各项数据可通过健值检索出来。map容器是一种关联容器。</p>
<p>九map和unordered_map的实现机理：<br>map:是基于红黑树来实现的（红黑树是非常严格的平衡二叉搜索树），红黑树具有自动排序功能，红黑树的每一个节点都代表着map中的一个元素，因此对于map的查找，删除和插入操作都是对红黑树的操作。<br>unordered_map:是基于哈希表来实现的，查找的时间复杂度是O(1),在海量数据处理中有着广泛的应用。</p>
<p>十 map和unordered_map的优缺点<br>map的优点：（1）map是有序的（2）基于红黑树实现，查找的时间复杂度是O(n)<br>map的缺点：空间占用率比较高，因为内部实现了红黑树，虽然提高了运行效率，但是每个节点都要保存父亲节点和孩子节点和红黑树的性质，使得每一个节点都占用大量的空间。<br>适用的情况：对于要有序的结构，适用map<br>unordered_map的优点：因为内部是哈希表来实现的，所以查找效率会非常高<br>unordered_map的缺点：哈希表的建立比较费时<br>适用的情况：对于查找问题，适用unordered_map会更好一点。</p>
<p>十一 Map插入元素方法<br>map&lt;int, string&gt; mapStudent;<br>1 mapStudent.insert(pair&lt;int, string&gt;(1, “student_one”));<br>2 mapStudent.insert(map&lt;int, string&gt;::value_type (1, “student_one”));<br>3 mapStudent[1] &#x3D; “student_one”;<br>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对应的值</p>
<p>十二 为何map和set的插入删除效率比其他序列容器高<br>因为不需要内存拷贝和内存移动</p>
<p>十三 当数据元素增多时（从10000到20000），map的set的查找速度会怎样 变化？<br>RB-TREE用二分查找法，时间复杂度为logn，所以从10000增到20000时，查找次数从log10000&#x3D;14次到 log20000&#x3D;15次，多了1次而已。</p>
<p>十四 map 、set、multiset、multimap的特点<br>set和multiset会根据特定的排序准则自动将元素排序，set中元素不允许重复，multiset可以重复。 map和multimap将key和value组成的pair作为元素，根据key的排序准则自动将元素排序（因为红黑树也是 二叉搜索树，所以map默认是按key排序的），map中元素的key不允许重复，multimap可以重复。 map和set的增删改查速度为都是logn，是比较高效的。</p>
<p>十五 为何map和set每次insert之后， 以前保存的iterator不会失效？<br>存储的是结点，不需要内存拷贝和内存移动。 插入操作只是结点指针换来换去，结点内存没有改变。而iterator就像指向结点的指针，内存没变，指向内 存的指针也不会变。 6</p>
<p>十六 为何map和set不能像vector一样有个reserve函数来预分配数据?<br>在map和set内部存储的已经不是元素本身了，而是包含元素的结点。也就是说map内部使用的Alloc并不是 map声明的时候从参数中传入的Alloc。</p>
<p>十七 set底层实现<br>底层是红黑树，set会根据待定的排序准则，自动将元素排序。不允许元素重复。</p>
<p>十八 set, multiset (map,multimap)<br>set和multiset会根据特定的排序准则自动将元素排序，set中元素不允许重复，multiset可以重复。因为是排序的，所以set中的元素不能被修改，只能删除后再添加。</p>
<p>十九 set的底层实现实现为什么不用哈希表而使用红黑树？<br>set中元素是经过排序的，红黑树也是有序的，哈希是无序的 如果只是单纯的查找元素的话，那么肯定要选哈希表了，因为哈希表在的最好查找时间复杂度为O(1)，并且 如果用到set中那么查找时间复杂度的一直是O（1），因为set中是不允许有元素重复的。而红黑树的查找时 间复杂度为O(lgn)</p>
<p>二十 hash表<br>hash表的实现，包括STL中的哈希桶长度常数。<br>hash表的实现主要涉及两个问题：散列函数和碰撞处理。<br>1）hash function （散列函数）。最常见的散列函数：f(x) &#x3D; x % TableSize .<br>2）碰撞问题（不同元素的散列值相同）。解决碰撞问题的方法有许多种，包括线性探测、二次探测、开链等做法。SGL版本使用开链法，使用一个链表保持相同散列值的元素。</p>
<p>二十一 你怎样理解迭代器？<br>Iterator(迭代器)用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示，相当于智能指针。</p>
<p>二十二 迭代器失效问题<br>vector 迭代器<br>当插入一个元素后，插入点之前的迭代器如果未扩容则不受影响，插入点之后的迭代器失效；<br>当插入一个元素后，capacity 如果有变化，则容器需要重新分配内存，所有迭代器都会失效；<br>当进行删除操作后，指向删除点及之后元素的迭代器全部失效。<br>deque 迭代器<br>在容器 begin&#x2F;end 插入操作所有迭代器不受影响；<br>在容器非 begin&#x2F;end 的位置插入和删除操作都会使指向该容器元素的所有迭代器失效。<br>在容器 begin&#x2F;end 删除元素会使指向被删除元素的迭代器失效；<br>List&#x2F;forward_list 迭代器<br>list insert 操作不会使 list 迭代器失效；<br>list erase 操作会使当前指向被删除元素的迭代器失效，其它迭代器正常。<br>set 迭代器<br>set 的 insert 操作不会使 set 迭代器失效；<br>set erase操作会使当前指向被删除元素的迭代器失效，其它迭代器正常。<br>map 迭代器<br>map 的 insert 操作不会使 map 迭代器失效；<br>map erase 删除操作会使当前指向被删除元素的迭代器失效</p>
<p>二十三 vector为何每次insert之后，以前保存的iterator不会失效?<br>答:iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。相对于vector来说，每一次删除和插入，指针都有可能失效，调用push_back在尾部插入也是如此。因为为了保证内部数据的连续存放，iterator指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时push_back的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。特别时在和find等算法在一起使用的时候，牢记这个原则:不要使用过期的iterator。</p>
<p>二十四 vector、list、map、deque用erase（it）后，迭代器的变化。<br>vector和deque是序列式容器，其内存分别是连续空间和分段连续空间，删除迭代器it后，其后面的迭代器都失效了，此时it及其后面的迭代器会自动加1，使it指向被删除元素的下一个元素。<br>list删除迭代器it时，其后面的迭代器都不会失效，将前面和后面连接起来即可。<br>map也是只能使当前删除的迭代器失效，其后面的迭代器依然有效。</p>
<p>二十五 不允许有遍历行为的容器有哪些（不提供迭代器）？<br>1）queue，除了头部外，没有其他方法存取deque的其他元素。<br>2）stack（底层以deque实现），除了最顶端外，没有任何其他方法可以存取stack的其他元素。<br>3）heap，所有元素都必须遵循特别的排序规则，不提供遍历功能。</p>
<p>二十六 stl中alloc<br>SGI 版本STL的默认配置器std::alloc。参见：《STL源码剖析》<br>1）考虑到小型区块所可能造成的内存碎片问题，SGI设计了双层配置器。第一级配置器直接使用malloc()和free()；第二级则视情况采取不同的策略：当配置区块超过128bytes时，视为“足够大”，便调用第一级配置器；当配置区块小于128bytes时，视之为“过小”，为了降低额外负担，便采用memory pool（内存池）整理方式，而不在求助于第一级配置器。<br>2）内存池的核心：内存池和16个自由链表（各自管理8,16，…，128bytes的小额区块）。在分配一个小区块时，首先在所属自由链表中寻找，如果找到，直接抽出分配；若所属自由链表为空，则请求内存池为所属自由链表分配空间；默认情况下，为该自由链表分配20个区块，若内存池剩余容量不足，则分配可分配的最大容量；若内存池连一个区块都无法分配，则调用chunk_alloc为内存池分配一大块区块；若内存不足，则尝试调用malloc分配，否则返回bad_alloc异常。</p>
<p>二十七 STL线程不安全的情况<br>在对同一个容器进行多线程的读写、写操作时；<br>在每次调用容器的成员函数期间都要锁定该容器；<br>在每个容器返回的迭代器（例如通过调用begin或end）的生存期之内都要锁定该容器； 在每个在容器上调用的算法执行期间锁定该容器。</p>
<p>二十八 priority_queue的底层原理<br>priority_queue：优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是当前队列中优先级最 高的那一个。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #ff7d73">
                C++
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/STL/" style="color: #00bcd4">
                STL
            </a>
        </span>
        
    </div>
    <a href="/2023/03/09/STL/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/03/06/Linux/">
        <h2 class="post-title">Linux</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Linux/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Linux
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/6
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="Linux-配置"><a href="#Linux-配置" class="headerlink" title="Linux 配置"></a>Linux 配置</h1><p>windows powershell</p>
<pre><code class="shell">wsl --installl -d Ubuntu-20.04
</code></pre>
<p>更新软件包</p>
<pre><code class="shell">apt-get update
</code></pre>
<p>安装最常用linux桌面程序gedit</p>
<pre><code class="shell">apt install gedit
</code></pre>
<p>安装编译工具gcc+cmake</p>
<pre><code class="shell">apt install build-essential
apt install cmake
</code></pre>
<pre><code class="shell">apt-get install vim
</code></pre>
<h1 id="Linux-系统目录结构"><a href="#Linux-系统目录结构" class="headerlink" title="Linux 系统目录结构"></a>Linux 系统目录结构</h1><pre><code class="shell">ls /
</code></pre>
<p><img src="/image-20230309080718084.png" alt="image-20230309080718084"></p>
<p>树状目录结构：</p>
<p><img src="/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="img"></p>
<p><strong>系统启动必须：</strong></p>
<ul>
<li><p><code>/boot</code>：存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。</p>
</li>
<li><p><code>/etc</code>：<strong>存放</strong>所有<strong>的系统需要的</strong>配置文件<strong>和</strong>子目录列表，**更改目录下的文件可能会导致系统不能启动。</p>
</li>
<li><p><code>/lib</code>：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p>
</li>
<li><p><code>/sys</code>： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中</p>
</li>
</ul>
<p><strong>指令集合：</strong></p>
<ul>
<li><p><code>/bin</code>：存放着最常用的程序和指令</p>
</li>
<li><p><code>/sbin</code>：只有系统管理员能使用的程序和指令。是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p>
</li>
</ul>
<p><strong>外部文件管理：</strong></p>
<ul>
<li><p><code>/dev</code> ：Device(设备)的缩写, 存放的是Linux的外部设备。<strong>注意：</strong>在Linux中访问设备和访问文件的方式是相同的。</p>
</li>
<li><p><code>/media</code>：类windows的<strong>其他设备，</strong>例如U盘、光驱等等，识别后linux会把设备放到这个目录下。</p>
</li>
<li><p><code>/mnt</code>：临时挂载别的文件系统的，我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
</ul>
<p><strong>临时文件：</strong></p>
<ul>
<li><p><code>/run</code>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。</p>
</li>
<li><p><code>/lost+found</code>：一般情况下为空的，系统非法关机后，这里就存放一些文件。</p>
</li>
<li><p><code>/tmp</code>：这个目录是用来存放一些临时文件的。</p>
</li>
</ul>
<p><strong>账户：</strong></p>
<ul>
<li><p><code>/root</code>：系统管理员的用户主目录。</p>
</li>
<li><p><code>/home</code>：用户的主目录，以用户的账号命名的。</p>
</li>
<li><p><code>/usr</code>： usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p>
</li>
<li><p><code>/usr/bin</code>：系统用户使用的应用程序与指令。</p>
</li>
<li><p><code>/usr/sbin</code>：超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p><code>/usr/src</code>：内核源代码默认的放置目录。</p>
</li>
</ul>
<p><strong>运行过程中要用：</strong></p>
<ul>
<li><p><code>/var</code>：存放经常修改的数据，比如程序运行的日志文件（&#x2F;var&#x2F;log 目录下）。</p>
</li>
<li><p><code>/proc</code>：管理<strong>内存空间！</strong>虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</p>
</li>
</ul>
<p><strong>扩展用的：</strong></p>
<ul>
<li><p><code>/opt</code>：默认是空的，我们安装额外软件可以放在这个里面。</p>
</li>
<li><p><code>/srv</code>：存放服务启动后需要提取的数据<strong>（不用服务器就是空）</strong></p>
</li>
</ul>
<h1 id="Linux-文件基本属性"><a href="#Linux-文件基本属性" class="headerlink" title="Linux 文件基本属性"></a>Linux 文件基本属性</h1><p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。</p>
<p>为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p>
<p>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p>
<ul>
<li><code>chown</code> (change owner) ： 修改所属用户与组。</li>
<li><code>chmod</code> (change mode) ： 修改用户的权限。</li>
</ul>
<p>在 Linux 中我们可以使用 <code>ll</code> 或者 <code>ls –l</code> 命令来显示一个文件的属性以及文件所属的用户和组，如：</p>
<pre><code class="shell">root@LAPTOP-G8CK4FEN:/# ll
total 1480
drwxr-xr-x  19 root root    4096 Mar  9 08:01 ./
drwxr-xr-x  19 root root    4096 Mar  9 08:01 ../
lrwxrwxrwx   1 root root       7 Apr 23  2020 bin -&gt; usr/bin/
drwxr-xr-x   2 root root    4096 Apr 23  2020 boot/
</code></pre>
<p>实例中，<strong>boot</strong> 文件的第一个属性用 <strong>d</strong> 表示。<strong>d</strong> 在 Linux 中代表该文件是一个目录文件。</p>
<p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p>
<ul>
<li>当为 <strong>d</strong> 则是目录</li>
<li>当为 <strong>-</strong> 则是文件；</li>
<li>若是 <strong>l</strong> 则表示为链接文档(link file)；</li>
<li>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li>
<li>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li>
</ul>
<p>接下来的字符中，以三个为一组，且均为 <strong>rwx</strong> 的三个参数的组合。其中， <strong>r</strong> 代表可读(read)、 <strong>w</strong> 代表可写(write)、 <strong>x</strong> 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 <strong>-</strong> 而已。</p>
<p><img src="/file-llls22.jpg" alt="img"></p>
<p><img src="/363003_1227493859FdXT.png" alt="363003_1227493859FdXT"></p>
<p>从左至右用 <strong>0-9</strong> 这些数字来表示。</p>
<p>第 <strong>0</strong> 位确定文件类型，第 <strong>1-3</strong> 位确定属主（该文件的所有者）拥有该文件的权限。</p>
<p>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p>
<p>其中，第 <strong>1、4、7</strong> 位表示读权限，如果用 <strong>r</strong> 字符表示，则有读权限，如果用 <strong>-</strong> 字符表示，则没有读权限；第 <strong>2、5、8</strong> 位表示写权限，如果用 <strong>w</strong> 字符表示，则有写权限，如果用 <strong>-</strong> 字符表示没有写权限；第 <strong>3、6、9</strong> 位表示可执行权限，如果用 <strong>x</strong> 字符表示，则有执行权限，如果用 <strong>-</strong> 字符表示，则没有执行权限。</p>
<h1 id="Linux-文件与目录管理"><a href="#Linux-文件与目录管理" class="headerlink" title="Linux 文件与目录管理"></a>Linux 文件与目录管理</h1><p>我们知道 Linux 的目录结构为树状结构，最顶级的目录为根目录 **&#x2F;**。</p>
<p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p>
<ul>
<li><strong>绝对路径：</strong><br>路径的写法，由根目录 <strong>&#x2F;</strong> 写起，例如：<code>/usr/share/doc</code> 这个目录。</li>
<li><strong>相对路径：</strong><br>  路径的写法，不是由 <strong>&#x2F;</strong> 写起，例如由 <code>/usr/share/doc</code> 要到 <code>/usr/share/man</code> 底下时，可以写成： <code>cd ../man</code> 这就是相对路径的写法。</li>
</ul>
<p><strong>“&#x2F;”在系统文件中表示绝对路径；</strong></p>
<p>“&#x2F;”处于Linux文件系统<strong>树形结构</strong>的最顶端，我们称它为Linux文件系统的root，<strong>它是Linux文件系统的入口</strong>；<br>所有的目录、文件、设备都在“&#x2F;”之下，它是Linux文件系统最顶层的唯一的目录；<br>一般建议在根目录下面只有目录，不要直接存放文件；<br>根目录是linux系统启动时系统第一个载入的分区，所以启动过程中用到的文件应该都放在这个分区中；<br>其中<code>/etc</code>、<code>/bin</code>、<code>/dev</code>、<code>/lib</code>、<code>/sbin</code>这5个子目录都应该要与根目录连在一起，不可独立成为某个分区。</p>
<p><strong>“.&#x2F;” 代表的意思是：</strong> .&#x2F; 代表当前文件目录，某一个文件（或者目录）的查找路径是从当前目录“.”下面开始进行查找。</p>
<p><strong>“~” 代表的意思是：</strong>表示代码主目录，也就是当前登录用户的用户目录。</p>
<p><strong>“..” 代表的意思是：</strong>“..”表示上级目录</p>
<h2 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h2><ul>
<li><code>ls</code>（英文全拼：list files）: 列出目录及文件名</li>
<li><code>cd</code>（英文全拼：change directory）：切换目录</li>
<li><code>pwd</code>（英文全拼：print work directory）：显示目前的目录</li>
<li><code>mkdir</code>（英文全拼：make directory）：创建一个新的目录</li>
<li><code>rmdir</code>（英文全拼：remove directory）：删除一个空的目录</li>
<li><code>cp</code>（英文全拼：copy file）: 复制文件或目录</li>
<li><code>rm</code>（英文全拼：remove）: 删除文件或目录</li>
<li><code>mv</code>（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p>可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p>
<h3 id="ls-列出目录"><a href="#ls-列出目录" class="headerlink" title="ls (列出目录)"></a>ls (列出目录)</h3><p>在Linux系统当中， ls 命令可能是最常被运行的。</p>
<p>选项与参数：</p>
<ul>
<li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li>
<li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li>
<li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li>
</ul>
<h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd (切换目录)"></a>cd (切换目录)</h3><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p>
<p>语法：</p>
<pre><code class="shell">cd [相对路径或绝对路径]
</code></pre>
<pre><code class="shell">#使用 mkdir 命令创建 runoob 目录
[root@www ~]# mkdir runoob

#使用绝对路径切换到 runoob 目录
[root@www ~]# cd /root/runoob/

#使用相对路径切换到 runoob 目录
[root@www ~]# cd ./runoob/

# 表示回到自己的家目录，亦即是 /root 这个目录
[root@www runoob]# cd ~

# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；
[root@www ~]# cd ..
</code></pre>
<h3 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd (显示目前所在的目录)"></a>pwd (显示目前所在的目录)</h3><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p>
<pre><code class="shell">[root@www ~]# pwd [-P]
</code></pre>
<p>选项与参数：</p>
<ul>
<li><strong>-P</strong> ：显示出确实的路径，而非使用链接 (link) 路径。</li>
</ul>
<h3 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir (创建新目录)"></a>mkdir (创建新目录)</h3><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p>
<p>语法：</p>
<pre><code class="shell">mkdir [-mp] 目录名称
</code></pre>
<p>选项与参数：</p>
<ul>
<li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li>
<li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li>
</ul>
<p>实例：请到&#x2F;tmp底下尝试创建数个新目录看看：</p>
<pre><code class="shell">[root@www ~]# cd /tmp
[root@www tmp]# mkdir test    &lt;==创建一名为 test 的新目录
[root@www tmp]# mkdir test1/test2/test3/test4
mkdir: cannot create directory `test1/test2/test3/test4&#39;: 
No such file or directory       &lt;== 没办法直接创建此目录啊！
[root@www tmp]# mkdir -p test1/test2/test3/test4
</code></pre>
<h3 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir (删除空的目录)"></a>rmdir (删除空的目录)</h3><p>语法：</p>
<pre><code class="shell"> rmdir [-p] 目录名称
</code></pre>
<p>选项与参数：</p>
<ul>
<li><strong>-p ：</strong>从该目录起，一次删除多级空目录</li>
</ul>
<p>删除 runoob 目录</p>
<pre><code>[root@www tmp]# rmdir runoob/
</code></pre>
<p>将 mkdir 实例中创建的目录(&#x2F;tmp 底下)删除掉！</p>
<pre><code class="shell">[root@www tmp]# ls -l   &lt;==看看有多少目录存在？
drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test
drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
[root@www tmp]# rmdir test   &lt;==可直接删除掉，没问题
[root@www tmp]# rmdir test1  &lt;==因为尚有内容，所以无法删除！
rmdir: `test1&#39;: Directory not empty
[root@www tmp]# rmdir -p test1/test2/test3/test4
[root@www tmp]# ls -l        &lt;==您看看，底下的输出中test与test1不见了！
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
</code></pre>
<p>利用 -p 这个选项，立刻就可以将 test1&#x2F;test2&#x2F;test3&#x2F;test4 一次删除。</p>
<p>不过要注意的是，这个 <strong>rmdir 仅能删除空的目录</strong>，你可以使用 <strong>rm 命令来删除非空目录</strong>。</p>
<h3 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp (复制文件或目录)"></a>cp (复制文件或目录)</h3><p>cp 即拷贝文件和目录。</p>
<p>语法:</p>
<pre><code class="shell">[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)
[root@www ~]# cp [options] source1 source2 source3 .... directory
</code></pre>
<p>选项与参数：</p>
<ul>
<li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li>
<li><strong>-d：</strong>若来源档为链接档的属性(link file)，则复制链接档属性而非文件本身；</li>
<li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li>
<li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li>
<li><strong>-l：</strong>进行硬式链接(hard link)的链接档创建，而非复制文件本身；</li>
<li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li>
<li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li>
<li><strong>-s：</strong>复制成为符号链接档 (symbolic link)，亦即『捷径』文件；</li>
<li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li>
</ul>
<p>用 root 身份，将 root 目录下的 .bashrc 复制到 &#x2F;tmp 下，并命名为 bashrc</p>
<pre><code class="shell">[root@www ~]# cp ~/.bashrc /tmp/bashrc
[root@www ~]# cp -i ~/.bashrc /tmp/bashrc
cp: overwrite `/tmp/bashrc&#39;? n  &lt;==n不覆盖，y为覆盖
</code></pre>
<h3 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm (移除文件或目录)"></a>rm (移除文件或目录)</h3><p>语法：</p>
<pre><code class="shell"> rm [-fir] 文件或目录
</code></pre>
<p>选项与参数：</p>
<ul>
<li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li>
<li>-i ：互动模式，在删除前会询问使用者是否动作</li>
<li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
</ul>
<p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p>
<pre><code class="shell">[root@www tmp]# rm -i bashrc
rm: remove regular file `bashrc&#39;? y
</code></pre>
<p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p>
<h3 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv (移动文件与目录，或修改名称)"></a>mv (移动文件与目录，或修改名称)</h3><p>语法：</p>
<pre><code class="shell">[root@www ~]# mv [-fiu] source destination
[root@www ~]# mv [options] source1 source2 source3 .... directory
</code></pre>
<p>选项与参数：</p>
<ul>
<li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li>
<li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li>
</ul>
<p>复制一文件，创建一目录，将文件移动到目录中</p>
<pre><code class="shell">[root@www ~]# cd /tmp
[root@www tmp]# cp ~/.bashrc bashrc
[root@www tmp]# mkdir mvtest
[root@www tmp]# mv bashrc mvtest
</code></pre>
<p>将某个文件移动到某个目录去，就是这样做！</p>
<p>将刚刚的目录名称更名为 mvtest2</p>
<pre><code class="shell">[root@www tmp]# mv mvtest mvtest2
</code></pre>
<h2 id="Linux-文件内容查看"><a href="#Linux-文件内容查看" class="headerlink" title="Linux 文件内容查看"></a>Linux 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容：</p>
<ul>
<li><code>cat</code> 由第一行开始显示文件内容</li>
<li><code>tac</code> 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>
<li><code>nl</code>  显示的时候，顺道输出行号！</li>
<li><code>more</code> 一页一页的显示文件内容</li>
<li><code>less</code> 与 <code>more</code> 类似，但是比 more 更好的是，他可以往前翻页！</li>
<li><code>head</code> 只看头几行</li>
<li><code>tail</code> 只看尾巴几行</li>
</ul>
<p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>由第一行开始显示文件内容</p>
<p>语法：</p>
<pre><code class="shell">cat [-AbEnTv]
</code></pre>
<p>选项与参数：</p>
<ul>
<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li>-E ：将结尾的断行字节 $ 显示出来；</li>
<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>
<li>-v ：列出一些看不出来的特殊字符</li>
</ul>
<p>检看 &#x2F;etc&#x2F;issue 这个文件的内容：</p>
<pre><code class="shell">[root@www ~]# cat /etc/issue
CentOS release 6.4 (Final)
Kernel \r on an \m
</code></pre>
<h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>
<pre><code class="shell">[root@www ~]# tac /etc/issue

Kernel \r on an \m
CentOS release 6.4 (Final)
</code></pre>
<h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><p>显示行号</p>
<p>语法：</p>
<pre><code class="shell">nl [-bnw] 文件
</code></pre>
<p>选项与参数：</p>
<ul>
<li>-b ：指定行号指定的方式，主要有两种：<br>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li>
<li>-n ：列出行号表示的方法，主要有三种：<br>-n ln ：行号在荧幕的最左方显示；<br>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li>
<li>-w ：行号栏位的占用的位数。</li>
</ul>
<p>实例一：用 nl 列出 &#x2F;etc&#x2F;issue 的内容</p>
<pre><code class="shell">[root@www ~]# nl /etc/issue
     1  CentOS release 6.4 (Final)
     2  Kernel \r on an \m
</code></pre>
<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>一页一页翻动</p>
<pre><code class="shell">[root@www ~]# more /etc/man_db.config 
#
# Generated automatically from man.conf.in by the
# configure script.
#
# man.conf from man-1.6d
....(中间省略)....
--More--(28%)  &lt;== 重点在这一行喔！你的光标也会在这里等待你的命令
</code></pre>
<p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>
<ul>
<li>空白键 (space)：代表向下翻一页；</li>
<li>Enter     ：代表向下翻『一行』；</li>
<li>&#x2F;字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>
<li>:f      ：立刻显示出档名以及目前显示的行数；</li>
<li>q      ：代表立刻离开 more ，不再显示该文件内容。</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>一页一页翻动，以下实例输出&#x2F;etc&#x2F;man.config文件的内容：</p>
<pre><code>[root@www ~]# less /etc/man.config
#
# Generated automatically from man.conf.in by the
# configure script.
#
# man.conf from man-1.6d
....(中间省略)....
:   &lt;== 这里可以等待你输入命令！
</code></pre>
<p>less运行时可以输入的命令有：</p>
<ul>
<li>空白键  ：向下翻动一页；</li>
<li>[pagedown]：向下翻动一页；</li>
<li>[pageup] ：向上翻动一页；</li>
<li>&#x2F;字串   ：向下搜寻『字串』的功能；</li>
<li>?字串   ：向上搜寻『字串』的功能；</li>
<li>n     ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li>
<li>N     ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li>
<li>q     ：离开 less 这个程序；</li>
</ul>
<h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>取出文件前面几行</p>
<p>语法：</p>
<pre><code class="shell">head [-n number] 文件 
</code></pre>
<p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
</ul>
<pre><code class="shell">[root@www ~]# head /etc/man.config
</code></pre>
<p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p>
<pre><code class="shell">[root@www ~]# head -n 20 /etc/man.config
</code></pre>
<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>取出文件后面几行</p>
<p>语法：</p>
<pre><code class="shell">tail [-n number] 文件 
</code></pre>
<p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
<li>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</li>
</ul>
<pre><code class="shell">[root@www ~]# tail /etc/man.config
# 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：
[root@www ~]# tail -n 20 /etc/man.config
</code></pre>
<h1 id="Linux-链接概念"><a href="#Linux-链接概念" class="headerlink" title="Linux 链接概念"></a>Linux 链接概念</h1><p>Linux 链接分两种，一种被称为<strong>硬链接（Hard Link）</strong>，另一种被称为<strong>符号链接（Symbolic Link）</strong>。默认情况下，<strong>ln</strong> 命令产生硬链接。</p>
<h2 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a>硬连接</h2><p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p>
<p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>
<h2 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h2><p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p>
<p><strong>通过实验加深理解</strong></p>
<pre><code>[oracle@Linux]$ touch f1          #创建一个测试文件f1
[oracle@Linux]$ ln f1 f2          #创建f1的一个硬连接文件f2
[oracle@Linux]$ ln -s f1 f3       #创建f1的一个符号连接文件f3
[oracle@Linux]$ ls -li            # -i参数显示文件的inode节点信息
total 0
9797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f1
9797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f2
9797649 lrwxrwxrwx  1 oracle oinstall 2 Apr 21 08:11 f3 -&gt; f1
</code></pre>
<p>从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 9797648，然而符号连接文件的 inode 节点不同。</p>
<pre><code>[oracle@Linux]$ echo &quot;I am f1 file&quot; &gt;&gt;f1
[oracle@Linux]$ cat f1
I am f1 file
[oracle@Linux]$ cat f2
I am f1 file
[oracle@Linux]$ cat f3
I am f1 file
[oracle@Linux]$ rm -f f1
[oracle@Linux]$ cat f2
I am f1 file
[oracle@Linux]$ cat f3
cat: f3: No such file or directory
</code></pre>
<p>通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f3 文件无效</p>
<p><strong>总结</strong></p>
<p>依此您可以做一些相关的测试，可以得到以下全部结论：</p>
<ul>
<li>1).删除符号连接f3,对f1,f2无影响；</li>
<li>2).删除硬连接f2，对f1,f3也无影响；</li>
<li>3).删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</li>
<li>4).同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</li>
</ul>
<h1 id="Linux-用户和用户组管理"><a href="#Linux-用户和用户组管理" class="headerlink" title="Linux 用户和用户组管理"></a>Linux 用户和用户组管理</h1><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>
<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p>
<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>
<ul>
<li>用户账号的添加、删除与修改。</li>
<li>用户口令的管理。</li>
<li>用户组的管理。</li>
</ul>
<h1 id="Linux-磁盘管理"><a href="#Linux-磁盘管理" class="headerlink" title="Linux 磁盘管理"></a>Linux 磁盘管理</h1><p>Linux 磁盘管理好坏直接关系到整个系统的性能问题。</p>
<p>Linux 磁盘管理常用三个命令为 <code>df</code>、<code>du</code> 和 <code>fdisk</code>。</p>
<ul>
<li><code>df</code>（英文全称：disk free）：列出文件系统的整体磁盘使用量</li>
<li><code>du</code>（英文全称：disk used）：检查磁盘空间使用量</li>
<li><code>fdisk</code>：用于磁盘分区</li>
</ul>
<h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<p>语法：</p>
<pre><code class="shell">df [-ahikHTm] [目录或文件名]
</code></pre>
<p>选项与参数：</p>
<ul>
<li><code>-a</code> ：列出所有的文件系统，包括系统特有的 &#x2F;proc 等文件系统；</li>
<li><code>-k</code> ：以 KBytes 的容量显示各文件系统；</li>
<li><code>-m</code> ：以 MBytes 的容量显示各文件系统；</li>
<li><code>-h</code> ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li>
<li><code>-H</code> ：以 M&#x3D;1000K 取代 M&#x3D;1024K 的进位方式；</li>
<li><code>-T</code> ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li>
<li><code>-i</code> ：不用硬盘容量，而以 inode 的数量来显示</li>
</ul>
<h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p>Linux du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍 Linux du 命令。</p>
<p>语法：</p>
<pre><code>du [-ahskm] 文件或目录名称
</code></pre>
<p>选项与参数：</p>
<ul>
<li><code>-a</code> ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li>
<li><code>-h</code> ：以人们较易读的容量格式 (G&#x2F;M) 显示；</li>
<li><code>-s</code> ：列出总量而已，而不列出每个各别的目录占用容量；</li>
<li><code>-S</code> ：不包括子目录下的总计，与 -s 有点差别。</li>
<li><code>-k</code> ：以 KBytes 列出容量显示；</li>
<li><code>-m</code> ：以 MBytes 列出容量显示；</li>
</ul>
<h2 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h2><p>fdisk 是 Linux 的磁盘分区表操作工具。</p>
<p>语法：</p>
<pre><code class="shell">fdisk [-l] 装置名称
</code></pre>
<p>选项与参数：</p>
<ul>
<li><code>-l</code> ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。</li>
</ul>
<h1 id="Linux-vi-x2F-vim"><a href="#Linux-vi-x2F-vim" class="headerlink" title="Linux vi&#x2F;vim"></a>Linux vi&#x2F;vim</h1><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p>
<p>但是目前我们使用比较多的是 vim 编辑器。</p>
<p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p>
<h2 id="什么是-vim？"><a href="#什么是-vim？" class="headerlink" title="什么是 vim？"></a>什么是 vim？</h2><p>Vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>
<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p>
<p>连 vim 的官方网站 (<a target="_blank" rel="noopener" href="https://www.vim.org/">https://www.vim.org/</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p>
<p><img src="/vi-vim-cheat-sheet-sch.gif" alt="img"></p>
<h2 id="vi-x2F-vim-的使用"><a href="#vi-x2F-vim-的使用" class="headerlink" title="vi&#x2F;vim 的使用"></a>vi&#x2F;vim 的使用</h2><p>基本上 vi&#x2F;vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是：</p>
<h3 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h3><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p>
<p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p>
<p>以下是常用的几个命令：</p>
<ul>
<li><code>i</code> 切换到输入模式，以输入字符。</li>
<li><code>x</code> 删除当前光标所在处的字符。</li>
<li><code>:</code> 切换到底线命令模式，以在最底一行输入命令。</li>
</ul>
<p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p>
<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>
<h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><p>在命令模式下按下i就进入了输入模式。</p>
<p>在输入模式中，可以使用以下按键：</p>
<ul>
<li><strong>字符按键以及Shift组合</strong>，输入字符</li>
<li><strong>ENTER</strong>，回车键，换行</li>
<li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li>
<li><strong>DEL</strong>，删除键，删除光标后一个字符</li>
<li><strong>方向键</strong>，在文本中移动光标</li>
<li><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</li>
<li><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</li>
<li><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</li>
<li><strong>ESC</strong>，退出输入模式，切换到命令模式</li>
</ul>
<h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li><code>q</code> 退出程序</li>
<li><code>w</code> 保存文件</li>
</ul>
<p>按ESC键可随时退出底线命令模式。</p>
<p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>
<p><img src="/vim-vi-workmodel.png" alt="img"></p>
<h2 id="vi-x2F-vim-使用实例"><a href="#vi-x2F-vim-使用实例" class="headerlink" title="vi&#x2F;vim 使用实例"></a>vi&#x2F;vim 使用实例</h2><p><strong>使用 vi&#x2F;vim 进入一般模式</strong></p>
<p>如果你想要使用 vi 来建立一个名为 runoob.txt 的文件时，你可以这样做：</p>
<pre><code class="shell">$ vim runoob.txt
</code></pre>
<p>直接输入 <strong>vi 文件名</strong> 就能够进入 vi 的一般模式了。请注意，记得 <strong>vi 后面一定要加文件名，不管该文件存在与否！</strong></p>
<p><img src="/078207F0-B204-4464-AAEF-982F45EDDAE9.jpg" alt="img"></p>
<p><strong>按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</strong></p>
<p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p>
<p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p>
<p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p>
<p><img src="/1C928383-471E-4AF1-A61E-9E2CCBD5A913.jpg" alt="img"></p>
<p><strong>按下 ESC 按钮回到一般模式</strong></p>
<p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p>
<p><strong>在一般模式中按下 :wq 储存后离开 vi</strong></p>
<p>OK，我们要存档了，存盘并离开的指令很简单，输入 <code>:wq</code> 即可保存离开！</p>
<p><img src="/B2FB5146-327C-4019-AC96-DD7A8EE7460C.jpg" alt="img"></p>
<p>OK! 这样我们就成功创建了一个 runoob.txt 的文件。</p>
<h1 id="Linux-yum-命令"><a href="#Linux-yum-命令" class="headerlink" title="Linux yum 命令"></a>Linux yum 命令</h1><p><code>yum</code>（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。</p>
<p>基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p>
<p><code>yum</code> 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
<h1 id="Linux-apt-命令"><a href="#Linux-apt-命令" class="headerlink" title="Linux apt 命令"></a>Linux apt 命令</h1><p><code>apt</code>（Advanced Packaging Tool）是一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。</p>
<p><code>apt</code> 命令提供了查找、安装、升级、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
<p><code>apt</code> 命令执行需要超级管理员权限(root)。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Linux/" style="color: #00bcd4">
                Linux
            </a>
        </span>
        
    </div>
    <a href="/2023/03/06/Linux/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/03/05/C++%E9%9D%A2%E7%BB%8F/">
        <h2 class="post-title">C++面经</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/C/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                C++
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/5
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="1-编译内存相关"><a href="#1-编译内存相关" class="headerlink" title="1.编译内存相关"></a>1.编译内存相关</h1><h2 id="1-1-C-程序编译过程"><a href="#1-1-C-程序编译过程" class="headerlink" title="1.1. C++ 程序编译过程"></a>1.1. C++ 程序编译过程</h2><p>编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接。</p>
<p><strong>编译预处理</strong>：处理以 # 开头的指令，产生 .i 文件；<br>主要的处理操作如下：</p>
<ul>
<li>对全部的#define进行宏展开。</li>
<li>处理全部的条件编译指令，比方#if、#ifdef、#elif、#else、#endif;</li>
<li>处理 #include 指令，这个过程是递归的，也就是说被包括的文件可能还包括其它文件;</li>
<li>删除全部的注释 &#x2F;&#x2F; 和 &#x2F;**&#x2F;</li>
<li>加入行号和文件标识</li>
<li>保留全部的 #pragma 编译器指令</li>
</ul>
<p>ps:经过预处理后的 .i 文件不包括任何宏定义，由于全部的宏已经被展开。而且包括的文件也已经被插入到 .i 文件里。</p>
<p><strong>编译、优化</strong>：将源码 .cpp 文件翻译成 .s 汇编代码；</p>
<ul>
<li>词法分析：将源代码的字符序列分割成一系列的记号。</li>
<li>语法分析：对记号进行语法分析，产生语法树。</li>
<li>语义分析：判断表达式是否有意义。</li>
<li>代码优化：</li>
<li>目标代码生成：生成汇编代码。</li>
<li>目标代码优化：</li>
</ul>
<p>编译会将源代码由文本形式转换成机器语言，编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件。编译后的.s是ASCII码文件。</p>
<p><strong>汇编</strong>：将汇编代码 .s 翻译成机器指令的 .o 或.obj 目标文件；</p>
<ul>
<li><p>汇编过程调用汇编器AS来完成，是用于将汇编代码转换成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。</p>
</li>
<li><p>汇编后的.o文件是纯二进制文件。</p>
</li>
</ul>
<p><strong>链接</strong>：产生 .out 或 .exe 可运行文件</p>
<ul>
<li>汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe文件。</li>
</ul>
<p>详细来说，链接是将所有的.o文件和库（动态库、静态库）链接在一起，得到可以运行的可执行文件（Windows的.exe文件或Linux的.out文件）等。它的工作就是把一些指令对其他符号地址的引用加以修正。链接过程主要包括了地址和空间分配、符号决议和重定向。</p>
<p>*最基本的链接叫做静态链接，就是将每个模块的源代码文件编译、汇编成目标文件（Linux：.o 文件；Windows：.obj文件），然后将目标文件和库一起链接形成最后的可执行文件（.exe或.out等）。库其实就是一组目标文件的包，就是一些最常用的代码变异成目标文件后打包存放。最常见的库就是运行时库，它是支持程序运行的基本函数的集合。<br>                                      <img src="b70048db13024888936d51524f0fde9d.png" alt="b70048db13024888936d51524f0fde9d.png" style="zoom:33%;" /></p>
<p>链接分为两种：</p>
<p><strong>静态链接</strong>：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</p>
<p>把目标程序运行时需要调用的函数代码直接链接到了生成的可执行文件中，程序在运行的时候不需要其他额外的库文件，且就算你去静态库把程序执行需要的库删掉也不会影响程序的运行，因为所需要的所有东西已经被链接到了链接阶段生成的可执行文件中。</p>
<p>Windows下以.lib为后缀，Linux下以.a为后缀。</p>
<p><strong>动态链接</strong>：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</p>
<p>动态 “动” 在了程序在执行阶段需要去寻找相应的函数代码，即在程序运行时才会将程序安装模块链接在一起</p>
<p>具体来说，动态链接就是把调⽤的函数所在⽂件模块（DLL）和调⽤函数在⽂件中的位置等信息链接进目标程序，程序运⾏的时候再从DLL中寻找相应函数代码，因此需要相应DLL⽂件的⽀持 。（Windows）</p>
<p>包含函数重定位信息的文件，在Windows下以.dll为后缀，Linux下以.so为后缀。</p>
<p><strong>二者的区别</strong>：</p>
<ul>
<li>静态链接是将各个模块的obj和库链接成一个完整的可执行程序；</li>
<li>动态链接是程序在运行的时候寻找动态库的函数符号（重定位），即<strong>DLL（Dynamic Link Library）</strong>不必被包含在最终的exe文件中；</li>
<li><strong>链接使用工具不同</strong>:<ul>
<li>静态链接由称为“链接器”的工具完成；</li>
<li>动态链接由操作系统在程序运行时完成链接；</li>
</ul>
</li>
<li><strong>库包含限制</strong>：<ul>
<li>静态链接库中不能再包含其他的动态链接库或者静态库；</li>
<li>动态链接库中还可以再包含其他的动态或静态链接库。</li>
</ul>
</li>
<li><strong>运行速度</strong>：<ul>
<li>静态链接运行速度快（因为执行过程中不用重定位），可独立运行</li>
<li>动态链接运行速度慢、不可独立运行</li>
</ul>
</li>
</ul>
<p><strong>二者的优缺点</strong>：</p>
<ul>
<li><p>静态链接：</p>
<ul>
<li>缺点：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；</li>
<li>优点：执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</li>
</ul>
</li>
<li><p>动态链接：</p>
<ul>
<li>优点：节省内存、更新方便；</li>
<li>缺点：但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。</li>
</ul>
</li>
</ul>
<h2 id="1-2-C-内存管理"><a href="#1-2-C-内存管理" class="headerlink" title="1.2. C++ 内存管理"></a>1.2. C++ 内存管理</h2><p>C++的内存分布模型：</p>
<p><img src="/d11da6f90fba4a9f9cd935ee80d62a8c.png" alt="img"></p>
<p>从高地址到低地址，一个程序由内核空间、栈区、堆区、BSS段、数据段（data）、代码区组成。</p>
<p>（Block Started by Symbol通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。特点是:可读写的，在程序执行之前BSS段会自动清0，所以，未初始的全局变量在程序执行之前已经成0了。）</p>
<p><strong>常说的C++ 内存分区：栈、堆、全局&#x2F;静态存储区、常量存储区、代码区。</strong></p>
<p>可执行程序在运行时会多出两个区域：</p>
<ul>
<li>栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。栈从高地址向低地址增长。是一块连续的空间。栈一般分配几M大小的内存。</li>
<li>堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。堆从低地址向高地址增长。一般可以分配几个G大小的内存。</li>
<li>在堆栈之间有一个 共享区（文件映射区）。</li>
<li>全局区&#x2F;静态存储区（.BSS 段和 .data 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，程序中未初始化的全局变量和静态变量存放在.BSS 段中，已初始化的全局变量和静态变量存放在 .data 段中，C++ 中不再区分了。</li>
<li>常量存储区（.data 段）：存放的是常量，不允许修改，程序运行结束自动释放。</li>
<li>代码区（.text 段）：存放程序执行代码的一块内存区域。只读，不允许修改，但可以执行。编译后的二进制文件存放在这里。代码段的头部还会包含一些只读的常量，如字符串常量字面值（注意：const变量虽然属于常量，但是本质还是变量，不存储于代码段）</li>
</ul>
<p>在linux下size命令可以查看一个可执行二进制文件基本情况：<br><img src="/8292ae6c07774a2293dda6e7ff301107.png" alt="img"></p>
<h2 id="1-3-栈和堆的区别"><a href="#1-3-栈和堆的区别" class="headerlink" title="1.3. 栈和堆的区别"></a>1.3. 栈和堆的区别</h2><ul>
<li><p>申请方式：栈是系统自动分配，堆是程序员主动申请。</p>
</li>
<li><p>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。</p>
</li>
<li><p>栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。</p>
</li>
<li><p>申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。</p>
</li>
<li><p>存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。</p>
</li>
</ul>
<p>此题总结：</p>
<ol>
<li>申请方式的不同。 栈由系统自动分配，而堆是人为申请开辟;</li>
<li>申请大小的不同。 栈获得的空间较小，而堆获得的空间较大;</li>
<li>申请效率的不同。 栈由系统自动分配，速度较快，而堆一般速度比较慢;</li>
<li>存储的内容不同。栈在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</li>
</ol>
<h2 id="1-4-变量的区别"><a href="#1-4-变量的区别" class="headerlink" title="1.4. 变量的区别"></a>1.4. 变量的区别</h2><p><strong>全局变量</strong>、<strong>局部变量</strong>、<strong>静态全局变量</strong>、<strong>静态局部变量</strong>的区别：</p>
<ul>
<li>全局变量就是定义在函数外的变量。</li>
<li>局部变量就是函数内定义的变量。</li>
<li>静态变量就是加了static的变量。 例如：static int value &#x3D; 1</li>
</ul>
<p><strong>各自存储的位置</strong>：</p>
<ul>
<li><p>全局变量，存储在常量区（静态存储区）。</p>
</li>
<li><p>局部变量，存储在栈区。</p>
</li>
<li><p>静态变量，存储在常量区（静态存储区）。</p>
<p>因为静态变量都在静态存储区（常量区），所以下次调用函数的时候还是能取到原来的值。</p>
</li>
</ul>
<p><strong>各自初始化的值</strong>：</p>
<ul>
<li>局部变量, 存储在栈区。局部变量一般是不初始化的。</li>
<li>全局变量和静态变量，都是初始化为0的，有一个初始值。</li>
<li>如果是类变量，会调用默认构造函数初始化。</li>
</ul>
<p><strong>从作用域看</strong>：</p>
<p>C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：</p>
<p><strong>全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。</strong></p>
<ul>
<li><p>全局变量：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。会一直存在到程序结束。</p>
</li>
<li><p>静态全局变量：全局作用域+文件作用域，所以无法在其他文件中使用。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</p>
</li>
<li><p>局部变量：具有局部作用域。比如函数的参数，函数内的局部变量等等；它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被销毁，其所占用的内存也被收回。<br>静态局部变量：具有局部作用域。它只被初始化一次， 直到程序结束。自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。</p>
</li>
</ul>
<p><strong>从分配内存空间看</strong>：</p>
<ul>
<li><strong>静态存储区</strong>：全局变量，静态局部变量，静态全局变量。</li>
<li><strong>栈</strong>：局部变量。</li>
</ul>
<p><strong>各自的应用场景</strong>：</p>
<ul>
<li>局部变量就是我们经常用的，进入函数，逐个构造，最后统一销毁。</li>
<li>全局变量主要是用来给不同的文件之间进行通信。</li>
<li>静态变量：只在本文件中使用，局部静态变量在函数内起作用，可以作为一个计数器。</li>
</ul>
<p>例子：</p>
<pre><code class="cpp">   void func()&#123;
     static int count;
     count ++;
   &#125;
   int main(int argc, char** argv)&#123;
     for(int i = 0; i &lt; 10; i++)
       func();
   &#125;
</code></pre>
<p><strong>说说静态变量在代码执行的什么阶段进行初始化？</strong></p>
<pre><code class="cpp">static int value  //静态变量初始化语句
</code></pre>
<p>对于C语言： 静态变量和全局变量均在编译期进行初始化，即初始化发生在任何代码执行之前。<br>对于C++： 静态变量和全局变量仅当首次被使用的时候才进行初始化。</p>
<p>助记： 如果你使用过C&#x2F;C++你会发现，C语言要求在程序的最开头声明全部的变量，而C++则可以随时使用随时声明；这个规律是不是和答案类似呢？</p>
<h2 id="1-5-全局变量定义在头文件中有什么问题？"><a href="#1-5-全局变量定义在头文件中有什么问题？" class="headerlink" title="1.5. 全局变量定义在头文件中有什么问题？"></a>1.5. 全局变量定义在头文件中有什么问题？</h2><p>如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。</p>
<h2 id="1-6-内存对齐"><a href="#1-6-内存对齐" class="headerlink" title="1.6. 内存对齐"></a>1.6. 内存对齐</h2><p>什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？</p>
<p><strong>内存对齐</strong>：编译器将程序中的每个“数据单元”安排在字的整数倍的地址指向的内存之中</p>
<p><strong>内存对齐的原则</strong>：</p>
<ul>
<li><p>结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；</p>
</li>
<li><p>结构体每个成员相对于结构体首地址的偏移量 （offset）都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）；</p>
</li>
<li><p>结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。</p>
</li>
</ul>
<p><strong>进行内存对齐的原因</strong>：（主要是硬件设备方面的问题）</p>
<ul>
<li>某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常；</li>
<li>某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作；</li>
<li>相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间；</li>
<li>某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignmenttrap）；</li>
<li>某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。</li>
</ul>
<p><strong>内存对齐的优点</strong>：</p>
<ul>
<li>便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；</li>
<li>提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取。</li>
</ul>
<h2 id="1-7-什么是内存泄露"><a href="#1-7-什么是内存泄露" class="headerlink" title="1.7. 什么是内存泄露"></a>1.7. 什么是内存泄露</h2><p><strong>内存泄漏</strong>：由于疏忽或错误导致的程序未能释放已经不再使用的内存。</p>
<p>进一步解释：</p>
<ul>
<li>并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。</li>
<li>常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。</li>
<li>使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete释放内存，否则这块内存就会造成内存泄漏。</li>
<li>指针重新赋值</li>
</ul>
<pre><code class="cpp">char *p = (char *)malloc(10);
char *p1 = (char *)malloc(10);
p = np;
</code></pre>
<p>开始时，指针 p 和 p1 分别指向一块内存空间，但指针 p 被重新赋值，导致 p 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。</p>
<h2 id="1-8-怎么防止内存泄漏？内存泄漏检测工具的原理？"><a href="#1-8-怎么防止内存泄漏？内存泄漏检测工具的原理？" class="headerlink" title="1.8. 怎么防止内存泄漏？内存泄漏检测工具的原理？"></a>1.8. 怎么防止内存泄漏？内存泄漏检测工具的原理？</h2><p><strong>防止内存泄漏的方法</strong>：</p>
<ul>
<li>内部封装：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。（说明：但这样做并不是最佳的做法，在类的对象复制时，程序会出现同一块内存空间释放两次的情况）</li>
<li>智能指针：智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用，将在下一个问题中对智能指针进行详细的解释。</li>
</ul>
<p><strong>VS下内存泄漏的检测方法（CRT）</strong>：</p>
<p>在debug模式下以F5运行：</p>
<pre><code class="cpp">#define CRTDBG_MAP_ALLOC  
#include &lt;stdlib.h&gt;  
#include &lt;crtdbg.h&gt;  
//在入口函数中包含 _CrtDumpMemoryLeaks();  
//即可检测到内存泄露
 
//以如下测试函数为例：
int main()&#123;
    char* pChars = new char[10];
    _CrtDumpMemoryLeaks();
    return 0;
&#125;
</code></pre>
<h2 id="1-9-智能指针有哪几种？智能指针的实现原理？"><a href="#1-9-智能指针有哪几种？智能指针的实现原理？" class="headerlink" title="1.9. 智能指针有哪几种？智能指针的实现原理？"></a>1.9. 智能指针有哪几种？智能指针的实现原理？</h2><p>智能指针是<strong>为了解决动态内存分配时忘记释放内存导致的内存泄漏以及多次释放同一块内存空间而提出的</strong>。C++11 中封装在了 <code>#include &lt; memory &gt;</code> 头文件中。</p>
<p>C++11 引入了 3 个智能指针类型：</p>
<ul>
<li><p>std::unique_ptr ：独占资源所有权的指针。</p>
</li>
<li><p>std::shared_ptr ：共享资源所有权的指针。</p>
</li>
<li><p>std::weak_ptr ：共享资源的观察者，需要和 std::shared_ptr 一起使用，不影响资源的生命周期。</p>
<p>注：std::auto_ptr 已被废弃。</p>
</li>
</ul>
<p><strong>共享指针（shared_ptr）</strong>：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。</p>
<p><strong>独占指针（unique_ptr）</strong>：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值。</p>
<p><strong>弱指针（weak_ptr）</strong>：指向 shared_ptr 指向的对象，能够解决由shared_ptr带来的循环引用问题。</p>
<p><strong>智能指针的实现原理： 计数原理。</strong></p>
<h2 id="1-10-智能指针应用举例"><a href="#1-10-智能指针应用举例" class="headerlink" title="1.10 智能指针应用举例"></a>1.10 智能指针应用举例</h2><p><strong>unique_ptr</strong><br>unique_ptr 的使用比较简单，也是用得比较多的智能指针。当我们独占资源的所有权的时候，可以使用 unique_ptr 对资源进行管理——离开 unique_ptr 对象的作用域时，会自动释放资源。这是很基本的RAII思想。（<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization）是由c++之父Bjarne Stroustrup提出的，中文翻译为资源获取即初始化，他说：使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入。</p>
<ul>
<li><p>自动管理内存<br>使用裸指针时，要记得释放内存。</p>
<pre><code class="cpp">&#123;
    int* p = new int(100);
    // ...
    delete p;  // 要记得释放内存
&#125;
</code></pre>
<p>使用 unique_ptr 自动管理内存。</p>
<pre><code class="cpp">&#123;
    std::unique_ptr&lt;int&gt; uptr = std::make_unique&lt;int&gt;(200);
    //...
    // 离开 uptr 的作用域的时候自动释放内存
&#125;
</code></pre>
</li>
<li><p>unique_ptr 是 move-only 的，也是实现将一个 unique_ptr 对象赋值给另一个 unique_ptr 对象的方法</p>
<pre><code class="cpp">&#123;
    std::unique_ptr&lt;int&gt; uptr = std::make_unique&lt;int&gt;(200);
    std::unique_ptr&lt;int&gt; uptr1 = uptr;  // 编译错误，std::unique_ptr&lt;T&gt; 是 move-only 的

    std::unique_ptr&lt;int&gt; uptr2 = std::move(uptr);
    assert(uptr == nullptr);
&#125;
</code></pre>
</li>
<li><p>unique_ptr 可以指向一个数组</p>
<pre><code class="cpp">&#123;
    std::unique_ptr&lt;int[]&gt; uptr = std::make_unique&lt;int[]&gt;(10);
    for (int i = 0; i &lt; 10; i++) &#123;
        uptr[i] = i * i;
    &#125;   
    for (int i = 0; i &lt; 10; i++) &#123;
        std::cout &lt;&lt; uptr[i] &lt;&lt; std::endl; //0 1 4 9 ...81
    &#125;   
&#125;
也可以用向量：
unique_ptr&lt;vector&lt;int&gt;&gt; p (new vector&lt;int&gt;(5, 6)); //n = 5, value = 6
std::cout &lt;&lt; *p-&gt;begin() &lt;&lt; endl;//6
</code></pre>
</li>
</ul>
<p><strong>shared_ptr</strong></p>
<ul>
<li><p>shared_ptr 其实就是对资源做引用计数——当引用计数 sptr.use_count() 为 0<br>的时候，自动释放资源。其中，<code>assert(p);</code>用于判断指针内容是否非空，空指针nullptr 与什么未指向的野指针过不了assert</p>
<pre><code class="cpp">&#123;
    std::shared_ptr&lt;int&gt; sptr = std::make_shared&lt;int&gt;(200);
    assert(sptr.use_count() == 1);  // 此时引用计数为 1
    &#123;   
        std::shared_ptr&lt;int&gt; sptr1 = sptr;
        assert(sptr.get() == sptr1.get());
        assert(sptr.use_count() == 2);   // sptr 和 sptr1 共享资源，引用计数为 2
    &#125;   
    assert(sptr.use_count() == 1);   // sptr1 已经释放
&#125;
// use_count 为 0 时自动释放内存
</code></pre>
</li>
<li><p>和 unique_ptr 一样，shared_ptr 也可以指向数组和自定义 deleter。</p>
<pre><code class="cpp">&#123;
    // C++20 才支持 std::make_shared&lt;int[]&gt;
    // std::shared_ptr&lt;int[]&gt; sptr = std::make_shared&lt;int[]&gt;(100);
    std::shared_ptr&lt;int[]&gt; sptr(new int[10]);
    for (int i = 0; i &lt; 10; i++) &#123;
        sptr[i] = i * i;
    &#125;   
    for (int i = 0; i &lt; 10; i++) &#123;
        std::cout &lt;&lt; sptr[i] &lt;&lt; std::endl;
    &#125;   
&#125;
</code></pre>
</li>
</ul>
<p>附：<br>一个 shared_ptr 对象的内存开销要比裸指针和无自定义 deleter 的 unique_ptr 对象略大。<br>无自定义 deleter 的 unique_ptr 只需要将裸指针用 RAII 的手法封装好就行，无需保存其它信息，所以它的开销和裸指针是一样的。如果有自定义 deleter，还需要保存 deleter 的信息。</p>
<p>shared_ptr 需要维护的信息有两部分：</p>
<ul>
<li><p>指向共享资源的指针。</p>
</li>
<li><p>引用计数等共享资源的控制信息——实现上是维护一个指向控制信息的指针。</p>
</li>
</ul>
<p>所以，shared_ptr 对象需要保存两个指针。shared_ptr 的 的 deleter 是保存在控制信息中，所以，是否有自定义 deleter 不影响 shared_ptr 对象的大小。</p>
<p>当我们创建一个 shared_ptr 时，其实现一般如下：</p>
<pre><code class="cpp">std::shared_ptr&lt;T&gt; sptr1(new T);
最好使用make_shared实现：
shared_ptr&lt;string&gt; p1 = make_shared&lt;string&gt;(10, &#39;9&#39;);
shared_ptr&lt;int&gt; p2 = make_shared&lt;int&gt;(42);
</code></pre>
<p><img src="/4a8a5987e39d49b2ace73524e49bdf6b.png" alt="img"></p>
<p>复制一个 shared_ptr ：</p>
<pre><code class="cpp">std::shared_ptr&lt;T&gt; sptr2 = sptr1;
</code></pre>
<p><img src="/2c2e397fb83245edab1853ea6c9b7028.png" alt="img"></p>
<p>为什么控制信息和每个 shared_ptr 对象都需要保存指向共享资源的指针？可不可以去掉 shared_ptr 对象中指向共享资源的指针，以节省内存开销？</p>
<p>答案是：不能。 因为 shared_ptr 对象中的指针指向的对象不一定和控制块中的指针指向的对象一样。</p>
<p>来看一个例子。</p>
<pre><code class="cpp">struct Fruit &#123;
    int juice;
&#125;;

struct Vegetable &#123;
    int fiber;
&#125;;

struct Tomato : public Fruit, Vegetable &#123;
    int sauce;
&#125;;

 // 由于继承的存在，shared_ptr 可能指向基类对象
std::shared_ptr&lt;Tomato&gt; tomato = std::make_shared&lt;Tomato&gt;();
std::shared_ptr&lt;Fruit&gt; fruit = tomato;
std::shared_ptr&lt;Vegetable&gt; vegetable = tomato;
</code></pre>
<p><img src="/4a8c3bbf5a07429b933d25c1d64fa359.png" alt="img"></p>
<p>此外，在使用 shared_ptr 时，会涉及两次内存分配：一次分配共享资源对象；一次分配控制块。C++ 标准库提供了 make_shared 函数来创建一个 shared_ptr 对象，只需要一次内存分配，所以推荐用make_shared 函数来创建对象。</p>
<p><strong>weak_ptr</strong></p>
<p>weak_ptr 要与 shared_ptr 一起使用。 一个 weak_ptr 对象看做是 shared_ptr 对象管理的资源的观察者，它不影响共享资源的生命周期：</p>
<ul>
<li>如果需要使用 weak_ptr 正在观察的资源，可以将 weak_ptr 提升为 shared_ptr。</li>
<li>当 shared_ptr 管理的资源被释放时，weak_ptr 会自动变成 nullptr。</li>
</ul>
<pre><code class="cpp">void Observe(std::weak_ptr&lt;int&gt; wptr) &#123;
    if (auto sptr = wptr.lock()) &#123;
        std::cout &lt;&lt; &quot;value: &quot; &lt;&lt; *sptr &lt;&lt; std::endl;
    &#125; else &#123;
        std::cout &lt;&lt; &quot;wptr lock fail&quot; &lt;&lt; std::endl;
    &#125;
&#125;

std::weak_ptr&lt;int&gt; wptr;
&#123;
    auto sptr = std::make_shared&lt;int&gt;(111);
    wptr = sptr;
    Observe(wptr);  // sptr 指向的资源没被释放，wptr 可以成功提升为 shared_ptr
&#125;
Observe(wptr);  // sptr 指向的资源已被释放，wptr 无法提升为 shared_ptr
</code></pre>
<p><img src="/eb6895f7c1454d98915dd3d0bc25607e.png" alt="img"></p>
<p>当 shared_ptr 析构并释放共享资源的时候，只要 weak_ptr 对象还存在，控制块就会保留，weak_ptr 可以通过控制块观察到对象是否存活。</p>
<p><img src="/f2abf0cc6f8241e0bd373f109c2d1eea.png" alt="img"></p>
<h2 id="1-11-一个-unique-ptr-怎么赋值给另一个-unique-ptr-对象？"><a href="#1-11-一个-unique-ptr-怎么赋值给另一个-unique-ptr-对象？" class="headerlink" title="1.11 一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？"></a>1.11 一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象？</h2><p>借助 <strong>std::move()</strong> 可以实现将一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，其目的是实现所有权的转移。</p>
<pre><code class="cpp">// A 作为一个类 
std::unique_ptr&lt;A&gt; ptr1(new A());
std::unique_ptr&lt;A&gt; ptr2 = std::move(ptr1);
</code></pre>
<h2 id="1-12-使用智能指针会出现什么问题？怎么解决？"><a href="#1-12-使用智能指针会出现什么问题？怎么解决？" class="headerlink" title="1.12 使用智能指针会出现什么问题？怎么解决？"></a>1.12 使用智能指针会出现什么问题？怎么解决？</h2><p>智能指针可能出现的问题：循环引用</p>
<p>比如定义了两个类 Parent、Child，在两个类中分别定义另一个类的对象的共享指针，由于在程序结束后，两个指针相互指向对方的内存空间，导致内存无法释放。</p>
<p>循环引用的解决方法： weak_ptr</p>
<p>循环引用：该被调用的析构函数没有被调用，从而出现了内存泄漏。</p>
<p>weak_ptr 对被 shared_ptr 管理的对象存在非拥有性（弱）引用，在访问所引用的对象前必须先转化为 shared_ptr；<br>weak_ptr 用来打断 shared_ptr 所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），shared_ptr 引用计数无法抵达 0，内存被泄露；令环中的指针之一为弱指针可以避免该情况；<br>weak_ptr 用来表达临时所有权的概念，当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用 weak_ptr 跟踪该对象；需要获得所有权时将其转化为 shared_ptr，此时如果原来的 shared_ptr 被销毁，则该对象的生命期被延长至这个临时的 shared_ptr 同样被销毁。</p>
<h2 id="1-13-VS检测内存泄漏，定位泄漏代码位置方法"><a href="#1-13-VS检测内存泄漏，定位泄漏代码位置方法" class="headerlink" title="1.13 VS检测内存泄漏，定位泄漏代码位置方法"></a>1.13 VS检测内存泄漏，定位泄漏代码位置方法</h2><p>检查方法：<br>在main函数最后面一行，加上一句_CrtDumpMemoryLeaks()。调试程序，自然关闭程序让其退出（不要定制调试），查看输出：</p>
<pre><code class="cpp">Detected memory leaks!
Dumping objects -&gt;
&#123;453&#125; normal block at 0x02432CA8, 868 bytes long.
 Data: &lt;404303374       &gt; 34 30 34 33 30 33 33 37 34 00 00 00 00 00 00 00 
&#123;447&#125; normal block at 0x024328B0, 868 bytes long.
 Data: &lt;404303374       &gt; 34 30 34 33 30 33 33 37 34 00 00 00 00 00 00 00 
&#123;441&#125; normal block at 0x024324B8, 868 bytes long.
 Data: &lt;404303374       &gt; 34 30 34 33 30 33 33 37 34 00 00 00 00 00 00 00 
&#123;435&#125; normal block at 0x024320C0, 868 bytes long.
 Data: &lt;404303374       &gt; 34 30 34 33 30 33 33 37 34 00 00 00 00 00 00 00 
&#123;429&#125; normal block at 0x02431CC8, 868 bytes long.
 Data: &lt;404303374       &gt; 34 30 34 33 30 33 33 37 34 00 00 00 00 00 00 00 
&#123;212&#125; normal block at 0x01E1BF30, 44 bytes long.
 Data: &lt;`               &gt; 60 B3 E1 01 CD CD CD CD CD CD CD CD CD CD CD CD 
&#123;204&#125; normal block at 0x01E1B2C8, 24 bytes long.
 Data: &lt;                &gt; C8 B2 E1 01 C8 B2 E1 01 C8 B2 E1 01 CD CD CD CD 
&#123;138&#125; normal block at 0x01E15680, 332 bytes long.
 Data: &lt;                &gt; 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
&#123;137&#125; normal block at 0x01E15628, 24 bytes long.
 Data: &lt;(V  (V  (V      &gt; 28 56 E1 01 28 56 E1 01 28 56 E1 01 CD CD CD CD 
Object dump complete.
</code></pre>
<p>取其中一条详细说明：{453} normal block at 0x02432CA8, 868 bytes long.<br>被{}包围的453就是我们需要的内存泄漏定位值，868 bytes long就是说这个地方有868比特内存没有释放。<br>在main函数第一行加上：_CrtSetBreakAlloc(453); 意思就是在申请453这块内存的位置中断。然后调试程序，……程序中断了。查看调用堆栈<br><img src="/cb907778bec34cf48495f99bf0dda252.png" alt="img"></p>
<p>双击我们的代码调用的最后一个函数，这里是CDbQuery::UpdateDatas()，就定位到了申请内存的代码：</p>
<p><img src="/f5ca922027ff4e3e882321fe5b8f2728.png" alt="img"></p>
<p>好了，我们总算知道是哪里出问题了，这块内存没有释放啊。改代码，修复好这个。然后继续…………，直到调试输出中没有normal block ，程序没有内存泄漏了。</p>
<p>记得加上头文件：#include &lt;crtdbg.h&gt;</p>
<p>最后要注意一点的，并不是所有normal block一定就有内存泄漏，当你的程序中有全局变量的时候，全局变量的释放示在main函数退出后，所以在main函数最后_CrtDumpMemoryLeaks（）会认为全局申请的内存没有释放，造成内存泄漏的假象。如何规避呢？我通常是把全局变量声明成指针在main函数中new 在main函数中delete，然后再调用_CrtDumpMemoryLeaks（），这样就不会误判了。</p>
<p>请自行查阅 Linux检测内存泄漏，定位泄漏代码位置方法</p>
<h2 id="1-14-深拷贝与浅拷贝"><a href="#1-14-深拷贝与浅拷贝" class="headerlink" title="1.14 深拷贝与浅拷贝"></a>1.14 深拷贝与浅拷贝</h2><ul>
<li><p><strong>c++默认的拷贝构造函数是浅拷贝</strong></p>
<p>浅拷贝就是对象的数据成员之间的简单赋值，如你设计了一个类而没有提供它的复制构造函数，当用该类的一个对象去给另一个对象赋值时所执行的过程就是浅拷贝。当数据成员中没有指针时，浅拷贝是可行的；但当<strong>数据成员中有指针时，如果采用简单的浅拷贝</strong>，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。</p>
</li>
<li><p>深拷贝与浅拷贝的区别就在于深拷贝会在<strong>堆内存中另外申请空间来储存数据，而不是一个简单的赋值过程</strong>，从而也就解决了指针悬挂的问题。</p>
</li>
</ul>
<h2 id="1-15-虚拟内存"><a href="#1-15-虚拟内存" class="headerlink" title="1.15 虚拟内存"></a>1.15 虚拟内存</h2><ul>
<li><p><strong>物理内存：</strong></p>
<p>物理内存实际上是CPU中能直接寻址的地址线条数。由于物理内存是有限的，例如32位平台下，寻址的大小是4G，并且是固定的。内存很快就会被分配完，于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后，再将等待的进程装入内存。这种频繁的装入内存的操作是很没效率的。</p>
</li>
<li><p><strong>虚拟内存：</strong></p>
<p>在进程创建的时候，系统都会给每个进程分配4G的内存空间，这其实是虚拟内存空间。进程得到的这4G虚拟内存，进程自身以为是一段连续的空间，而实际上，通常被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，需要的时候进行数据交换。<br>关于虚拟内存与物理内存的联系，下面这张图可以帮助我们巩固。</p>
</li>
</ul>
<p><img src="/05e4f27d295a43009d864995a3cc5e75.png" alt="img"></p>
<p><img src="/dc1766dd314f4861964db2236daa92b2.png" alt="img"></p>
<p><strong>虚拟内存机理及优点：</strong></p>
<ul>
<li><p><strong>虚拟内存是如何工作的？</strong></p>
<ul>
<li>当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个内存布局。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射）。这个时候数据和代码还是在磁盘上的。当运行到对应的程序时，进程去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生缺页异常，于是将磁盘上的数据拷贝到物理内存中。</li>
<li>另外在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</li>
<li>可以认为虚拟空间都被映射到了磁盘空间中（事实上也是按需要映射到磁盘空间上，通过mmap，mmap是用来建立虚拟空间和磁盘空间的映射关系的）</li>
</ul>
</li>
<li><p><strong>利用虚拟内存机制的优点 ？</strong></p>
<ul>
<li>既然每个进程的内存空间都是一致而且固定的（32位平台下都是4G），所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际内存地址，这交给内核来完成映射关系</li>
<li>当不同的进程使用同一段代码时，比如库文件的代码，在物理内存中可以只存储一份这样的代码，不同进程只要将自己的虚拟内存映射过去就好了，这样可以节省物理内存</li>
<li>在程序需要分配连续空间的时候，只需要在虚拟内存分配连续空间，而不需要物理内存时连续的，实际上，往往物理内存都是断断续续的内存碎片。这样就可以有效地利用我们的物理内存</li>
</ul>
</li>
</ul>
<h1 id="2-语言对比"><a href="#2-语言对比" class="headerlink" title="2.语言对比"></a>2.语言对比</h1><h2 id="2-1-C-11-新特性"><a href="#2-1-C-11-新特性" class="headerlink" title="2.1 C++ 11 新特性"></a>2.1 C++ 11 新特性</h2><ol>
<li><p><strong>auto 类型推导</strong></p>
<p>auto 关键字：自动类型推导，编译器会在 编译期间 通过初始值推导出变量的类型，通过 auto 定义的变量必须有初始值。</p>
</li>
<li><p><strong>decltype 类型推导</strong></p>
<p>decltype 关键字：decltype 是“declare type”的缩写，译为“声明类型”。和 auto 的功能一样，都用来在编译时期进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 auto。decltype 作用是选择并返回操作数的数据类型。</p>
<p>区别：</p>
<pre><code class="cpp">auto var = val1 + val2; 
decltype(val1 + val2) var1 = 0; 
</code></pre>
<ul>
<li>auto 根据 &#x3D; 右边的初始值 val1 + val2 推导出变量的类型，并将该初始值赋值给变量 var；decltype 根据 val1 + val2 表达式推导出变量的类型，变量的初始值和与表达式的值无关。</li>
<li>auto 要求变量必须初始化，因为它是根据初始化的值推导出变量的类型，而 decltype 不要求，定义变量的时候可初始化也可以不初始化。</li>
</ul>
</li>
<li><p><strong>lambda 表达式</strong></p>
<p>lambda 表达式，又被称为 lambda 函数或者 lambda 匿名函数。</p>
<p>lambda匿名函数的定义:</p>
<pre><code class="cpp">[capture list] (parameter list) -&gt; return type
&#123;
   function body;
&#125;;
</code></pre>
<p>其中：</p>
<ul>
<li>capture list：捕获列表，指 lambda 所在函数中定义的局部变量的列表，通常为空。</li>
<li>return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。</li>
</ul>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int main()&#123;
    int arr[4] = &#123;4, 2, 3, 1&#125;;
    //对 a 数组中的元素进行升序排序
    sort(arr, arr+4, [=](int x, int y) -&gt; bool&#123; return x &lt; y; &#125; );
    for(int n : arr)&#123;
        cout &lt;&lt; n &lt;&lt; &quot; &quot;;
    &#125;
    return 0;
&#125;
</code></pre>
</li>
<li><p>范围 for 语句</p>
<pre><code class="cpp">for (declaration : expression)&#123;
    statement
&#125;
</code></pre>
<p>参数的含义：</p>
<ul>
<li>expression：必须是一个序列，例如用花括号括起来的初始值列表、数组、vector ，string等，这些类型的共同特点是拥有能返回迭代器的 beign、end 成员。</li>
<li>declaration：此处定义一个变量，序列中的每一个元素都能转化成该变量的类型，常用 auto 类型说明符。</li>
</ul>
</li>
<li><p>左值和右值，左值引用和右值引用</p>
<p><strong>左值和右值</strong></p>
<ul>
<li><p><strong>左值：指表达式结束后依然存在的持久对象，可以取地址，具名变量或对象。</strong>左值符号 &amp;</p>
<p>通俗理解：左值是指具有对应的可由用户访问的存储单元，并且能由用户改变其值的量。如一个变量就是一个左值，因为它对应着一个存储单元，并可由编程者通过变量名访问和改变其值。<br>左值(Lvalue) →→ Location<br>表示内存中可以寻址，可以给它赋值(const类型的变量例外)</p>
</li>
<li><p><strong>右值：表达式结束后就不再存在的临时对象，不可以取地址，没有名字。</strong> 右值符号 &amp;&amp;</p>
<p>右值(Rvalue) →→ Read<br>表示可以知道它的值（例如常数）</p>
</li>
</ul>
<p>通俗的讲，左值就是能够出现在赋值符号左面的东西，而右值就是那些可以出现在赋值符号右面的东西， 比如 <code>int a = b + c;</code>，a 就是一个左值，可以对a取地址，而b+c 就是一个右值，对表达式b+c 取地址会报错。<br>一个典型的例子</p>
<p><strong>a++</strong> ： 先使用a的值，再给a加1，作为<strong>右值</strong></p>
<pre><code class="cpp">// a++的实现
int temp = a;
a = a + 1;
return temp;
</code></pre>
<p><strong>++a</strong> ： 先加再用，作为<strong>左值</strong></p>
<pre><code class="cpp">a = a + 1;
return a;
</code></pre>
<p>在C++中，临时对象不能作为左值，但是可以作为常量引用，const &amp;。</p>
<p>C++ 11中的std::move可将左值引用转化成右值引用。</p>
<p>C++11中右值又由两个概念组成：将亡值和纯右值。</p>
<p><strong>纯右值和将亡值</strong></p>
<p>在C++98中，右值是纯右值，纯右值指的是临时变量值、不跟对象关联的字面量值。包括非引用的函数返回值、表达式等，比如 2、‘ch’、int func()等。将亡值是C++11新增的、与右值引用相关的表达式。</p>
<ul>
<li>纯右值：非引用返回的临时变量( int func(void))、运算表达式产生的临时变量(b+c)、原始字面量(2)、lambda表达式等。</li>
<li>将亡值：将要被移动的对象、T&amp;&amp;函数返回值、std::move返回值和转换为T&amp;&amp;的类型的转换函数的返回值。</li>
</ul>
<p>将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。</p>
<p><strong>右值引用和左值引用</strong></p>
<ul>
<li>右值引用：绑定到右值的引用，用 &amp;&amp; 来获得右值引用，右值引用只能绑定到要销毁的对象。是对一个右值进行引用的类型，标记为T&amp;&amp;。因为右值不具名，是以引用的形式找到它，用引用来表示，右值引用也是引用的引用（我目前是这么想的）。</li>
<li>左值引用：对一个左值进行引用的类型。常规的引用一般都是左值引用</li>
</ul>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
int main()
&#123;
    int var = 42;
    int &amp;l_var = var;
    int &amp;&amp;r_var = var; // 错误：不能将右值引用绑定到左值上

    int &amp;&amp;r_var2 = var + 40; // 正确：将 r_var2 绑定到求和结果上
    return 0;
&#125;
</code></pre>
<p>引用本身不拥有所绑定对象的内存，只是该对象的一个别名，左值引用就是有名变量的别名，右值引用是不具名变量的别名。因此无论左值引用还是右值引用都必须立即进行初始化。</p>
<p>通过右值引用，这个将亡的右值又“重获新生”，它的生命周期与右值引用类型变量的生命周期一样，只要这个右值引用类型的变量还活着，那么这个右值临时量就会一直活着，这是一重要特性，可利用这一点会一些性能优化，避免临时对象的拷贝构造和析构。</p>
<p>左值引用包括常量左值引用和非常量左值引用。非常量左值引用只能接受左值，不能接受右值；常量左值引用是一个“万能”的引用类型，可以接受左值（常量左值、非常量左值）、右值。不过常量左值所引用的右值在它的“余生”中只能是只读的。</p>
<pre><code class="cpp">int &amp;a = 2;       // 非常量左值引用 绑定到 右值，编译失败
 
int b = 2;        // b 是非常量左值
const int &amp;c = b; // 常量左值引用 绑定到 非常量左值，编译通过
 
const int d = 2;  // d 是常量左值
const int &amp;e = d; // 常量左值引用 绑定到 常量左值，编译通过
const int &amp;f =2;  // 常量左值引用 绑定到 右值，编译通过
</code></pre>
<p>右值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。比如：</p>
<pre><code class="cpp">int a;
int &amp;&amp;r1 = a;             // 编译失败
int &amp;&amp;r2 = std::move(a);  // 编译通过
</code></pre>
<p>简单总结：</p>
<ul>
<li><strong>左值引用, 即&amp;i</strong>, 是一种对象类型的引用; <strong>右值引用, 即&amp;&amp;i</strong>, 是一种对象值的引用;</li>
<li><strong>move() 函数</strong>可以把左值引用, 转换为右值引用;</li>
<li>左值引用是固定的引用, 右值引用是易变的引用, 只能引用字面值(literals)或临时对象(temporary object);</li>
<li>右值引用主要应用在移动构造器(move constructor) 和移动-赋值操作符(move-assignment operator)上面;</li>
</ul>
<p>代码如下</p>
<pre><code class="cpp">#include &lt;iostream&gt;  
#include &lt;utility&gt;  
  
int main (void) &#123;  
    int i = 42;  
    int &amp;lr = i;  
    int &amp;&amp;rr = i*42;  
    const int &amp;lr1 = i*42;  
    int &amp;&amp;rr1 = 42;  
    int &amp;&amp;rr2 = std::move(lr);  
    std::cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; std::endl;  
    std::cout &lt;&lt; &quot;lr = &quot; &lt;&lt; lr &lt;&lt; std::endl;  
    std::cout &lt;&lt; &quot;rr = &quot; &lt;&lt; rr &lt;&lt; std::endl;  
    std::cout &lt;&lt; &quot;lr1 = &quot; &lt;&lt; lr1  &lt;&lt;std::endl;  
    std::cout &lt;&lt; &quot;rr1  = &quot; &lt;&lt; rr1  &lt;&lt; std::endl;  
    std::cout &lt;&lt; &quot;rr2  = &quot; &lt;&lt; rr2  &lt;&lt; std::endl;  
&#125;  
</code></pre>
</li>
<li><p>标准库 move() 函数</p>
<p>move() 函数：通过该函数可获得绑定到左值上的右值引用，该函数包括在 utility 头文件中。该知识点会在后续的章节中做详细的说明。</p>
</li>
<li><p>智能指针</p>
</li>
<li><p>delete 函数和 default 函数</p>
<ul>
<li>delete 函数：&#x3D; delete 表示该函数不能被调用。</li>
<li>default 函数：&#x3D; default 表示编译器生成默认的函数，例如：生成默认的构造函数。</li>
</ul>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

class A
&#123;
public:
    A() = default; // 表示使用默认的构造函数
    ~A() = default;	// 表示使用默认的析构函数
    A(const A &amp;) = delete; // 表示类的对象禁止拷贝构造
    A &amp;operator=(const A &amp;) = delete; // 表示类的对象禁止拷贝赋值
&#125;;
int main()
&#123;
    A ex1;
    A ex2 = ex1; // error: use of deleted function &#39;A::A(const A&amp;)&#39;
    A ex3;
    ex3 = ex1; // error: use of deleted function &#39;A&amp; A::operator=(const A&amp;)&#39;
    return 0;
&#125;
</code></pre>
</li>
</ol>
<h2 id="2-2-C-和-C-的区别"><a href="#2-2-C-和-C-的区别" class="headerlink" title="2.2 C 和 C++ 的区别"></a>2.2 C 和 C++ 的区别</h2><p>首先说一下面向对象和面向过程：</p>
<ul>
<li><strong>面向过程的思路</strong>：面向过程编程就是分析出解决问题的步骤，然后把这些步骤一步一步的实现，使用的时候一个一个的依次调用就可以了。</li>
<li><strong>面向对象的思路</strong>：面向对象编程就是把问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。</li>
<li>举个例子：（玩五子棋）<br>（1）用面向过程的思想来考虑就是：开始游戏，白子先走，绘制画面，判断输赢，轮到黑子，绘制画面，判断输赢，重复前面的过程，输出最终结果。<br>（2）用面向对象的思想来考虑就是：黑白双方（两者的行为是一样的）、棋盘系统（负责绘制画面）、规定系统（规定输赢、犯规等）、输出系统（输出赢家）。<br><strong>面向对象就是高度实物抽象化（功能划分）、面向过程就是自顶向下的编程（步骤划分）</strong></li>
</ul>
<p><strong>区别和联系：</strong></p>
<ul>
<li>C和C++一个典型的区别就在动态内存管理上了，C语言通过malloc和free来进行堆内存的分配和释放，而C++是通过new和delete来管理堆内存的；</li>
<li>强制类型转换上也不一样，C的强制类型转换使用()小括号里面加类型进行类型强转的，而C++有四种自己的类型强转方式，分别是const_cast，static_cast，reinterpret_cast和dynamic_cast；</li>
<li>C和C++的输入输出方式也不一样，printf&#x2F;scanf，和C++的cout&#x2F;cin的对别，前面一组是C的库函数，后面是ostream和istream类型的对象。</li>
<li>C++还支持namespace名字空间，可以让用户自己定义新的名字空间作用域出来，避免全局的名字冲突问题。</li>
<li>应用领域：C 语言主要用于嵌入式领域，驱动开发等与硬件直接打交道的领域，C++ 可以用于应用层开发，用户界面开发等与操作系统打交道的领域。</li>
<li>C++ 既继承了 C 强大的底层操作特性，又被赋予了面向对象机制。它特性繁多，面向对象语言的多继承，对值传递与引用传递的区分以及 const 关键字，等等。</li>
<li>C++ 对 C 的“增强”，表现在以下几个方面：类型检查更为严格。增加了面向对象的机制、泛型编程的机制（Template）、异常处理、运算符重载、标准模板库（STL）、命名空间（避免全局命名冲突）。</li>
</ul>
<p><strong>面向过程的语言：</strong></p>
<p><strong>优点</strong>：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发，性能是最重要的因素。<br><strong>缺点</strong>：没有面向对象易维护、易复用、易扩展</p>
<p><strong>面向对象语言：</strong></p>
<p><strong>优点</strong>：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护<br><strong>缺点</strong>：性能比面向过程低</p>
<h2 id="2-3-Python-和-C-的区别"><a href="#2-3-Python-和-C-的区别" class="headerlink" title="2.3 Python 和 C++ 的区别"></a>2.3 Python 和 C++ 的区别</h2><ul>
<li>语言自身：Python 为脚本语言，解释执行，不需要经过编译；C++ 是一种需要编译后才能运行的语言，在特定的机器上编译后运行。</li>
<li>运行效率：C++ 运行效率高，安全稳定。原因：Python 代码和 C++ 最终都会变成 CPU指令来跑，但一般情况下，比如反转和合并两个字符串，Python 最终转换出来的 CPU 指令会比 C++ 多很多。首先，Python中涉及的内容比 C++ 多，经过了更多层，Python 中甚至连数字都是 object ；其次，Python 是解释执行的，和物理机CPU 之间多了解释器这层，而 C++ 是编译执行的，直接就是机器码，编译的时候编译器又可以进行一些优化。</li>
<li>开发效率：Python 开发效率高。原因：Python 一两句代码就能实现的功能，C++ 往往需要更多的代码才能实现。</li>
<li>书写格式和语法不同：Python 的语法格式不同于其 C++ 定义声明才能使用，而且极其灵活，完全面向更上层的开发者。</li>
</ul>
<h1 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3. 面向对象"></a>3. 面向对象</h1><h2 id="3-1-什么是面向对象？面向对象的三大特性"><a href="#3-1-什么是面向对象？面向对象的三大特性" class="headerlink" title="3.1 什么是面向对象？面向对象的三大特性"></a>3.1 什么是面向对象？面向对象的三大特性</h2><p><strong>面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。</strong></p>
<p>面向对象的三大特性：</p>
<ul>
<li>封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。</li>
<li>继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。</li>
<li>多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。</li>
</ul>
<h2 id="3-2-重载、重写、隐藏的区别"><a href="#3-2-重载、重写、隐藏的区别" class="headerlink" title="3.2 重载、重写、隐藏的区别"></a>3.2 重载、重写、隐藏的区别</h2><p><strong>重载</strong>：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</p>
<pre><code class="cpp">class A &#123;
    public:
        void fun(int tmp);
        void fun(float tmp);        // 重载 参数类型不同（相对于上一个函数）
        void fun(int tmp, float tmp1); // 重载 参数个数不同（相对于上一个函数）
        void fun(float tmp, int tmp1); // 重载 参数顺序不同（相对于上一个函数）
        int fun(int tmp);            // error: &#39;int A::fun(int)&#39; cannot be overloaded 错误：注意重载不关心函数返回类型
&#125;;
</code></pre>
<p>**隐藏(重定义)**：是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。</p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

class Base &#123;
public:
    void fun(int tmp, float tmp1) &#123; 
        cout &lt;&lt; &quot;Base::fun(int tmp, float tmp1)&quot; &lt;&lt; endl; 
    &#125;
&#125;;

class Derive : public Base &#123;
public:
    void fun(int tmp) &#123; 
        cout &lt;&lt; &quot;Derive::fun(int tmp)&quot; &lt;&lt; endl; 
    &#125; // 隐藏基类中的同名函数
&#125;;

int main()&#123;
    Derive ex;
    ex.fun(1);       // Derive::fun(int tmp)
    ex.fun(1, 0.01); // error: candidate expects 1 argument, 2 provided
    return 0;
&#125;
</code></pre>
<p>说明：上述代码中 ex.fun(1, 0.01); 出现错误，说明派生类中将基类的同名函数隐藏了。若是想调用基类中的同名函数，可以加上类型名指明 ex.Base::fun(1, 0.01);，这样就可以调用基类中的同名函数。</p>
<p>**重写(覆盖)**：是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 virtual 修饰。</p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

class Base &#123;
public:
    virtual void fun(int tmp) &#123;
        cout &lt;&lt; &quot;Base::fun(int tmp) : &quot; &lt;&lt; tmp &lt;&lt; endl; 
    &#125;
&#125;;

class Derived : public Base&#123;
public:
    virtual void fun(int tmp) &#123; 
        cout &lt;&lt; &quot;Derived::fun(int tmp) : &quot; &lt;&lt; tmp &lt;&lt; endl; 
    &#125; // 重写基类中的 fun 函数
&#125;;
int main()&#123;
    Base *p = new Derived();
    p-&gt;fun(3); // Derived::fun(int) : 3
    return 0;
&#125;
</code></pre>
<p><strong>重写和重载的区别：</strong></p>
<ul>
<li>范围区别：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。</li>
<li>参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰。</li>
<li>virtual 关键字：重写的函数基类中必须有 virtual关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。</li>
</ul>
<p><strong>隐藏和重写，重载的区别：</strong></p>
<ul>
<li>范围区别：隐藏与重载范围不同，隐藏发生在不同类中。</li>
<li>参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 virtual修饰，基类函数都是被隐藏，而不是重写。</li>
</ul>
<h2 id="3-3-如何理解-C-是面向对象编程"><a href="#3-3-如何理解-C-是面向对象编程" class="headerlink" title="3.3 如何理解 C++ 是面向对象编程"></a>3.3 如何理解 C++ 是面向对象编程</h2><p>说明：该问题最好结合自己的项目经历进行展开解释，或举一些恰当的例子，同时对比下面向过程编程。</p>
<ul>
<li><strong>面向过程编程</strong>：一种以执行程序操作的过程或函数为中心编写软件的方法。程序的数据通常存储在变量中，与这些过程是分开的。所以必须将变量传递给需要使用它们的函数。缺点：随着程序变得越来越复杂，程序数据与运行代码的分离可能会导致问题。例如，程序的规范经常会发生变化，从而需要更改数据的格式或数据结构的设计。当数据结构发生变化时，对数据进行操作的代码也必须更改为接受新的格式。查找需要更改的所有代码会为程序员带来额外的工作，并增加了使代码出现错误的机会。</li>
<li><strong>面向对象编程（Object-Oriented Programming, OOP）</strong>：以创建和使用对象为中心。一个对象（Object）就是一个软件实体，它将数据和程序在一个单元中组合起来。对象的数据项，也称为其属性，存储在成员变量中。对象执行的过程被称为其成员函数。将对象的数据和过程绑定在一起则被称为封装。</li>
</ul>
<p>面向对象编程进一步说明：</p>
<p>面向对象编程将数据成员和成员函数封装到一个类中，并声明数据成员和成员函数的访问级别（public、private、protected），以便控制类对象对数据成员和函数的访问，对数据成员起到一定的保护作用。而且在类的对象调用成员函数时，只需知道成员函数的名、参数列表以及返回值类型即可，无需了解其函数的实现原理。当类内部的数据成员或者成员函数发生改变时，不影响类外部的代码。</p>
<h2 id="3-4-什么是多态？多态如何实现？"><a href="#3-4-什么是多态？多态如何实现？" class="headerlink" title="3.4 什么是多态？多态如何实现？"></a>3.4 什么是多态？多态如何实现？</h2><p><strong>多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。</strong>在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p>
<p><strong>实现方法：</strong>多态是通过<strong>虚函数</strong>实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。</p>
<p><strong>实现过程：</strong></p>
<ul>
<li>在类中用 virtual 关键字声明的函数叫做虚函数；</li>
<li>存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）；</li>
<li>当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。</li>
</ul>
<p><strong>静态多态与动态多态：</strong></p>
<ul>
<li><strong>静态多态</strong>：也称为<strong>编译期间的多态</strong>，编译器在编译期间完成的，编译器根据函数实参的类型(可能会进行隐式类型转换)，可推断出要调用那个函数，如果有对应的函数就调用该函数，否则出现编译错误。</li>
<li><strong>动态多态（动态绑定）</strong>：即<strong>运行时的多态</strong>，在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法。：<ul>
<li>基类中必须包含虚函数，并且派生类中一定要对基类中的虚函数进行重写。</li>
<li>通过基类对象的指针或者引用调用虚函数。</li>
</ul>
</li>
</ul>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

class Base&#123;
public:
    virtual void fun() &#123; cout &lt;&lt; &quot;Base::fun()&quot; &lt;&lt; endl; &#125;

    virtual void fun1() &#123; cout &lt;&lt; &quot;Base::fun1()&quot; &lt;&lt; endl; &#125;

    virtual void fun2() &#123; cout &lt;&lt; &quot;Base::fun2()&quot; &lt;&lt; endl; &#125;
&#125;;
class Derive : public Base&#123;
public:
    void fun() &#123; cout &lt;&lt; &quot;Derive::fun()&quot; &lt;&lt; endl; &#125;

    virtual void D_fun1() &#123; cout &lt;&lt; &quot;Derive::D_fun1()&quot; &lt;&lt; endl; &#125;

    virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125;
&#125;;
int main()&#123;
    Base *p = new Derive();
    p-&gt;fun(); // Derive::fun() 调用派生类中的虚函数
    return 0;
&#125;
</code></pre>
<p>简单解释：当基类的指针指向派生类的对象时，通过派生类的对象的虚表指针找到虚函数表（派生类的对象虚函数表），进而找到相应的虚函数 Derive::f() 进行调用。</p>
<h1 id="4-类相关"><a href="#4-类相关" class="headerlink" title="4.类相关"></a>4.类相关</h1><h2 id="4-1-什么是虚函数？什么是纯虚函数？"><a href="#4-1-什么是虚函数？什么是纯虚函数？" class="headerlink" title="4.1 什么是虚函数？什么是纯虚函数？"></a>4.1 什么是虚函数？什么是纯虚函数？</h2><p><strong>虚函数：</strong>被 virtual 关键字修饰的成员函数，就是虚函数。</p>
<p><strong>纯虚函数：</strong></p>
<ul>
<li>纯虚函数在类中声明时，加上 &#x3D;0；</li>
<li>含有纯虚函数的类称为抽象类（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法；</li>
<li>继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；</li>
<li>可以声明抽象类指针，可以声明抽象类的引用；</li>
<li>子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。</li>
</ul>
<h2 id="4-2-虚函数和纯虚函数的区别？"><a href="#4-2-虚函数和纯虚函数的区别？" class="headerlink" title="4.2 虚函数和纯虚函数的区别？"></a>4.2 虚函数和纯虚函数的区别？</h2><ul>
<li>虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类。（含有纯虚函数的类称为抽象基类）</li>
<li>使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；</li>
<li>定义形式不同：虚函数在定义时在普通函数的基础上加上 virtual 关键字，纯虚函数定义时除了加上virtual 关键字还需要加上 &#x3D;0;</li>
<li>虚函数必须实现，否则编译器会报错；</li>
<li>对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写；</li>
<li>析构函数最好定义为虚函数，特别是对于含有继承关系的类；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。</li>
</ul>
<h2 id="4-3-虚函数的实现机制"><a href="#4-3-虚函数的实现机制" class="headerlink" title="4.3 虚函数的实现机制"></a>4.3 虚函数的实现机制</h2><p><strong>实现机制：</strong>虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数</p>
<p>虚函数表相关知识点：</p>
<ul>
<li>虚函数表存放的内容：类的虚函数的地址。</li>
<li>虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。</li>
<li>虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。</li>
</ul>
<p>注：虚函数表和类绑定，虚表指针和对象绑定。即类的不同的对象的虚函数表是一样的，但是每个对象都有自己的虚表指针，来指向类的虚函数表。</p>
<p>实例：<br>无虚函数覆盖的情况：</p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

class Base&#123;
public:
    virtual void B_fun1() &#123; cout &lt;&lt; &quot;Base::B_fun1()&quot; &lt;&lt; endl; &#125;
    virtual void B_fun2() &#123; cout &lt;&lt; &quot;Base::B_fun2()&quot; &lt;&lt; endl; &#125;
    virtual void B_fun3() &#123; cout &lt;&lt; &quot;Base::B_fun3()&quot; &lt;&lt; endl; &#125;
&#125;;

class Derive : public Base&#123;
public:
    virtual void D_fun1() &#123; cout &lt;&lt; &quot;Derive::D_fun1()&quot; &lt;&lt; endl; &#125;
    virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125;
    virtual void D_fun3() &#123; cout &lt;&lt; &quot;Derive::D_fun3()&quot; &lt;&lt; endl; &#125;
&#125;;

int main()&#123;
    Base *p = new Derive();
    p-&gt;B_fun1(); // Base::B_fun1()
    return 0;
&#125;
</code></pre>
<p>主函数中基类的指针 p 指向了派生类的对象，当调用函数 B_fun1() 时，通过派生类的虚函数表找到该函数的地址，从而完成调用。</p>
<h2 id="4-4-单继承和多继承的虚函数表结构"><a href="#4-4-单继承和多继承的虚函数表结构" class="headerlink" title="4.4 单继承和多继承的虚函数表结构"></a>4.4 单继承和多继承的虚函数表结构</h2><p>编译器处理虚函数表：</p>
<ul>
<li>编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。</li>
<li>如果派生类没有重新定义基类的虚函数 A，则派生类的虚函数表中保存的是基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的。</li>
<li>如果派生类重写了基类的某个虚函数 B，则派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中。</li>
<li>如果派生类重新定义了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 的地址。</li>
</ul>
<h2 id="4-5-为什么构造函数不能为虚函数？"><a href="#4-5-为什么构造函数不能为虚函数？" class="headerlink" title="4.5 为什么构造函数不能为虚函数？"></a>4.5 为什么构造函数不能为虚函数？</h2><p>虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数——构造函数了。</p>
<h2 id="4-6-为什么析构函数可以为虚函数，如果不设为虚函数可能会存在什么问题？"><a href="#4-6-为什么析构函数可以为虚函数，如果不设为虚函数可能会存在什么问题？" class="headerlink" title="4.6 为什么析构函数可以为虚函数，如果不设为虚函数可能会存在什么问题？"></a>4.6 为什么析构函数可以为虚函数，如果不设为虚函数可能会存在什么问题？</h2><p><strong>防止内存泄露</strong>，delete p（基类）的时候，它很机智的先执行了派生类的析构函数，然后执行了基类的析构函数。</p>
<p>如果基类的析构函数不是虚函数，在delete p（基类）时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，这样就会造成内存泄露。</p>
<p>举例说明：<br>子类B继承自基类A；<code>A *p = new B; delete p;</code><br>1） 此时，如果类A的析构函数不是虚函数，那么<code>delete p；</code>将会仅仅调用A的析构函数，只释放了B对象中的A部分，而派生出的新的部分未释放掉。<br>2） 如果类A的析构函数是虚函数，<code>delete p;</code> 将会先调用B的析构函数，再调用A的析构函数，释放B对象的所有空间。<br>补充： <code>B *p = new B; delete p;</code>时也是先调用B的析构函数，再调用A的析构函数。</p>
<h2 id="4-7-不能声明为虚函数的有哪些"><a href="#4-7-不能声明为虚函数的有哪些" class="headerlink" title="4.7 .不能声明为虚函数的有哪些"></a>4.7 .不能声明为虚函数的有哪些</h2><ol>
<li><strong>静态成员函数；</strong></li>
<li><strong>类外的普通函数；</strong></li>
<li><strong>构造函数；</strong> </li>
<li><strong>友元函数</strong></li>
</ol>
<p>虚函数是为了实现多态特性的。虚函数的调用只有在程序运行的时候才能知道到底调用的是哪个函数，其是有有如下几点需要注意：</p>
<ul>
<li>类的<strong>构造函数</strong>不能是虚函数<br>构造函数是为了构造对象的，所以在调用构造函数时候必然知道是哪个对象调用了构造函数，所以构造函数不能为虚函数。</li>
<li>类的<strong>静态成员函数</strong>不能是虚函数<br>类的静态成员函数是该类共用的，与该类的对象无关，静态函数里没有this指针，所以不能为虚函数。</li>
<li><strong>内联函数</strong><br>内联函数的目的是为了减少函数调用时间。它是把内联函数的函数体在编译器预处理的时候替换到函数调用处，这样代码运行到这里时候就不需要花时间去调用函数。inline是在编译器将函数类容替换到函数调用处，是静态编译的。而虚函数是动态调用的，在编译器并不知道需要调用的是父类还是子类的虚函数，所以不能够inline声明展开，所以编译器会忽略。</li>
<li><strong>友元函数</strong><br>友元函数与该类无关，没有this指针，所以不能为虚函数。</li>
</ul>
<h1 id="5-关键字库函数"><a href="#5-关键字库函数" class="headerlink" title="5. 关键字库函数"></a>5. 关键字库函数</h1><h2 id="5-1-sizeof-和-strlen-的区别"><a href="#5-1-sizeof-和-strlen-的区别" class="headerlink" title="5.1 sizeof 和 strlen 的区别"></a>5.1 sizeof 和 strlen 的区别</h2><ul>
<li><p><strong>strlen 是头文件中的函数，sizeof 是 C++ 中的运算符。</strong></p>
</li>
<li><p><strong>strlen 测量的是字符串的实际长度（其源代码如下），以 \0 结束。而 sizeof 测量的是字符数组的分配大小。</strong></p>
<pre><code class="cpp">strlen 源代码:
size_t strlen(const char *str) &#123;
    size_t length = 0;
    while (*str++)
        ++length;
    return length;
&#125;
</code></pre>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

int main()
&#123;
    char arr[10] = &quot;hello&quot;;
    cout &lt;&lt; strlen(arr) &lt;&lt; endl; // 5
    cout &lt;&lt; sizeof(arr) &lt;&lt; endl; // 10
    return 0;
&#125;
</code></pre>
</li>
<li><p>若字符数组 arr 作为函数的形参，sizeof(arr) 中 arr 被当作字符指针来处理，strlen(arr) 中 arr<br>依然是字符数组，从下述程序的运行结果中就可以看出。</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

void size_of(char arr[])
&#123;
    cout &lt;&lt; sizeof(arr) &lt;&lt; endl; // warning: &#39;sizeof&#39; on array function parameter &#39;arr&#39; will return size of &#39;char*&#39; .
    cout &lt;&lt; strlen(arr) &lt;&lt; endl; 
&#125;

int main()
&#123;
    char arr[20] = &quot;hello&quot;;
    size_of(arr); 
    return 0;
&#125;
/*
输出结果：
8
5
*/
</code></pre>
</li>
<li><p>strlen 本身是库函数，因此在程序运行过程中，计算长度；而 sizeof 在编译时，计算长度；</p>
</li>
<li><p>sizeof 的参数可以是类型，也可以是变量；strlen 的参数必须是 char* 类型的变量。</p>
</li>
</ul>
<h2 id="5-2-lambda-表达式（匿名函数）的具体应用和使用场景"><a href="#5-2-lambda-表达式（匿名函数）的具体应用和使用场景" class="headerlink" title="5.2 lambda 表达式（匿名函数）的具体应用和使用场景"></a>5.2 lambda 表达式（匿名函数）的具体应用和使用场景</h2><p>lambda表达式的定义形式如下：</p>
<pre><code class="cpp">[capture list] (parameter list) -&gt; reurn type
&#123;
   function body
&#125;
</code></pre>
<p>其中：</p>
<ul>
<li>capture list：捕获列表，指 lambda 表达式所在函数中定义的局部变量的列表，通常为空，但如果函数体中用到了 lambda 表达式所在函数的局部变量，必须捕获该变量，即将此变量写在捕获列表中。捕获方式分为：引用捕获方式 [&amp;]、值捕获方式 [&#x3D;]。</li>
<li>return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。</li>
</ul>
<p>常见使用场景：排序算法</p>
<pre><code class="cpp">bool compare(int&amp; a, int&amp; b)
&#123;
    return a &gt; b;
&#125;

int main(void)
&#123;
    int data[6] = &#123; 3, 4, 12, 2, 1, 6 &#125;;
    vector&lt;int&gt; testdata;
    testdata.insert(testdata.begin(), data, data + 6);
    
    // 排序算法
    sort(testdata.begin(), testdata.end(), compare); // 升序
    
    // 使用lambda表达式
    sort(testdata.begin(), testdata.end(), [](int a, int b)&#123; return a &gt; b; &#125;);

    return 0;
&#125;
</code></pre>
<h2 id="5-3-explicit-的作用（如何避免编译器进行隐式类型转换）"><a href="#5-3-explicit-的作用（如何避免编译器进行隐式类型转换）" class="headerlink" title="5.3 explicit 的作用（如何避免编译器进行隐式类型转换）"></a>5.3 explicit 的作用（如何避免编译器进行隐式类型转换）</h2><p>作用：用来声明类构造函数是显示调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显示调用的，再加上 explicit 关键字也没有什么意义。</p>
<p>隐式转换：</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

class A
&#123;
public:
    int var;
    A(int tmp)
    &#123;
        var = tmp;
    &#125;
&#125;;
int main()
&#123;
    A ex = 10; // 发生了隐式转换
    return 0;
&#125;
</code></pre>
<p>上述代码中，<code>A ex = 10;</code> 在编译时，进行了隐式转换，将 10 转换成 A 类型的对象，然后将该对象赋值给 ex，等同于如下操作：</p>
<p>为了避免隐式转换，可用 explicit 关键字进行声明：</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

class A
&#123;
public:
    int var;
    explicit A(int tmp)
    &#123;
        var = tmp;
        cout &lt;&lt; var &lt;&lt; endl;
    &#125;
&#125;;
int main()
&#123;
    A ex(100);
    A ex1 = 10; // error: conversion from &#39;int&#39; to non-scalar type &#39;A&#39; requested
    return 0;
&#125;
</code></pre>
<h2 id="5-4-C-和-C-static-的区别"><a href="#5-4-C-和-C-static-的区别" class="headerlink" title="5.4 C 和 C++ static 的区别"></a>5.4 C 和 C++ static 的区别</h2><ul>
<li>在 C 语言中，使用 static 可以定义局部静态变量、外部静态变量、静态函数</li>
<li>在 C++ 中，使用 static 可以定义局部静态变量、外部静态变量、静态函数、静态成员变量和静态成员函数。因为 C++中有类的概念，静态成员变量、静态成员函数都是与类有关的概念。</li>
</ul>
<h2 id="5-4-static-的作用"><a href="#5-4-static-的作用" class="headerlink" title="5.4 static 的作用"></a>5.4 static 的作用</h2><p>作用：static 定义静态变量，静态函数。</p>
<ul>
<li>保持变量内容持久：static 作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间。</li>
<li>隐藏：static作用于全局变量和函数，改变了全局变量和函数的作用域，使得全局变量和函数<strong>只能在定义它的文件中使用</strong>，在源文件中不具有全局可见性。（注：普通全局变量和函数具有全局可见性，即其他的源文件也可以使用。）</li>
<li>static 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说<strong>可以不定义类的对象就可以通过类访问这些静态成员</strong>。注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。</li>
</ul>
<h2 id="5-5-static-在类中使用的注意事项（定义、初始化和使用）"><a href="#5-5-static-在类中使用的注意事项（定义、初始化和使用）" class="headerlink" title="5.5 static 在类中使用的注意事项（定义、初始化和使用）"></a>5.5 static 在类中使用的注意事项（定义、初始化和使用）</h2><p>static 静态成员变量：</p>
<ul>
<li><p>静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现 static关键字和private、public、protected 访问规则。</p>
</li>
<li><p>静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象。</p>
</li>
<li><p>静态成员变量可以作为成员函数的参数，而普通成员变量不可以。</p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

class A
&#123;
public:
    static int s_var;
    int var;
    void fun1(int i = s_var); // 正确，静态成员变量可以作为成员函数的参数
    void fun2(int i = var);   //  error: invalid use of non-static data member &#39;A::var&#39;
&#125;;
</code></pre>
</li>
<li><p>静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。</p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

class A
&#123;
public:
    static A s_var; // 正确，静态数据成员
    A var;          // error: field &#39;var&#39; has incomplete type &#39;A&#39;
    A *p;           // 正确，指针
    A &amp;var1;        // 正确，引用
&#125;;
</code></pre>
</li>
</ul>
<p>static 静态成员函数：</p>
<ul>
<li>静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 this 指针。静态成员函数做为类作用域的全局函数。</li>
<li>静态成员函数不能声明成虚函数（virtual）、const函数和 volatile 函数。</li>
</ul>
<h2 id="5-7-static-全局变量和普通全局变量的异同"><a href="#5-7-static-全局变量和普通全局变量的异同" class="headerlink" title="5.7 static 全局变量和普通全局变量的异同"></a>5.7 static 全局变量和普通全局变量的异同</h2><p>相同点：</p>
<ul>
<li>存储方式：普通全局变量和 static 全局变量都是静态存储方式。</li>
</ul>
<p>不同点：</p>
<ul>
<li>作用域：普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</li>
<li>初始化：静态全局变量只初始化一次，防止在其他文件中使用。</li>
</ul>
<h2 id="5-8-const-作用及用法"><a href="#5-8-const-作用及用法" class="headerlink" title="5.8 const 作用及用法"></a>5.8 const 作用及用法</h2><p>作用：</p>
<ul>
<li>const 修饰成员变量，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。</li>
<li>const 修饰函数参数，使得传递过来的函数参数的值不能改变。</li>
<li>const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。</li>
</ul>
<p>在类中的用法：</p>
<p>const 成员变量：</p>
<ul>
<li>const 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。</li>
<li>const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此不能在类的声明中初始化 const 成员变量，类的对象还没有创建，编译器不知道他的值。</li>
</ul>
<p>const 成员函数：</p>
<ul>
<li>不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量。</li>
<li>不能调用非常量成员函数，以防修改成员变量的值。</li>
</ul>
<h2 id="5-9-define-和-const-的区别"><a href="#5-9-define-和-const-的区别" class="headerlink" title="5.9 define 和 const 的区别"></a>5.9 define 和 const 的区别</h2><p>区别：</p>
<ul>
<li>编译阶段：define 是在编译预处理阶段进行替换，const 是在编译阶段确定其值。</li>
<li>安全性：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。</li>
<li>内存占用：define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；const 定义的常量占用静态存储区的空间，程序运行过程中只有一份。</li>
<li>调试：define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；cons定义的常量可以进行调试。</li>
</ul>
<p>const 的优点：</p>
<ul>
<li>有数据类型，在定义式可进行安全性检查。<br>可调式。</li>
<li>占用较少的空间。</li>
</ul>
<h2 id="5-10-define-和-typedef-的区别"><a href="#5-10-define-和-typedef-的区别" class="headerlink" title="5.10 define 和 typedef 的区别"></a>5.10 define 和 typedef 的区别</h2><ul>
<li>原理：#define 作为预处理指令，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。typedef 是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用 typedef 。</li>
<li>功能：typedef 用来定义类型的别名，方便使用。#define 不仅可以为类型取别名，还可以定义常量、变量、编译开关等。</li>
<li>作用域：#define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而 typedef 有自己的作用域。</li>
<li>指针的操作：typedef 和 #define 在处理指针时不完全一样</li>
</ul>
<pre><code class="cpp">#include &lt;iostream&gt;
#define INTPTR1 int *
typedef int * INTPTR2;

using namespace std;

int main()
&#123;
    INTPTR1 p1, p2; // p1: int *; p2: int
    INTPTR2 p3, p4; // p3: int *; p4: int *

    int var = 1;
    const INTPTR1 p5 = &amp;var; // 相当于 const int * p5; 常量指针，即不可以通过 p5 去修改 p5 指向的内容，但是 p5 可以指向其他内容。
    const INTPTR2 p6 = &amp;var; // 相当于 int * const p6; 指针常量，不可使 p6 再指向其他内容。
    
    return 0;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00bcd4">
                C++
            </a>
        </span>
        
    </div>
    <a href="/2023/03/05/C++%E9%9D%A2%E7%BB%8F/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    <div class="prev">
        
    </div>
    <div class="page-index">
        
        <span class="current">1</span>
        
        <span>
            <a class="page-num" href="/page/2/">2</a>
            
            
        </span>
        
    </div>
    <div class="next">
        
        <a class="page-num" href="/page/2/">
            <i class="fa-solid fa-caret-right fa-fw"></i>
        </a>
        
    </div>
</div>

    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">AdventureYX</div>
        <div class="description">
            <p>Description<br>…</p>

        </div>
        
        <div class="icon-links">
            
            <span class="icon-link">
                <a href="/function%20link()%20%7B%20%5Bnative%20code%5D%20%7D">
                    <i
                        class="fa- fa- fa-fw"
                    ></i>
                </a>
            </span>
            
        </div>
        
        
    </div>
</div>

    </div>
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 Adventure
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;AdventureYX
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
    </body>
</html>
