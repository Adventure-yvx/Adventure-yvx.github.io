{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"操作系统\" tag",
    "description": "",
    "home_page_url": "https://adventure-yx.github.io",
    "items": [
        {
            "id": "https://adventure-yx.github.io/2023/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%97%E5%A4%A72023%EF%BC%89/",
            "url": "https://adventure-yx.github.io/2023/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%97%E5%A4%A72023%EF%BC%89/",
            "title": "操作系统（南大2023）",
            "date_published": "2023-03-15T09:56:33.000Z",
            "content_html": "<p>南京大学 2023《操作系统：设计与实现》- 蒋炎岩</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVh4NHkxVjdKWg==\">https://www.bilibili.com/video/BV1Xx4y1V7JZ</span></p>\n<h1 id=\"操作系统概述\"><a class=\"markdownIt-Anchor\" href=\"#操作系统概述\">#</a> 操作系统概述</h1>\n<h2 id=\"什么是操作系统\"><a class=\"markdownIt-Anchor\" href=\"#什么是操作系统\">#</a> 什么是操作系统？</h2>\n<blockquote>\n<p>Operating System: A body of software, in fact, that is responsible for making it easy to run programs(even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that.     ——《OSTEP》</p>\n</blockquote>\n<p>操作系统发展历程：……</p>\n<p><strong>今天的操作系统：通过 “虚拟化硬件” 资源为程序运行提供服务的软件</strong></p>\n<ul>\n<li>更复杂的的处理器和内存\n<ul>\n<li>非对称对处理器（ARM big.LITTLE；Intel P/E-cores）</li>\n<li>Non-uniform Memory Access (NUMA)</li>\n<li>更多的硬件机制</li>\n</ul>\n</li>\n<li>更多的设备和资源\n<ul>\n<li>网卡、SSD、GPU、FPGA……</li>\n</ul>\n</li>\n<li>复杂的应用需求和应用环境\n<ul>\n<li>服务器、个人电脑、智能手机、手环、IoT……</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"理解操作系统\"><a class=\"markdownIt-Anchor\" href=\"#理解操作系统\">#</a> 理解操作系统</h2>\n<p>三个根本问题：</p>\n<ol>\n<li>操作系统服务谁？\n<ul>\n<li><strong>程序 = 状态机</strong></li>\n<li>本课程涉及：多线程 Linux 应用程序</li>\n</ul>\n</li>\n<li>操作系统为程序提供什么服务？（设计 / 应用视角）\n<ul>\n<li><strong>操作系统 = 对象 + API</strong></li>\n<li>本课程涉及：POSIX + 部分 Linux 特性</li>\n</ul>\n</li>\n<li>如何实现操作系统提供的服务（实现 / 硬件视角）？\n<ul>\n<li><strong>操作系统 = C 程序</strong>\n<ul>\n<li>完成初始化后就成为 interrupt/trap/fault handler</li>\n</ul>\n</li>\n<li>本课程涉及：xv6，自制迷你操作系统</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"应用视角的操作系统\"><a class=\"markdownIt-Anchor\" href=\"#应用视角的操作系统\">#</a> 应用视角的操作系统</h1>\n<p><strong>背景回顾</strong>：操作系统有三条主线：“软件 (应用)”、“硬件 (计算机)”、“操作系统 (软件直接访问硬件带来麻烦太多而引入的中间件)”。想要理解操作系统，对操作系统的服务对象 (应用程序) 有精确的理解是必不可少的。</p>\n<p>操作系统 = 对象 + API (应用视角 / 设计) = C 程序 (硬件视角 / 实现)</p>\n<p><strong>本讲内容</strong>：指令序列和高级语言的状态机模型；回答以下问题：</p>\n<ul>\n<li>什么是软件 (程序)？</li>\n<li>如何在操作系统上构造最小 / 一般 / 图形界面应用程序？</li>\n<li>什么是编译器？编译器把一段程序翻译成什么样的指令序列才算 “正确”？</li>\n</ul>\n<h2 id=\"什么是程序源代码视角\"><a class=\"markdownIt-Anchor\" href=\"#什么是程序源代码视角\">#</a> 什么是程序（源代码视角）</h2>\n<p><strong>C 程序的状态机模型</strong>（语义，semantics）</p>\n<ul>\n<li>状态 = 堆 + 栈</li>\n<li>初始状态 = main 的第一条语句</li>\n<li>迁移 = 执行一条简单语句\n<ul>\n<li>任何 C 程序都可以改写成 “非复合语句” 的 C 代码</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>这还只是粗浅的理解</p>\n<p>任何真正的理解都应该落实到可以执行的代码</p>\n</blockquote>\n<ul>\n<li>状态 = stack frame 的列表（每个 frame 有 PC）+ 全局变量</li>\n<li>初始状态 = main (argc, argv), 全局变量初始化</li>\n<li>迁移 = 执行 top stack frame PC 的语句；PC++（PC 是计数器，存下一条指令地址）\n<ul>\n<li>函数调用 = push frame (frame.PC = 入口)</li>\n<li>函数返回 = pop frame</li>\n</ul>\n</li>\n</ul>\n<p>C 语言程序是由很多栈帧组成的，每次函数调用创建一个新的栈帧</p>\n<p>应用：将任何递归程序就地转为非递归（还是一样的 call ()，但放入不同的 frame）</p>\n<h2 id=\"什么是程序二进制代码视角\"><a class=\"markdownIt-Anchor\" href=\"#什么是程序二进制代码视角\">#</a> 什么是程序（二进制代码视角）</h2>\n<ul>\n<li>状态 = 内存 M + 寄存器 R</li>\n<li>初始状态</li>\n<li>迁移 = 执行一条指令</li>\n</ul>\n<p>操作系统上的程序</p>\n<ul>\n<li>所有的指令都只能<strong>计算</strong>\n<ul>\n<li>deterministic: mov, add, sub, call…</li>\n<li>non-deterministic: rdrand …</li>\n<li>但这些指令甚至都无法使程序停下来（NEMU：加条 trap 指令）</li>\n</ul>\n</li>\n<li>一条特殊的指令：调用操作系统 <code>syscall</code>\n<ul>\n<li>把（M,R）完全交给操作系统，任其修改</li>\n<li>实现与操作系统中的其它对象交互\n<ul>\n<li>读写文件 / 操作系统状态（例如把文件内容写入 M）</li>\n<li>改变进程（运行中状态机）的状态，例如创建进程 / 销毁自己</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>程序 = 计算 + syscall</strong></li>\n</ul>\n<h2 id=\"如何在程序的两个视角之间切换\"><a class=\"markdownIt-Anchor\" href=\"#如何在程序的两个视角之间切换\">#</a> 如何在程序的两个视角之间切换</h2>\n<p><strong>编译器</strong>：源代码 S（状态机） → 二进制代码 C（状态机）</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>C</mi><mo>=</mo><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>e</mi><mtext>（</mtext><mi>S</mi><mtext>）</mtext></mrow><annotation encoding=\"application/x-tex\">C = complie（S）\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">e</span><span class=\"mord cjk_fallback\">（</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord cjk_fallback\">）</span></span></span></span></span></p>\n<h2 id=\"操作系统中的一般程序\"><a class=\"markdownIt-Anchor\" href=\"#操作系统中的一般程序\">#</a> 操作系统中的一般程序</h2>\n<p>系统中常见的应用程序</p>\n<ul>\n<li>\n<p>Core Utilities(coreutils)</p>\n<ul>\n<li>standard programs for text and file manipulation</li>\n<li>系统中安装的是 GNU Coreutils</li>\n</ul>\n</li>\n<li>\n<p>系统 / 工具程序</p>\n<ul>\n<li>bash, binutils, apt, ip, ssh, vim, tmux, jdk, python, …</li>\n</ul>\n</li>\n<li>\n<p>其他应用程序</p>\n<ul>\n<li>浏览器、音乐播放器</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>面试题 (1)：一个普通的、人畜无害的 Hello World C 程序执行的第一条指令在哪里？</p>\n</blockquote>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>gdb a.out</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> start</pre></td></tr></table></figure><p>main () 之前发生了什么？</p>\n<p><code>ld-linux-x86-64.so</code>  加载了 libc</p>\n<p>之后 libc 完成了自己的初始化</p>\n<ul>\n<li>RTFM: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9odXJkL2dsaWJjL3N0YXJ0dXAuaHRtbA==\">libc startup</span> on Hurd</li>\n<li><code>main()</code>  的开始 / 结束并不是整个程序的开始 / 结束</li>\n<li>例子：hello-goodbye.c</li>\n</ul>\n<blockquote>\n<p>面试题 (2)：main 执行之前、执行中、执行后，发生了哪些操作系统 API 调用？</p>\n</blockquote>\n<blockquote>\n<p>In general, trace refers to the process of following <em>anything</em> from the beginning to the end. For example, the  <code>traceroute</code>  command follows each of the network hops as your computer connects to another computer.</p>\n</blockquote>\n<p>这门课中很重要的工具：strace</p>\n<ul>\n<li>system call trace</li>\n<li>理解程序运行时使用的系统调用\n<ul>\n<li>demo:  <code>strace ./hello-goodbye</code></li>\n<li>在这门课中，你能理解 strace 的输出并在你自己的操作系统里实现相当一部分系统调用 (mmap, execve, …)</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>本质上，所有程序都和 Hello World 类似</p>\n<p>程序 = 状态机 = 计算 → syscall → 计算 →</p>\n<ul>\n<li>被操作系统加载\n<ul>\n<li>通过另一个进程执行 execve 设置为初始状态</li>\n</ul>\n</li>\n<li>状态机执行\n<ul>\n<li>进程管理：fork, execve, exit, …</li>\n<li>文件 / 设备管理：open, close, read, write, …</li>\n<li>存储管理：mmap, brk, …</li>\n</ul>\n</li>\n<li>直到 _exit (exit_group) 退出</li>\n</ul>\n<hr>\n<p>(初学者对这一点会感到有一点惊讶)</p>\n<p>说好的浏览器、游戏、杀毒软件、病毒呢？都是这些 API 吗</p>\n<p>Yes! - 这些 API 就是操作系统的全部</p>\n<p>编译器 (gcc)，代表其他工具程序</p>\n<ul>\n<li>\n<p>主要的系统调用：execve, read, write</p>\n</li>\n<li>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">strace</span> <span class=\"token parameter variable\">-f</span> gcc a.c</pre></td></tr></table></figure><p>(gcc 会启动其他进程)</p>\n<ul>\n<li>可以管道给编辑器  <code>vim -</code></li>\n<li>编辑器里还可以  <code>%!grep</code>  (细节 / 技巧)</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>图形界面程序 (xedit)，代表其他图形界面程序 (例如 vscode)</p>\n<ul>\n<li>\n<p>主要的系统调用：poll, recvmsg, writev</p>\n</li>\n<li>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">strace</span> xedit</pre></td></tr></table></figure><ul>\n<li>图形界面程序和 X-Window 服务器按照 X11 协议通信</li>\n<li>虚拟机中的 xedit 将 X11 命令通过 ssh (X11 forwarding) 转发到 Host</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>本次课回答的问题</p>\n<ul>\n<li>\n<p><strong>Q</strong>: 到底什么是 “程序”？</p>\n</li>\n<li>\n<p>程序 = 状态机</p>\n<ul>\n<li>源代码 <em>S</em>: 状态迁移 = 执行语句</li>\n<li>二进制代码 <em>C</em>: 状态迁移 = 执行指令</li>\n<li>编译器 C = compile (S)</li>\n</ul>\n</li>\n<li>\n<p>应用视角的操作系统</p>\n<ul>\n<li><strong>就是一条 syscall 指令</strong></li>\n</ul>\n</li>\n<li>\n<p>计算机系统不存在玄学；一切都建立在确定的机制上</p>\n<ul>\n<li>理解操作系统的重要工具：gcc, binutils, gdb, strace</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"硬件视角的操作系统\"><a class=\"markdownIt-Anchor\" href=\"#硬件视角的操作系统\">#</a> 硬件视角的操作系统</h1>\n<p><strong>本讲内容</strong>：计算机硬件的状态机模型；回答以下问题：</p>\n<ul>\n<li>什么是计算机硬件？</li>\n<li>计算机硬件和程序员之间是如何约定的？</li>\n<li>听说操作系统也是程序。那到底是鸡生蛋还是蛋生鸡？</li>\n</ul>\n<blockquote>\n<p>状态机复习</p>\n<p>数字逻辑电路：</p>\n<ul>\n<li>状态 = 寄存器保存的值（flip-flop）</li>\n<li>初始状态 = RESET (implementation dependent)</li>\n<li>迁移 = 组合逻辑电路计算寄存器下一周期的值</li>\n</ul>\n</blockquote>\n<p>数字系统本身是状态机</p>\n<p>所有的程序都是运行在数字系统上的，<strong>程序也是状态机</strong></p>\n<h1 id=\"调试理论与实践\"><a class=\"markdownIt-Anchor\" href=\"#调试理论与实践\">#</a> 调试理论与实践</h1>\n<h2 id=\"调试理论\"><a class=\"markdownIt-Anchor\" href=\"#调试理论\">#</a> 调试理论</h2>\n<p><strong>本讲内容</strong>：调试理论：Fault, Error 和 Failure；GDB 使用技巧。</p>\n<p>“软件” 的两层含义</p>\n<ul>\n<li>人类需求在信息世界的投影\n<ul>\n<li>理解错需求 → bug</li>\n</ul>\n</li>\n<li>计算过程的精确 (数学) 描述\n<ul>\n<li>实现错误 → bug</li>\n</ul>\n</li>\n</ul>\n<p>调试 (debugging)</p>\n<ul>\n<li>已知程序有 bug，如何找到？</li>\n</ul>\n<p><strong>调试困难的根本原因</strong></p>\n<p>因为 bug 的触发经历了漫长的过程</p>\n<ul>\n<li>需求 → 设计 → 代码 (状态机) → Fault (bug) → Error (程序状态错) → Failure\n<ul>\n<li>我们只能观测到 failure (可观测的结果错)</li>\n<li>我们可以检查状态的正确性 (但非常费时)</li>\n<li>无法预知 bug 在哪里 (每一行 “看起来” 都挺对的)</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>调试理论：如果我们能判定任意程序状态的正确性，那么给定一个 failure，我们可以通过二分查找定位到第一个 error 的状态，此时的代码就是 fault (bug)。</p>\n</blockquote>\n<p>调试理论：推论</p>\n<ul>\n<li>\n<p>为什么我们喜欢 “单步调试”？</p>\n<ul>\n<li>从一个假定正确的状态出发</li>\n<li>每个语句的行为有限，容易判定是否是 error</li>\n</ul>\n</li>\n<li>\n<p>为什么调试理论看起来很没用？</p>\n<ul>\n<li>\n<p>因为判定程序状态的正确性非常困难</p>\n<p>(是否在调试 DP 题 / 图论算法时陷入时间黑洞？)</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>实际中的调试：观察状态机执行 (trace) 的某个侧面</p>\n<ul>\n<li>缩小错误状态 (error) 可能产生的位置</li>\n<li>作出适当的假设</li>\n<li>再进行细粒度的定位和诊断</li>\n</ul>\n<p><strong>最重要的两个工具</strong></p>\n<ul>\n<li>printf → 自定义 log 的 trace\n<ul>\n<li>灵活可控、能快速定位问题大概位置、适用于大型软件</li>\n<li>无法精确定位、大量的 logs 管理起来比较麻烦</li>\n</ul>\n</li>\n<li>gdb → 指令 / 语句级 trace\n<ul>\n<li>精确、指令级定位、任意查看程序内部状态</li>\n<li>耗费大量时间</li>\n</ul>\n</li>\n</ul>\n<p>调试理论给了大家在遇到 “任何问题” 时候 self-check 的列表：</p>\n<ol>\n<li>是怎样的程序 (状态机) 在运行？</li>\n<li>我们遇到了怎样的 failure？</li>\n<li>我们能从状态机的运行中从易到难得到什么信息？</li>\n<li>如何二分检查这些信息和 error 之间的关联？</li>\n</ol>\n<h2 id=\"编程基本准则回顾\"><a class=\"markdownIt-Anchor\" href=\"#编程基本准则回顾\">#</a> 编程基本准则：回顾</h2>\n<blockquote>\n<p>Programs are meant to be read by humans (AIs) and only incidentally for computers to execute. — <em>D. E. Knuth</em></p>\n<p>(程序首先是拿给人读的，其次才是被机器执行。)</p>\n</blockquote>\n<p>好的程序</p>\n<ul>\n<li>\n<p>不言自明：能知道是做什么的 (specification)</p>\n<ul>\n<li>因此代码风格很重要</li>\n</ul>\n</li>\n<li>\n<p>不言自证：能确认代码和 specification 一致</p>\n<ul>\n<li>因此代码中的逻辑流很重要</li>\n</ul>\n</li>\n<li>\n<p>人类新纪元的评判标准</p>\n<ul>\n<li>AI 是否能正确理解 / 维护你的代码</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"调试理论的最重要应用\"><a class=\"markdownIt-Anchor\" href=\"#调试理论的最重要应用\">#</a> 调试理论的最重要应用</h2>\n<blockquote>\n<p>写好读、易验证的代码</p>\n<p>在代码中添加更多的断言 (assertions)</p>\n</blockquote>\n<p>断言的意义</p>\n<ul>\n<li>把代码中隐藏的 specification 写出来\n<ul>\n<li>Fault → Error (靠测试)</li>\n<li>Error → Failure (靠断言)\n<ul>\n<li>Error 暴露的越晚，越难调试</li>\n<li>追溯导致 assert failure 的变量值 (slice) 通常可以快速定位到 bug</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"gdb\"><a class=\"markdownIt-Anchor\" href=\"#gdb\">#</a> GDB</h2>\n<h1 id=\"python-建模操作系统\"><a class=\"markdownIt-Anchor\" href=\"#python-建模操作系统\">#</a> Python 建模操作系统</h1>\n<h1 id=\"并发\"><a class=\"markdownIt-Anchor\" href=\"#并发\">#</a> = 并发 =</h1>\n<h1 id=\"多处理器编程\"><a class=\"markdownIt-Anchor\" href=\"#多处理器编程\">#</a> 多处理器编程</h1>\n<h2 id=\"并发-2\"><a class=\"markdownIt-Anchor\" href=\"#并发-2\">#</a> 并发</h2>\n<blockquote>\n<p>Concurrent: existing, happening, or done <em>at the same time</em>.</p>\n<p>In computer science, concurrency refers to the ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in partial order, without affecting the final outcome. (Wikipedia)</p>\n</blockquote>\n<p>操作系统作为 “状态机的管理者”，引入了共享的状态</p>\n<ul>\n<li>带来了并发</li>\n<li>(操作系统是最早的并发程序)</li>\n</ul>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">Tprint</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    sys_write<span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f'</span><span class=\"token interpolation\"><span class=\"token punctuation\">&#123;</span>name<span class=\"token punctuation\">&#125;</span></span><span class=\"token string\">'</span></span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">for</span> name <span class=\"token keyword\">in</span> <span class=\"token string\">'AB'</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        sys_spawn<span class=\"token punctuation\">(</span>Tprint<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><ul>\n<li>使用 model checker 绘制状态图</li>\n</ul>\n<hr>\n<p><strong>多线程共享内存并发</strong></p>\n<p>线程：共享内存的执行流</p>\n<ul>\n<li>执行流拥有独立的堆栈 / 寄存器</li>\n</ul>\n<p>简化的线程 API (thread.h)</p>\n<ul>\n<li><code>spawn(fn)</code>\n<ul>\n<li>创建一个入口函数是 <code>fn</code>  的线程，并立即开始执行\n<ul>\n<li><code>void fn(int tid) &#123; ... &#125;</code></li>\n<li>参数  <code>tid</code>  从 1 开始编号</li>\n</ul>\n</li>\n<li>行为： <code>sys_spawn(fn, tid)</code></li>\n</ul>\n</li>\n<li><code>join()</code>\n<ul>\n<li>等待所有运行线程的返回 (也可以不调用)</li>\n<li>行为： <code>while (done != T) sys_sched()</code></li>\n</ul>\n</li>\n</ul>\n<p>多处理器编程：一个 API 搞定</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"thread.h\"</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Ta</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Tb</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token function\">create</span><span class=\"token punctuation\">(</span>Ta<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token function\">create</span><span class=\"token punctuation\">(</span>Tb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ul>\n<li>这个程序可以利用系统中的多处理器\n<ul>\n<li>操作系统会自动把线程放置在不同的处理器上</li>\n<li>CPU 使用率超过了 100%</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"原子性互斥\"><a class=\"markdownIt-Anchor\" href=\"#原子性互斥\">#</a> 原子性 (互斥)</h2>\n<h2 id=\"执行顺序\"><a class=\"markdownIt-Anchor\" href=\"#执行顺序\">#</a> 执行顺序</h2>\n<h2 id=\"处理器间的可见性\"><a class=\"markdownIt-Anchor\" href=\"#处理器间的可见性\">#</a> 处理器间的可见性</h2>\n<h1 id=\"并发控制基础\"><a class=\"markdownIt-Anchor\" href=\"#并发控制基础\">#</a> 并发控制基础</h1>\n<p><strong>背景回顾</strong>：虽然 “线程库” 入门简单，但多处理器编程 + 编译优化会给我们带来很多意想不到的惊喜。在编写多线程程序时，必须放弃许多对顺序程序编程时的基本假设，这也是并发编程困难的原因。</p>\n<p><strong>本讲内容</strong>：并发编程困难不代表我们只能摆烂 —— 我们还可以创造出新的手段，帮助我们编写正确的并发程序：</p>\n<ul>\n<li>互斥问题和 Peterson 算法</li>\n<li>Peterson 算法的正确性和模型检验</li>\n<li>Peterson 算法在现代多处理器系统上的实现</li>\n<li>实现并发控制的硬件和编译器机制</li>\n</ul>\n<h2 id=\"peterson算法\"><a class=\"markdownIt-Anchor\" href=\"#peterson算法\">#</a> Peterson 算法</h2>\n<p>在共享内容上实现互斥</p>\n<h2 id=\"模型验证model-checker\"><a class=\"markdownIt-Anchor\" href=\"#模型验证model-checker\">#</a> 模型验证 (model checker)</h2>\n<h2 id=\"原子指令\"><a class=\"markdownIt-Anchor\" href=\"#原子指令\">#</a> 原子指令</h2>\n<p>并发编程困难的解决：普通的变量读写在编译器 + 处理器的双重优化下行为变得复杂</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>retry<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>locked <span class=\"token operator\">!=</span> UNLOCK<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">goto</span> retry<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  locked <span class=\"token operator\">=</span> LOCK<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>解决方法：编译器和硬件共同提供不可优化、不可打断的指令</p>\n<ul>\n<li>“原子指令” + compiler barrier</li>\n</ul>\n<h1 id=\"并发控制互斥\"><a class=\"markdownIt-Anchor\" href=\"#并发控制互斥\">#</a> 并发控制：互斥</h1>\n<p><strong>背景回顾</strong>：互斥 (Peterson 算法)：为了掌控并发程序的复杂行为，使程序退回到 “串行执行” 的 lock &amp; unlock。</p>\n<p><strong>本讲内容</strong>：现代多处理器系统上的互斥实现：</p>\n<ul>\n<li>互斥问题的定义和假设</li>\n<li>自旋锁</li>\n<li>互斥锁和 Futex</li>\n</ul>\n<p>review：并发编程（理解并发的工具）</p>\n<ul>\n<li>线程 = 人 (大脑能完成局部存储和计算)</li>\n<li>共享内存 = 物理世界 (物理世界天生并行)</li>\n<li>一切都是状态机 (debugger &amp; model checker)</li>\n</ul>\n<h2 id=\"互斥问题\"><a class=\"markdownIt-Anchor\" href=\"#互斥问题\">#</a> 互斥问题</h2>\n<p>互斥 (mutual exclusion)，“互相排斥”</p>\n<ul>\n<li>\n<p>实现  <code>lock_t</code>  数据结构和  <code>lock/unlock</code>  API:</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span> <span class=\"token class-name\">lock_t</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>lk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>lk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>一把 “排他性” 的锁 —— 对于锁对象  <code>lk</code></p>\n</li>\n<li>\n<p>如果某个线程持有锁，则其他线程的  <code>lock</code>  不能返回 (Safety)</p>\n</li>\n<li>\n<p>在多个线程执行  <code>lock</code>  时，至少有一个可以返回 (Liveness)</p>\n</li>\n<li>\n<p>能<strong>正确处理处理器乱序、宽松内存模型和编译优化</strong></p>\n</li>\n</ul>\n<h1 id=\"并发控制同步\"><a class=\"markdownIt-Anchor\" href=\"#并发控制同步\">#</a> 并发控制：同步</h1>\n<p><strong>背景回顾</strong>：我们已经了解如何通过 “不可优化、保证顺序” 的原子指令实现自旋锁，以及借助操作系统 (系统调用) 实现线程的睡眠，从而不致于出现 CPU 空转的浪费。然而，互斥并不总是能满足多个并发线程协作完成任务的需求，例如大家试着在完成 Minilab 时应该已经遇到了一些困难。如何能便捷地让共享内存的线程协作以共同完成计算任务？</p>\n<p><strong>本讲内容</strong>：并发控制：同步</p>\n<ul>\n<li>同步问题的定义</li>\n<li>生产者 - 消费者问题</li>\n<li>条件变量</li>\n<li>信号量</li>\n<li>信号量适合解决什么问题</li>\n<li>哲学家吃饭问题</li>\n</ul>\n<h2 id=\"同步问题\"><a class=\"markdownIt-Anchor\" href=\"#同步问题\">#</a> 同步问题</h2>\n<p>同步 (Synchronization)：两个或两个以上随时间变化的量在变化过程中保持一定的相对关系。</p>\n<h1 id=\"真实世界的并发编程\"><a class=\"markdownIt-Anchor\" href=\"#真实世界的并发编程\">#</a> 真实世界的并发编程</h1>\n<p><strong>背景回顾</strong>：我们已经掌握了多种并发控制技术：自旋锁、互斥锁、条件变量、信号量。我们已经可以实现共享内存系统上的任意并发 / 并行计算。然而，大家也在使用这些 “底层” 并发控制时发现使用的困难。那么，真实世界的程序员是怎么实现并发程序的？</p>\n<p><strong>本讲内容</strong>：(本节为科普) 并发编程模型与底层同步机制的封装</p>\n<ul>\n<li>高性能计算中的并行编程 (embarrassingly parallel 的数值计算)</li>\n<li>数据中心中的并发编程 (协程、Goroutine 和 channel)</li>\n<li>人工智能时代的分布式机器学习 (GPU 和 Parameter Server)</li>\n<li>用户身边的并发编程 (Web 和异步编程)</li>\n</ul>\n<h1 id=\"并发-bugs\"><a class=\"markdownIt-Anchor\" href=\"#并发-bugs\">#</a> 并发 Bugs</h1>\n<p><strong>常见的并发 bugs</strong></p>\n<ul>\n<li>死锁</li>\n<li>数据竞争</li>\n<li>原子性和顺序违反</li>\n</ul>\n<h1 id=\"并发-bug-的应对\"><a class=\"markdownIt-Anchor\" href=\"#并发-bug-的应对\">#</a> 并发 Bug 的应对</h1>\n<p><strong>背景回顾</strong>：我们在编写并发程序时，难免会遇到死锁、数据竞争、原子性 / 顺序违反等类型的并发 bugs。即便我们知道它们的定义和触发条件，直接在编程时消灭它们依然是十分困难的。以数据竞争为例，它的定义貌似简单：两个线程同时访问同一内存地址，并且至少有一个是写。但 “访问内存” 则可能出其不意 —— 例如 ret 指令和栈上数据的修改产生的数据竞争。那么，我们应该如何应对这些并发 bugs？</p>\n<p><strong>本讲内容</strong>：<strong>一节真正的 “编程” 课</strong>：如何正确地 (并发) 编程：</p>\n<ul>\n<li>Lock ordering</li>\n<li>防御性编程</li>\n<li>运行时检查</li>\n</ul>\n<h1 id=\"多处理器系统与中断机制\"><a class=\"markdownIt-Anchor\" href=\"#多处理器系统与中断机制\">#</a> 多处理器系统与中断机制</h1>\n<p><strong>背景回顾</strong>：我们已经了解并发编程实践需要的几乎全部内容 —— 线程、内存模型、互斥、同步和并发 bugs 的应对。但我们一直是在简化的线程模型 (thread.h) 上讲解的。但我们还没有回答一个关键问题：线程到底在计算机硬件上是如何实现的？即便系统中只有一个处理器，我们依然可以创建很多并发执行的线程。</p>\n<p><strong>本讲内容</strong>：操作系统内核实现</p>\n<ul>\n<li>多处理器和中断</li>\n<li>AbstractMachine API</li>\n<li>50 行实现嵌入式操作系统</li>\n</ul>\n<h1 id=\"虚拟化\"><a class=\"markdownIt-Anchor\" href=\"#虚拟化\">#</a> = 虚拟化 =</h1>\n<h1 id=\"操作系统上的进程\"><a class=\"markdownIt-Anchor\" href=\"#操作系统上的进程\">#</a> 操作系统上的进程</h1>\n<p><strong>背景回顾</strong>：有关状态机、并发和中断的讨论给我们真正理解操作系统奠定了基础，现在我们正式进入操作系统和应用程序的 “边界” 了。让我们把视角回到单线程应用程序，即 “执行计算指令和系统调用指令的状态机”，开始对操作系统和进程的讨论。</p>\n<p><strong>本讲内容</strong>：操作系统上的进程</p>\n<ul>\n<li>线程、进程和操作系统</li>\n<li>UNIX/Linux 进程管理 API</li>\n</ul>\n<h2 id=\"进程process线程\"><a class=\"markdownIt-Anchor\" href=\"#进程process线程\">#</a> 进程（Process）&amp; 线程（）</h2>\n<blockquote>\n<p>进程映像（静态）由程序段，数据段和进程控制块 (PCB) 组成</p>\n<p>进程（动态）是具有独立功能的程序在一个数据集合上运行的过程</p>\n<p>进程是系统进行资源分配基本单位，线程是处理机分配的基本单元。</p>\n</blockquote>\n<p>进程状态：</p>\n<ul>\n<li>运行态</li>\n<li>就绪态</li>\n<li>阻塞态</li>\n<li>创建态</li>\n<li>结束态</li>\n</ul>\n<blockquote>\n<p>线程即 “轻量型进程”，他是一个基本的 CPU 执行单元，是程序执行流的最小单元。</p>\n<p>线程由线程 ID、程序计数器、寄存器集合和堆栈组成。</p>\n<p>线程自己不拥有资源，和同一进程的其他线程共享进程的所有资源。</p>\n</blockquote>\n<p><strong>引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量；</strong></p>\n<p><strong>引入线程的目的是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</strong></p>\n<h1 id=\"linux-操作系统\"><a class=\"markdownIt-Anchor\" href=\"#linux-操作系统\">#</a> Linux 操作系统</h1>\n<h1 id=\"进程的地址空间\"><a class=\"markdownIt-Anchor\" href=\"#进程的地址空间\">#</a> 进程的地址空间</h1>\n<h1 id=\"系统调用和-unix-shell\"><a class=\"markdownIt-Anchor\" href=\"#系统调用和-unix-shell\">#</a> 系统调用和 UNIX Shell</h1>\n<h1 id=\"c-标准库的实现\"><a class=\"markdownIt-Anchor\" href=\"#c-标准库的实现\">#</a> C 标准库的实现</h1>\n<h1 id=\"可执行文件的加载\"><a class=\"markdownIt-Anchor\" href=\"#可执行文件的加载\">#</a> 可执行文件的加载</h1>\n<h1 id=\"处理器调度\"><a class=\"markdownIt-Anchor\" href=\"#处理器调度\">#</a> 处理器调度</h1>\n<h1 id=\"进程-线程与系统调用\"><a class=\"markdownIt-Anchor\" href=\"#进程-线程与系统调用\">#</a> 进程、线程与系统调用</h1>\n<h1 id=\"持久化\"><a class=\"markdownIt-Anchor\" href=\"#持久化\">#</a> = 持久化 =</h1>\n<h1 id=\"存储设备原理\"><a class=\"markdownIt-Anchor\" href=\"#存储设备原理\">#</a> 存储设备原理</h1>\n<h1 id=\"输入输出设备\"><a class=\"markdownIt-Anchor\" href=\"#输入输出设备\">#</a> 输入输出设备</h1>\n<h1 id=\"设备驱动程序\"><a class=\"markdownIt-Anchor\" href=\"#设备驱动程序\">#</a> 设备驱动程序</h1>\n<h1 id=\"文件系统-api\"><a class=\"markdownIt-Anchor\" href=\"#文件系统-api\">#</a> 文件系统 API</h1>\n<h1 id=\"fat-和-unix-文件系统\"><a class=\"markdownIt-Anchor\" href=\"#fat-和-unix-文件系统\">#</a> FAT 和 UNIX 文件系统</h1>\n<h1 id=\"持久数据的可靠性\"><a class=\"markdownIt-Anchor\" href=\"#持久数据的可靠性\">#</a> 持久数据的可靠性</h1>\n",
            "tags": [
                "Linux",
                "操作系统"
            ]
        }
    ]
}