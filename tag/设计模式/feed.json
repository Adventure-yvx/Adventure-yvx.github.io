{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"设计模式\" tag",
    "description": "",
    "home_page_url": "https://adventure-yx.github.io",
    "items": [
        {
            "id": "https://adventure-yx.github.io/2023/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
            "url": "https://adventure-yx.github.io/2023/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
            "title": "设计模式",
            "date_published": "2023-03-20T12:10:48.000Z",
            "content_html": "<h1 id=\"设计模式概述\"><a class=\"markdownIt-Anchor\" href=\"#设计模式概述\">#</a> 设计模式概述</h1>\n<p><strong>什么是设计模式？</strong></p>\n<p>“每一个模式描述了一个在我们周围不断重复发生的问题， 以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。 ——Christopher Alexander</p>\n<p><strong>23 种设计模式</strong></p>\n<ul>\n<li>创建型模式\n<ol>\n<li>单例模式（Singleton）</li>\n<li>简单工厂模式</li>\n<li>工厂模式（Factory Method）</li>\n<li>抽象工厂模式（Abstract Factory）</li>\n<li>生成器 / 建造者模式（Builder）</li>\n<li>原型模式（Prototype）</li>\n</ol>\n</li>\n<li>结构型模式\n<ol>\n<li>适配器模式（Adapter）</li>\n<li>桥接模式（Bridge)</li>\n<li>组合模式（Composite）</li>\n<li>装饰模式（Decorator）</li>\n<li>外观模式（Facade）</li>\n<li>享元模式（Flyweight）</li>\n<li>代理模式（Proxy）</li>\n</ol>\n</li>\n<li>行为模式\n<ol>\n<li>职责链模式（Chain of Responsibility）</li>\n<li>命令模式（Command）</li>\n<li>迭代器模式（Iterator）</li>\n<li>中介者模式（Mediator）</li>\n<li>备忘录模式（Memento）</li>\n<li>观察者模式（Observer）</li>\n<li>策略模式（Strategy）</li>\n<li>状态模式（State）</li>\n<li>模板方法模式（Template Method）</li>\n<li>访问者模式（Vistor）</li>\n</ol>\n</li>\n</ul>\n<p><strong>深入理解面向对象</strong></p>\n<ul>\n<li>底层思维：向下，如何把握机器底层从微观理解对象构造\n<ul>\n<li>语言构造</li>\n<li>编译转换</li>\n<li>内存模型</li>\n<li>运行时机制</li>\n</ul>\n</li>\n<li>抽象思维：向上，如何将我们的周围世界抽象为程序代码\n<ul>\n<li>面向对象\n<ul>\n<li>封装，隐藏内部实现</li>\n<li>继承，复用现有代码</li>\n<li>多态，改写对象行为</li>\n</ul>\n</li>\n<li>组件封装</li>\n<li>设计模式</li>\n<li>架构模式</li>\n</ul>\n</li>\n</ul>\n<p>软件设计固有的复杂性高</p>\n<p>软件设计复杂的根本原因：<strong>变化</strong></p>\n<ul>\n<li>客户需求的变化</li>\n<li>技术平台的变化</li>\n<li>开发团队的变化</li>\n<li>市场环境的变化</li>\n<li>……</li>\n</ul>\n<p>如何解决复杂性？</p>\n<ul>\n<li>\n<p>分解（结构化）</p>\n<p>人们面对复杂性有一个常见的做法：即分而治之，将大问题分 解为多个小问题，将复杂问题分解为多个简单问题。</p>\n</li>\n<li>\n<p>抽象（面向对象）</p>\n<p>更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。 由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节， 而去处理泛化和理想化了的对象模型。</p>\n</li>\n</ul>\n<p>软件设计的目标：<strong>复用</strong></p>\n<h1 id=\"uml类图\"><a class=\"markdownIt-Anchor\" href=\"#uml类图\">#</a> UML 类图</h1>\n<h1 id=\"面向对象设计原则\"><a class=\"markdownIt-Anchor\" href=\"#面向对象设计原则\">#</a> 面向对象设计原则</h1>\n<h1 id=\"创建型模式\"><a class=\"markdownIt-Anchor\" href=\"#创建型模式\">#</a> = 创建型模式 =</h1>\n<h1 id=\"单例模式singleton\"><a class=\"markdownIt-Anchor\" href=\"#单例模式singleton\">#</a> 单例模式（Singleton）</h1>\n<h1 id=\"简单工厂模式\"><a class=\"markdownIt-Anchor\" href=\"#简单工厂模式\">#</a> 简单工厂模式</h1>\n<h1 id=\"工厂模式factory-method\"><a class=\"markdownIt-Anchor\" href=\"#工厂模式factory-method\">#</a> 工厂模式（Factory Method）</h1>\n<h1 id=\"抽象工厂模式abstract-factory\"><a class=\"markdownIt-Anchor\" href=\"#抽象工厂模式abstract-factory\">#</a> 抽象工厂模式（Abstract Factory）</h1>\n<h1 id=\"生成器建造者模式builder\"><a class=\"markdownIt-Anchor\" href=\"#生成器建造者模式builder\">#</a> 生成器 / 建造者模式（Builder）</h1>\n<h1 id=\"原型模式prototype\"><a class=\"markdownIt-Anchor\" href=\"#原型模式prototype\">#</a> 原型模式（Prototype）</h1>\n<h1 id=\"结构型模式\"><a class=\"markdownIt-Anchor\" href=\"#结构型模式\">#</a> = 结构型模式 =</h1>\n<h1 id=\"适配器模式adapter\"><a class=\"markdownIt-Anchor\" href=\"#适配器模式adapter\">#</a> 适配器模式（Adapter）</h1>\n<h1 id=\"桥接模式bridge\"><a class=\"markdownIt-Anchor\" href=\"#桥接模式bridge\">#</a> 桥接模式（Bridge)</h1>\n<h1 id=\"组合模式composite\"><a class=\"markdownIt-Anchor\" href=\"#组合模式composite\">#</a> 组合模式（Composite）</h1>\n<h1 id=\"装饰模式decorator\"><a class=\"markdownIt-Anchor\" href=\"#装饰模式decorator\">#</a> 装饰模式（Decorator）</h1>\n<h1 id=\"外观模式facade\"><a class=\"markdownIt-Anchor\" href=\"#外观模式facade\">#</a> 外观模式（Facade）</h1>\n<h1 id=\"享元模式flyweight\"><a class=\"markdownIt-Anchor\" href=\"#享元模式flyweight\">#</a> 享元模式（Flyweight）</h1>\n<h1 id=\"代理模式proxy\"><a class=\"markdownIt-Anchor\" href=\"#代理模式proxy\">#</a> 代理模式（Proxy）</h1>\n<h1 id=\"行为模式\"><a class=\"markdownIt-Anchor\" href=\"#行为模式\">#</a> = 行为模式 =</h1>\n<h1 id=\"职责链模式chain-of-responsibility\"><a class=\"markdownIt-Anchor\" href=\"#职责链模式chain-of-responsibility\">#</a> 职责链模式（Chain of Responsibility）</h1>\n<h1 id=\"命令模式command\"><a class=\"markdownIt-Anchor\" href=\"#命令模式command\">#</a> 命令模式（Command）</h1>\n<h1 id=\"迭代器模式iterator\"><a class=\"markdownIt-Anchor\" href=\"#迭代器模式iterator\">#</a> 迭代器模式（Iterator）</h1>\n<h1 id=\"中介者模式mediator\"><a class=\"markdownIt-Anchor\" href=\"#中介者模式mediator\">#</a> 中介者模式（Mediator）</h1>\n<h1 id=\"备忘录模式memento\"><a class=\"markdownIt-Anchor\" href=\"#备忘录模式memento\">#</a> 备忘录模式（Memento）</h1>\n<h1 id=\"观察者模式observer\"><a class=\"markdownIt-Anchor\" href=\"#观察者模式observer\">#</a> 观察者模式（Observer）</h1>\n<h1 id=\"策略模式strategy\"><a class=\"markdownIt-Anchor\" href=\"#策略模式strategy\">#</a> 策略模式（Strategy）</h1>\n<h1 id=\"状态模式state\"><a class=\"markdownIt-Anchor\" href=\"#状态模式state\">#</a> 状态模式（State）</h1>\n<h1 id=\"模板方法模式template-method\"><a class=\"markdownIt-Anchor\" href=\"#模板方法模式template-method\">#</a> 模板方法模式（Template Method）</h1>\n<h1 id=\"访问者模式vistor\"><a class=\"markdownIt-Anchor\" href=\"#访问者模式vistor\">#</a> 访问者模式（Vistor）</h1>\n",
            "tags": [
                "C++",
                "设计模式"
            ]
        }
    ]
}