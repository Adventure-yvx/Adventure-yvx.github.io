{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"database\" tag",
    "description": "",
    "home_page_url": "https://adventure-yx.github.io",
    "items": [
        {
            "id": "https://adventure-yx.github.io/2023/04/20/CMU15-445%20Project1/",
            "url": "https://adventure-yx.github.io/2023/04/20/CMU15-445%20Project1/",
            "title": "CMU15-445：Project#1 Buffer Pool",
            "date_published": "2023-04-20T06:03:05.000Z",
            "content_html": "<h1 id=\"overview\"><a class=\"markdownIt-Anchor\" href=\"#overview\">#</a> Overview</h1>\n<ul>\n<li>本课程要求为 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2NtdS1kYi9idXN0dWI=\">BusTub</span> DBMS 实现一个新的面向磁盘的存储管理器 (disk-oriented storage manager)。这样的存储管理器假定数据库的主要存储位置是磁盘上。</li>\n<li>第一个编程项目是实现一个缓冲池 (buffer pool)。缓冲池负责将物理页从主存中来回移动到磁盘。它允许 DBMS 支持大于系统可用内存量的数据库。缓冲池的操作对系统的其他部分是透明 (transparent) 的。比如：系统使用其唯一的标识符 (page_id_t) 向缓冲池要 (ask) 一个页面，它不知道这个页面是否已经在内存中，或者系统是否必须从磁盘中检索它。</li>\n<li>注意：实现必须是线程安全的 (thread-safe)。多个线程都将同时访问数据结构，所以必须确保他们的关键部分收到 latch 的保护。（即：锁）</li>\n<li>我们需要在我们的存储管理器中实现以下 3 个部分：\n<ul>\n<li><a href=\"https://15445.courses.cs.cmu.edu/fall2022/project1/#extendible-hash-table\"><strong>Extendible Hash Table</strong></a></li>\n<li><a href=\"https://15445.courses.cs.cmu.edu/fall2022/project1/#lru-k-replacer\"><strong>LRU-K Replacement Policy</strong></a></li>\n<li><a href=\"https://15445.courses.cs.cmu.edu/fall2022/project1/#buffer-pool-instance\"><strong>Buffer Pool Manager Instance</strong></a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"project-specification\"><a class=\"markdownIt-Anchor\" href=\"#project-specification\">#</a> Project Specification</h1>\n<ul>\n<li>对此次任务实现的每个组件，都提供了包含所需要我们实现的 API 的存根类 (stub class)。我们不应该修改这些类中预先定义的函数签名 (function signatures)。如果修改了，用来评分的测试代码可能会被破坏。就评分不了了。</li>\n<li>如果一个类已经包含了数据成员，我们不应该删除它们。例如 <code>BufferPoolManagerInstance</code>  里面的 <code>DiskManager</code> ,  <code>ExtendibleHashTable</code>  和 <code>LRUKReplacer</code>  对象。这些都是实现系统其他部分所需要的功能所需要的。另一方面，我们可能要向这些类来添加数据成员，以便正确实现所需要的功能。也可以给这些类添加辅助函数。</li>\n<li>除非有规定，我们可以在项目中使用任何的 C++17 容器。可以自行选择。注意多线程安全和锁的使用，来保护它们。但是我们不能带入额外的第三方依赖，比如 boost。</li>\n</ul>\n<h1 id=\"extendible-hash-table\"><a class=\"markdownIt-Anchor\" href=\"#extendible-hash-table\">#</a> Extendible Hash Table</h1>\n<h2 id=\"task\"><a class=\"markdownIt-Anchor\" href=\"#task\">#</a> task</h2>\n<p>在这个项目的第一部分，我们将建立一个通用的哈希表，使用无序的桶 (unordered buckets) 来存储唯一的键值对 (key/value pairs)。<br>\n我们的哈希表必须支持</p>\n<ul>\n<li>插入 / 删除键值对的能力。</li>\n<li>我们无需指定表的最大 size，表应该可以根据需要逐步增加大小，但是我们不需要缩小表。也就是说，我们不需要实现对缩小或者压缩哈希表的功能。</li>\n<li>我们还需要支持检查一个键是否存在于哈希表中，并返回相应的值。</li>\n</ul>\n<p>在正式开始编程之前，建议先着手一些分割和目录增长的小例子。</p>\n<p>我们必须在项目源代码的指定文件中实现哈希表。而且只允许修改哈希表头文件 ( <code>src/include/container/hash/extendible_hash_table.h</code> ) 和对应的实现文件 ( <code>src/container/hash/extendible_hash_table.cpp</code> )。我们不需要修改任何其他文件，在视线中，我们不能在内部使用另一个内置哈希表。而且我们必须在 <code>ExtendibleHashTable</code>  类中实现以下函数：</p>\n<ul>\n<li>\n<p><code>Find(K, V)</code> : 给定键 K，检查它是否存在于哈希表中，如果存在，则在 V 中存储指向其对应值的指针并返回 true。如果键不存在，返回 false。</p>\n</li>\n<li>\n<p><code>Insert(K, V)</code> : 将键值对插入哈希表。如果 K 已经存在，则用新的值 V 覆盖其值，并返回 true。如果键值对不能被插入到桶中（因为桶已经满了，而且键没有更新现有的对），在重试之前做以下步骤：</p>\n<ol>\n<li>如果桶的本地深度 (local depth) 等于全局深度 (global depth)。递增全局深度。并将目录 (directory) 的大小增加一倍。</li>\n<li>增加桶的局部深度。</li>\n<li>分割桶。并重新分配目录指针和桶中的 K/V 对。</li>\n</ol>\n<p><strong>有限实现是在插入后，如果桶满了就分割桶，但是在这个项目中，请检测桶是否溢出，并在插入之前执行分割！</strong></p>\n</li>\n<li>\n<p><code>Remove(K)</code> ：给定 K, 从哈希表删除其对应的键值对，并返回 true。如果不存在，返回 false。</p>\n</li>\n<li>\n<p><code>GetGlobalDepth()</code> : 返回整个哈希表的当前全局深度。</p>\n</li>\n<li>\n<p><code>GetLocalDepth(dir_index)</code> ：返回给定目录索引所指向的桶的当前本地深度。</p>\n</li>\n<li>\n<p><code>GetNumBuckets()</code> : 返回在哈希表中分配的桶的总数。</p>\n</li>\n<li>\n<p>我们可以利用给定的 <code>IndexOf(K)</code>  的私有函数来计算一个给定键所切分的目录索引。此外，还提供了一个 Bucket 嵌套类，表示可扩展哈希表中的桶。通过遵循代码文档，首先完成 Bucket 类的 TODOs 可以让我们更容易实现 ``ExtendibleHashTable` 的 API。但也可以自由的表写我们自己的内部类和辅助函数。</p>\n</li>\n<li>\n<p>我们需要使用 <code>std::mutex</code>  确保哈希表中的所有操作都是线程安全的。如何保护数据机构由我们自己决定。</p>\n</li>\n</ul>\n<h2 id=\"可扩展哈希表原理\"><a class=\"markdownIt-Anchor\" href=\"#可扩展哈希表原理\">#</a> 可扩展哈希表原理</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvZXh0ZW5kaWJsZS1oYXNoaW5nLWR5bmFtaWMtYXBwcm9hY2gtdG8tZGJtcy8=\">Extendible Hashing (Dynamic approach to DBMS)</span></p>\n<blockquote>\n<p><strong>Extendible Hashing</strong> is a dynamic hashing method wherein directories, and buckets are used to hash data. It is an aggressively flexible method in which the hash function also experiences dynamic changes.</p>\n<p><strong>Extendible Hashing</strong> 是一种动态哈希方法，其中目录和桶被用于哈希数据。可扩展哈希是一个有力的灵活的方法，其中哈希函数也经历动态的改变。</p>\n</blockquote>\n<p><strong>Main features of Extendible Hashing</strong>: The main features in this hashing technique are:</p>\n<p><strong>Main features of Extendible Hashing</strong>:  在哈希技术中主要的特征如下：</p>\n<ul>\n<li>\n<p><strong>Directories:</strong> The directories store addresses of the buckets in pointers. An id is assigned to each directory which may change each time when Directory Expansion takes place.</p>\n<p><strong>目录:</strong> 目录在指针中存储桶的地址。每个目录被分配一个 <code>id</code>  ，每次目录扩张时， <code>id</code>  可能会发生变化。</p>\n</li>\n<li>\n<p><strong>Buckets:</strong> The buckets are used to hash the actual data.</p>\n<p><strong>桶:</strong> 桶被用于哈希真实的数据。</p>\n</li>\n</ul>\n<p><strong>Basic Structure of Extendible Hashing</strong></p>\n<p>可扩展哈希的基本结构</p>\n<p>![image-20230424230000782.png)</p>\n<p><strong>Frequently used terms in Extendible Hashing</strong></p>\n<p>在可扩展哈希中常用术语</p>\n<ul>\n<li 全局深度=\"\">\n<p><strong>Directories:</strong> These containers store pointers to buckets. Each directory is given a unique id which may change each time when expansion takes place. The hash function returns this directory id which is used to navigate to the appropriate bucket. Number of Directories = 2^Global Depth.</p>\n<p><strong>目录:</strong> 这个容器存储指向桶的指针。每个目录给定一个唯一的 id，当扩张发生时 <code>id</code>  可能随之改变。哈希函数返回这个目录的 id，这个 <code>id</code>  被用来指向合适的桶。目录的数量 = 2^</p>\n</li>\n<li>\n<p><strong>Buckets:</strong> They store the hashed keys. Directories point to buckets. A bucket may contain more than one pointers to it if its local depth is less than the global depth.</p>\n<p><strong>桶:</strong>  它们存储哈希键。目录指向桶。如果局部深度小于全局深度时，一个桶可能包含不止一个指针指向它。</p>\n</li>\n<li>\n<p><strong>Global Depth:</strong> It is associated with the Directories. They denote the number of bits which are used by the hash function to categorize the keys. Global Depth = Number of bits in directory id.</p>\n<p><strong>全局深度</strong>：它跟目录相关联。它们表示哈希函数使用的比特位数目去分类这些键。全局深度 = 目录 id 的比特位数。</p>\n</li>\n<li>\n<p><strong>Local Depth:</strong> It is the same as that of Global Depth except for the fact that Local Depth is associated with the buckets and not the directories. Local depth in accordance with the global depth is used to decide the action that to be performed in case an overflow occurs. Local Depth is always less than or equal to the Global Depth.</p>\n<p><strong>局部深度</strong>：和全局深度类似，除了局部深度是跟桶关联，而不是跟目录。当桶溢出发生时，局部深度根据全局深度去决定执行的行为。局部深度通常小于等于全局深度。</p>\n</li>\n<li>\n<p><strong>Bucket Splitting:</strong> When the number of elements in a bucket exceeds a particular size, then the bucket is split into two parts.</p>\n<p><strong>桶分裂</strong>：当桶的元素超过了特定的大小，那么桶分裂成两个部分。</p>\n</li>\n<li>\n<p><strong>Directory Expansion:</strong> Directory Expansion Takes place when a bucket overflows. Directory Expansion is performed when the local depth of the overflowing bucket is equal to the global depth.</p>\n<p><strong>目录扩容</strong>：当桶溢出时，产生目录扩容。当溢出桶的局部深度等于全局深度时，目录扩容被执行。</p>\n</li>\n</ul>\n<p><strong>Basic Working of Extendible Hashing</strong>:</p>\n<p>可扩展哈希基本工作流程</p>\n<p><img data-src=\"image-20230424230307442.png\" alt=\"image-20230424230307442\"></p>\n<ol>\n<li>\n<p><strong>Step 1 – Analyze Data Elements:</strong> Data elements may exist in various forms eg. Integer, String, Float, etc… Currently, let us consider data elements of type integer. eg: 49.</p>\n<p><strong>步骤 1 – 分析数据元素</strong>：数据元素可能以各种形式存在，比如整形，字符串，浮点数等等… 当前，我们考虑整形这类数据元素，比如 49。</p>\n</li>\n<li>\n<p><strong>Step 2 – Convert into binary format:</strong> Convert the data element in Binary form. For string elements, consider the ASCII equivalent integer of the starting character and then convert the integer into binary form. Since we have 49 as our data element, its binary form is 110001.</p>\n<p><strong>步骤 2 - 转换成二进制形式</strong>：将数据元素转换为二进制形式。对于字符串元素，考虑 ASCII 码起始字符的对应整数，然后转换成二进制形式。因为我们是将 49 作为数据元素，它的二进制形式是 11001。</p>\n</li>\n<li>\n<p><strong>Step 3 – Check Global Depth of the directory.</strong> Suppose the global depth of the Hash-directory is 3.</p>\n<p><strong>步骤 3 - 检查目录的全局深度</strong>：假设哈希目录的全局深度是 3。</p>\n</li>\n<li>\n<p><strong>Step 4 – Identify the Directory:</strong> Consider the ‘Global-Depth’ number of LSBs in the binary number and match it to the directory id.  Eg. The binary obtained is: 110001 and the global-depth is 3. So, the hash function will return 3 LSBs of 110<strong>001</strong> viz. 001.</p>\n<p><strong>步骤 4 - 识别目录</strong>：考虑在二进制下最低 “全局深度” 位，然后去匹配目录 id。比如，二进制是：110001，全局深度是 3，所以哈希函数会返回 110<strong>001</strong> 最后三位，即 001。</p>\n</li>\n<li>\n<p><strong>Step 5 – Navigation:</strong> Now, navigate to the bucket pointed by the directory with directory-id 001.</p>\n<p><strong>步骤 5 - 导航</strong>：现在，访问目录 id=001 指向的桶。</p>\n</li>\n<li>\n<p><strong>Step 6 – Insertion and Overflow Check:</strong> Insert the element and check if the bucket overflows. If an overflow is encountered, go to <strong>step 7</strong> followed by <strong>Step 8</strong>, otherwise, go to <strong>step 9</strong>.</p>\n<p><strong>步骤 6 – 插入和溢出检查</strong>：插入元素并且检查桶是否溢出。如果遇到溢出，转向步骤 7 和步骤 8，否则转到步骤 9。</p>\n</li>\n<li>\n<p><strong>Step 7 – Tackling Over Flow Condition during Data Insertion:</strong> Many times, while inserting data in the buckets, it might happen that the Bucket overflows. In such cases, we need to follow an appropriate procedure to avoid mishandling of data.  First, Check if the local depth is less than or equal to the global depth. Then choose one of the cases below.</p>\n<p><strong>步骤 7– 处理数据插入过程中的溢出情况:</strong>  很多情况下，当在桶里插入数据时，可能发生桶溢出。在这种情况下，我们需要采取下面合适的流程去避免误操作数据。首先，检查局部深度是否小于或等于全局深度。然后选择下述情况之一。</p>\n<ul>\n<li>\n<p><strong>Case1:</strong> If the local depth of the overflowing Bucket is equal to the global depth, then Directory Expansion, as well as Bucket Split, needs to be performed. Then increment the global depth and the local depth value by 1. And, assign appropriate pointers.  Directory expansion will double the number of directories present in the hash structure.</p>\n<p><strong>情况 1:</strong> 如果溢出桶的本地深度等于全局深度，那么需要执行目录扩张和桶分裂。然后全局深度和局部深度的值增加 1，并且指定合适的指针。目录扩张会 double 哈希结果中的目录数量。</p>\n</li>\n<li>\n<p><strong>Case2:</strong> In case the local depth is less than the global depth, then only Bucket Split takes place. Then increment only the local depth value by 1. And, assign appropriate pointers.</p>\n<p><strong>情况 2:</strong> 如果本地深度小于全局深度，那么仅仅发生桶分裂。然后仅仅把局部深度增加 1。并且指定合适的指针。</p>\n<p><img data-src=\"image-20230424231204645.png\" alt=\"image-20230424231204645\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Step 8 – Rehashing of Split Bucket Elements:</strong> The Elements present in the overflowing bucket that is split are rehashed w.r.t the new global depth of the directory.</p>\n<p><strong>步骤 8 - 分裂桶的元素重新哈希</strong>：在被分裂的溢出桶中呈现的元素会根据目录的全局深度进行重新哈希。</p>\n</li>\n<li>\n<p><strong>Step 9 –</strong> The element is successfully hashed.</p>\n<p><strong>步骤 9</strong> - 元素被成功哈希。</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Example based on Extendible Hashing:</strong> Now, let us consider a prominent example of hashing the following elements: <strong>16,4,6,22,24,10,31,7,9,20,26.</strong></p>\n<p><strong>基于可扩展哈希的样例</strong>：现在让我们考虑一个哈希以下元素的典型样例：16,4,6,22,24,10,31,7,9,20,26。（共 11 个元素）</p>\n<p><strong>Bucket Size:</strong> 3 (Assume)</p>\n<p><strong>桶大小</strong>：3（假设）</p>\n<p><strong>Hash Function:</strong> Suppose the global depth is X. Then the Hash Function returns X LSBs.</p>\n<p><strong>哈希函数</strong>：假设全局深度是 X，那么哈希函数返回 X 的最低位。</p>\n</blockquote>\n<ol>\n<li>\n<p><strong>Solution:</strong> First, calculate the binary forms of each of the given numbers.</p>\n<p>** 解决方案：** 首先，计算每个给定数值的二进制形式。</p>\n<p>16- 10000</p>\n<p>4- 00100</p>\n<p>6- 00110</p>\n<p>22- 10110</p>\n<p>24- 11000</p>\n<p>10- 01010</p>\n<p>31- 11111</p>\n<p>7- 00111</p>\n<p>9- 01001</p>\n<p>20- 10100</p>\n<p>26- 11010</p>\n</li>\n<li>\n<p>Initially, the global-depth and local-depth is always 1. Thus, the hashing frame looks like this:</p>\n<p>首先，全局深度和局部深度总是 1。因此哈希图看起来像这样：</p>\n<p><img data-src=\"image-20230424231857524.png\" alt=\"image-20230424231857524\"></p>\n</li>\n<li>\n<p><strong>Inserting 16:</strong>  The binary format of 16 is 10000 and global-depth is 1. The hash function returns 1 LSB of 1000<strong>0</strong> which is 0. Hence, 16 is mapped to the directory with id=0.</p>\n<p><strong>插入 16:</strong>  16 的二进制形式是 10000，且全局深度是 1。哈希函数返回 1000<strong>0</strong> 最低 1 位为 0。因此，16 映射到目录的 <code>id=0</code> 。</p>\n<p><img data-src=\"image-20230424231954017.png\" alt=\"image-20230424231954017\"></p>\n</li>\n<li>\n<p><strong>Inserting 4 and 6:</strong>  Both 4(10<strong>0</strong>) and 6(11<strong>0</strong>)have 0 in their LSB. Hence, they are hashed as follows:</p>\n<p><strong>插入 4 和 6</strong>：4(10<strong>0</strong>) and 6(11<strong>0</strong>) 的最低 1 位都是 0。因此，他们哈希结果如下：</p>\n<p><img data-src=\"image-20230424232039916.png\" alt=\"image-20230424232039916\"></p>\n</li>\n<li>\n<p><strong>Inserting 22:</strong> The binary form of 22 is 1011<strong>0</strong>. Its LSB is 0. The bucket pointed by directory 0 is already full. Hence, Over Flow occurs.</p>\n<p><strong>插入 22</strong>：22 的二进制形式是 1011**0。** 它的最低位是 0。目录 0 指向的桶已经满了。因此溢出发生了。</p>\n<p><img data-src=\"image-20230424232131329.png\" alt=\"image-20230424232131329\"></p>\n</li>\n<li>\n<p>As directed by <strong>Step 7-Case 1</strong>, Since Local Depth = Global Depth, the bucket splits and directory expansion takes place. Also, rehashing of numbers present in the overflowing bucket takes place after the split. And, since the global depth is incremented by 1, now,the global depth is 2. Hence, 16,4,6,22 are now rehashed w.r.t 2 LSBs.[ 16(100<strong>00</strong>),4(1<strong>00</strong>),6(1<strong>10</strong>),22(101<strong>10</strong>) ]</p>\n<p>正如<strong> Step 7-Case 1</strong> 指示的，因为局部深度 = 全局深度，桶分裂且目录扩张。同时，分裂之后在溢出的桶中重新哈希数值。并且因为全局深度增加了 1，所以现在全局深度是 2。因此，16,4,6,22 被重新哈希为最低 2 位。[16 (100<strong>00</strong>),4(1<strong>00</strong>),6(1<strong>10</strong>),22(101<strong>10</strong>) ]</p>\n<p><img data-src=\"image-20230424232239402.png\" alt=\"image-20230424232239402\"></p>\n<blockquote>\n<p><em>Notice that the bucket which was underflow has remained untouched. But, since the number of directories has doubled, we now have 2 directories 01 and 11 pointing to the same bucket. This is because the local-depth of the bucket has remained 1. And, any bucket having a local depth less than the global depth is pointed-to by more than one directories.</em></p>\n<p>注意，未溢出的桶存在没有触及的。但是，因为目录的数量已经翻倍，我们现在有 2 个目录 01 和 11 指向了同一个桶。这是因为桶的局部深度保持为 1。并且，任何局部深度小于全局深度的桶会被不止一个目录指向。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>Inserting 24 and 10:</strong> 24(110<strong>00</strong>) and 10 (10<strong>10</strong>) can be hashed based on directories with id 00 and 10. Here, we encounter no overflow condition.</p>\n<p><strong>插入 24 and 10:</strong> 24(110<strong>00</strong>) 和 10 (10<strong>10</strong>) 基于目录 id 00 和 10 可以被哈希。此处，我们没有遇到溢出的情况。</p>\n<p><img data-src=\"image-20230424232401349.png\" alt=\"image-20230424232401349\"></p>\n</li>\n<li>\n<p><strong>Inserting 31,7,9:</strong> All of these elements[ 31(111<strong>11</strong>), 7(1<strong>11</strong>), 9(10<strong>01</strong>) ] have either 01 or 11 in their LSBs. Hence, they are mapped on the bucket pointed out by 01 and 11. We do not encounter any overflow condition here.</p>\n<p><strong>插入 31,7,9:</strong> 所有这些元素 [ 31 (111<strong>11</strong>), 7(1<strong>11</strong>), 9(10<strong>01</strong>) ] 在最低 2 位要么 01，要么 11。因此，我们映射到 01 和 11 对应的桶。我们没有遇到任何溢出的情况。</p>\n<p><img data-src=\"image-20230424232504474.png\" alt=\"image-20230424232504474\"></p>\n</li>\n<li>\n<p><strong>Inserting 20:</strong> Insertion of data element 20 (101<strong>00</strong>) will again cause the overflow problem.</p>\n<p><strong>插入 20:</strong> 插入元素 20 (101<strong>00</strong>) 时再一次遇到了溢出问题。</p>\n<p><img data-src=\"image-20230424232547238.png\" alt=\"image-20230424232547238\"></p>\n</li>\n<li>\n<p>20 is inserted in bucket pointed out by 00. As directed by <strong>Step 7-Case 1</strong>, since the <strong>local depth of the bucket = global-depth</strong>, directory expansion (doubling) takes place along with bucket splitting. Elements present in overflowing bucket are rehashed with the new global depth. Now, the new Hash table looks like this:</p>\n<p>20 插入的桶被 00 所指向。正如<strong> Step 7-Case 1</strong> 提示的那样，因为<strong>桶的局部深度 = 全局深度</strong>，目录扩张和桶分裂发生了。在溢出桶中的元素在新的全局深度下重新哈希。现在，新的哈希表如下：</p>\n<p><img data-src=\"image-20230424232653483.png\" alt=\"image-20230424232653483\"></p>\n</li>\n<li>\n<p><strong>Inserting 26:</strong> Global depth is 3. Hence, 3 LSBs of 26(11<strong>010</strong>) are considered. Therefore 26 best fits in the bucket pointed out by directory 010.</p>\n<p><strong>插入 26</strong>：全局深度是 3。因此 26 (11<strong>010</strong>) 的最低 3 位被考虑。因此 26 最适合的桶被目录 010 指向。</p>\n<p>![image-20230424232743216](D:\\Blog\\source_posts\\CMU15-445 Project1\\image-20230424232743216.png)</p>\n</li>\n<li>\n<p>The bucket overflows, and, as directed by <strong>Step 7-Case 2,</strong> since the <strong>local depth of bucket &lt; Global depth (2&lt;3)</strong>, directories are not doubled but, only the bucket is split and elements are rehashed.  Finally, the output of hashing the given list of numbers is obtained.</p>\n<p>桶发生了溢出，并且按照<strong> Step 7-Case 2</strong> 的指示，因此桶的<strong>局部深度小于全局深度（2&lt;3）</strong>，目录不会翻倍，仅仅是桶分裂和元素重新哈希。最后，哈希给定数值列表的结果已经获得。</p>\n<p><img data-src=\"image-20230424232914876.png\" alt=\"image-20230424232914876\"></p>\n</li>\n<li>\n<p><strong>Hashing of 11 Numbers is Thus Completed.</strong></p>\n<p>11 个数值的哈希已经完成。</p>\n</li>\n</ol>\n<p><strong>Key Observations 关键观察：</strong></p>\n<ol>\n<li>A Bucket will have more than one pointers pointing to it if its local depth is less than the global depth. 如果局部深度小于全局深度，一个桶会被超过 1 个指针指向。</li>\n<li>When overflow condition occurs in a bucket, all the entries in the bucket are rehashed with a new local depth. 当桶发生溢出时，在这个桶里的所有元素都要用新的局部深度重新哈希。</li>\n<li>If Local Depth of the overflowing bucket. 如果溢出桶的局部深度</li>\n<li>The size of a bucket cannot be changed after the data insertion process begins. 在数据插入操作开始之后桶的大小不能改变。</li>\n</ol>\n<p><strong>Advantages:</strong>   <strong>优势</strong></p>\n<ol>\n<li>Data retrieval is less expensive (in terms of computing). 数据检索很便宜（根据计算）</li>\n<li>No problem of Data-loss since the storage capacity increases dynamically. 因此存储容量动态增长，数据丢失没有问题。</li>\n<li>With dynamic changes in hashing function, associated old values are rehashed w.r.t the new hash function. 随着在哈希函数中的动态改变，相关联的旧值被重新哈希到新的哈希函数中。</li>\n</ol>\n<p><strong>Limitations Of Extendible Hashing:</strong>   <strong>可扩展哈希的限制</strong></p>\n<ol>\n<li>The directory size may increase significantly if several records are hashed on the same directory while keeping the record distribution non-uniform. 当记录保持非均匀分布，如果多个记录被哈希到同一个目录，那么目录的大小会显著增加。</li>\n<li>Size of every bucket is fixed. 每个桶的大小是固定的。</li>\n<li>Memory is wasted in pointers when the global depth and local depth difference becomes drastic. 当全局深度和局部深度差距很大时，内存在指针上是浪费的。</li>\n<li>This method is complicated to code. 这个方法在代码上很复杂。</li>\n</ol>\n<h1 id=\"lru-k-replacement-policy\"><a class=\"markdownIt-Anchor\" href=\"#lru-k-replacement-policy\">#</a> LRU-K Replacement Policy</h1>\n<h2 id=\"task-2\"><a class=\"markdownIt-Anchor\" href=\"#task-2\">#</a> task</h2>\n<p>这个组件负责跟踪缓冲池中的页面使用情况。我们将在 <code>src/include/buffer/lru_k_replacer.h</code>  中实现一个名为 <code>LRUKReplacer</code>  的新类。并在 <code>src/buffer/lru_k_replacer.cpp</code>  中实现相应的实现文件。<br>\n注意： <code>LRUKReplacer</code>  是一个独立的类，它与其他的 Replacer 类没有关系。我们应该只实现 LRU-K 替换策略，而不需要实现 LRU 或者时钟 (clock) 替换策略，即使有相应的文件。</p>\n<p>LRU-K 算法驱逐一个帧，该帧的后向 k - 距离 (Backward k-distance) 是替换器中所有帧的最大值。** 后向 k - 距离的计算方法是当前时间戳和第 k 次访问的时间戳之间的时间差。** 一个少于 k 次历史访问的帧被赋予  <code>+inf</code>  来作为它的后向 k - 距离。<br>\n当多个帧有 <code>+inf</code>  的后向 k - 距离的时候，替换器会驱逐具有最早时间戳的帧。</p>\n<p><code>LRUReplacer</code>  的最大尺寸与缓冲池的尺寸相同，因为它包含 <code>BufferPoolManager</code>  中所有帧的占位符（记录每个 page 的访问次数）。然而在任何给定的时刻，并不是复制器中的所有帧都被认为是可驱逐的。 <code>LRUReplacer</code>  的大小由可驱逐的数量表示。 <code>LRUReplacer</code>  被初始化为里面没有帧，然后只有当一个帧标记为可驱逐后，替换器 (replacer) 的大小才会增加。</p>\n<p>我们需要实现课堂上讨论的 LRU-K 策略。我们将实现以下方法:</p>\n<ul>\n<li><code>Evict(frame_id_t*)</code> <br>\n 驱逐 Replacer 正在跟踪的所有其他可驱逐帧相比，具有最大后向 k - 距离的帧。在输出参数中存储该帧的 ID，并返回 true。如果没有可驱逐帧，返回 false。</li>\n<li><code>RecordAccess(frame_id_t)</code> <br>\n 记录给定的帧 ID 在当前时间戳被访问，这个方法应该在一个页面被 pin 在 <code>BufferPoolManager</code>  后被调用。</li>\n<li><code>Remove(frame_id_t)</code> <br>\n 清除与一个帧相关的所有访问历史。只有在 <code>BufferPoolManager</code>  中删除一个页面的时候，才应该调用这个方法。</li>\n<li><code>SetEvictable(frame_id_t, bool set_evictable)</code> <br>\n 该方法控制一个帧是否可以被驱逐。它还控制 LRUReplacer 的大小。<br>\n当我们实现 <code>BufferPoolManager</code>  的时候，我们就会知道啥时候调用这个函数。<br>\n具体来说，当一个页面的 pin count 达到 0 的时候，其对应的帧就会标记为可驱逐 (Evictable)。Replacer 的大小也会增加。</li>\n<li><code>Size()</code> <br>\n 这个方法返回当前在 LRUReplacer 中可驱逐帧的数量。</li>\n<li>实现的方法取决于我们。我们被允许使用内置的 STL 容器。而且可以假定不会耗尽内存，但必须保证操作是线程安全的 (thread-safe)。</li>\n</ul>\n<h2 id=\"lru-k算法原理\"><a class=\"markdownIt-Anchor\" href=\"#lru-k算法原理\">#</a> LRU-K 算法原理</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9scnUtY2FjaGUv\">146. LRU 缓存 - 力扣（LeetCode）</span></p>\n<p>请你设计并实现一个<strong>满足 LRU (Least Recently Used 最近最少使用) 缓存</strong>约束的数据结构。<br>\n实现  <code>LRUCache</code>  类：</p>\n<ul>\n<li><code>LRUCache(int capacity)</code>  以 <strong>正整数</strong> 作为容量  <code>capacity</code>  初始化 LRU 缓存</li>\n<li><code>int get(int key)</code>  如果关键字  <code>key</code>  存在于缓存中，则返回关键字的值，否则返回  <code>-1</code>  。</li>\n<li><code>void put(int key, int value)</code>  如果关键字  <code>key</code>  已经存在，则变更其数据值  <code>value</code>  ；如果不存在，则向缓存中插入该组  <code>key-value</code>  。如果插入操作导致关键字数量超过  <code>capacity</code>  ，则应该 逐出 最久未使用的关键字。</li>\n</ul>\n<p>函数  <code>get</code>  和  <code>put</code>  必须以  <code>O(1)</code>  的平均时间复杂度运行。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>p</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 输入</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token string\">\"LRUCache\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"put\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"put\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"get\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"put\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"get\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"put\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"get\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"get\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"get\"</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 输出</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">[</span>null<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 解释</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>LRUCache lRUCache <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">LRUCache</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>lRUCache<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 缓存是 &#123;1=1&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>lRUCache<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 缓存是 &#123;1=1, 2=2&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>lRUCache<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 返回 1</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>lRUCache<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>lRUCache<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 返回 -1 (未找到)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>lRUCache<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>lRUCache<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 返回 -1 (未找到)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>lRUCache<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 返回 3</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>lRUCache<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 返回 4</span></pre></td></tr></table></figure><figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>p</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">LRUCache</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// 1. 哈希表</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 2. 双向链表</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">int</span> key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        Node <span class=\"token operator\">*</span>prev<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>next<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> v<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span><span class=\"token function\">key</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">val</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">prev</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    unordered_map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> Node<span class=\"token operator\">*</span><span class=\"token operator\">></span> mp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">//3. 容量</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token comment\">// 哨兵</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    Node <span class=\"token operator\">*</span>L <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    Node <span class=\"token operator\">*</span>R <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token function\">LRUCache</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        n <span class=\"token operator\">=</span> capacity<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        L<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> R<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        R<span class=\"token operator\">-></span>prev <span class=\"token operator\">=</span> L<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">int</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mp<span class=\"token punctuation\">.</span><span class=\"token function\">count</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            Node <span class=\"token operator\">*</span>node <span class=\"token operator\">=</span> mp<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token comment\">// 最近使用</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 从链表中移除该节点</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">-></span>key<span class=\"token punctuation\">,</span> node<span class=\"token operator\">-></span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 在链表的最右边插入该节点</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            <span class=\"token keyword\">return</span> node<span class=\"token operator\">-></span>val<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mp<span class=\"token punctuation\">.</span><span class=\"token function\">count</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>            Node<span class=\"token operator\">*</span> node <span class=\"token operator\">=</span> mp<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>            <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>            <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mp<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>                Node <span class=\"token operator\">*</span>node <span class=\"token operator\">=</span> L<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 最久未使用。左哨兵的下一个节点</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>                <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>                <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>                <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    <span class=\"token comment\">// 4. 同时在链表和哈希表中删除节点</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>Node <span class=\"token operator\">*</span>node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>        <span class=\"token keyword\">auto</span> pre <span class=\"token operator\">=</span> node<span class=\"token operator\">-></span>prev<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>        <span class=\"token keyword\">auto</span> nxt <span class=\"token operator\">=</span> node<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"55\"></td><td><pre>        pre<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> nxt<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>        nxt<span class=\"token operator\">-></span>prev <span class=\"token operator\">=</span> pre<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"58\"></td><td><pre>        mp<span class=\"token punctuation\">.</span><span class=\"token function\">erase</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">-></span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> key<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>        <span class=\"token keyword\">auto</span> node <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"63\"></td><td><pre>        <span class=\"token keyword\">auto</span> pre <span class=\"token operator\">=</span> R<span class=\"token operator\">-></span>prev<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>        <span class=\"token keyword\">auto</span> nxt <span class=\"token operator\">=</span> R<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"66\"></td><td><pre>        <span class=\"token comment\">// 从左往右</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>        pre<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>        node<span class=\"token operator\">-></span>next <span class=\"token operator\">=</span> nxt<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>        <span class=\"token comment\">// 从右往左</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>        nxt<span class=\"token operator\">-></span>prev <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>        node<span class=\"token operator\">-></span>prev <span class=\"token operator\">=</span> pre<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"73\"></td><td><pre>        mp<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"77\"></td><td><pre> * Your LRUCache object will be instantiated and called as such:</pre></td></tr><tr><td data-num=\"78\"></td><td><pre> * LRUCache* obj = new LRUCache(capacity);</pre></td></tr><tr><td data-num=\"79\"></td><td><pre> * int param_1 = obj->get(key);</pre></td></tr><tr><td data-num=\"80\"></td><td><pre> * obj->put(key,value);</pre></td></tr><tr><td data-num=\"81\"></td><td><pre> */</span></pre></td></tr></table></figure><p>LRU-K 算法参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9jNGU0ZDU1NzA2ZmY=\">LRU-K 和 2Q 缓存算法介绍</span></p>\n<ul>\n<li>\n<p>算法思想</p>\n<p>LRU-K 中的 K 代表最近使用的次数，因此 LRU 可以认为是 LRU-1。LRU-K 的主要目的是为了解决 LRU 算法 “缓存污染” 的问题，其核心思想是将 “最近使用过 1 次” 的判断标准扩展为 “最近使用过 K 次”。</p>\n</li>\n<li>\n<p>工作原理</p>\n<p>相比 LRU，LRU-K 需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到 K 次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K 会淘汰第 K 次访问时间距当前时间最大的数据。详细实现如下</p>\n<p>![img](D:\\Blog\\source_posts\\CMU15-445 Project1\\20230425001.png)</p>\n<ol>\n<li>数据第一次被访问，加入到访问历史列表；</li>\n<li>如果数据在访问历史列表里后没有达到 K 次访问，则按照一定规则（FIFO，LRU）淘汰；</li>\n<li>当访问历史队列中的数据访问次数达到 K 次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</li>\n<li>缓存数据队列中被再次访问后，重新排序；</li>\n<li>需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰 “倒数第 K 次访问离现在最久” 的数据。</li>\n</ol>\n</li>\n</ul>\n<p>LRU-K 具有 LRU 的优点，同时能够避免 LRU 的缺点，实际应用中 LRU-2 是综合各种因素后最优的选择，LRU-3 或者更大的 K 值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。</p>\n<p><strong>Two queues（2Q）</strong></p>\n<ul>\n<li>\n<p>算法思想</p>\n<p>该算法类似于 LRU-2，不同点在于 2Q 将 LRU-2 算法中的访问历史队列（注意这不是缓存数据的）改为一个 FIFO 缓存队列，即：2Q 算法有两个缓存队列，一个是 FIFO 队列，一个是 LRU 队列。</p>\n</li>\n<li>\n<p>工作原理</p>\n<p>当数据第一次访问时，2Q 算法将数据缓存在 FIFO 队列里面，当数据第二次被访问时，则将数据从 FIFO 队列移到 LRU 队列里面，两个队列各自按照自己的方法淘汰数据。详细实现如下：</p>\n<p>![img](D:\\Blog\\source_posts\\CMU15-445 Project1\\20230425002.png)</p>\n<ol>\n<li>新访问的数据插入到 FIFO 队列；</li>\n<li>如果数据在 FIFO 队列中一直没有被再次访问，则最终按照 FIFO 规则淘汰；</li>\n<li>如果数据在 FIFO 队列中被再次访问，则将数据移到 LRU 队列头部；</li>\n<li>如果数据在 LRU 队列再次被访问，则将数据移到 LRU 队列头部；</li>\n<li>LRU 队列淘汰末尾的数据。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"buffer-pool-manager-instance\"><a class=\"markdownIt-Anchor\" href=\"#buffer-pool-manager-instance\">#</a> Buffer Pool Manager Instance</h1>\n<h2 id=\"review\"><a class=\"markdownIt-Anchor\" href=\"#review\">#</a> review</h2>\n<p>实现缓冲池的两个重要数据结构：</p>\n<ul>\n<li>可扩展哈希表</li>\n<li>LRU-K</li>\n</ul>\n<p>本节将介绍缓冲池实现的具体细节，通过模式关系图和代码，加深对传统关系型数据库中缓冲池的理解。</p>\n<h2 id=\"task-3\"><a class=\"markdownIt-Anchor\" href=\"#task-3\">#</a> task</h2>\n<p>最后我们需要实现缓冲池管理系统 ( <code>BufferPoolManagerInstance</code> )。 <code>BufferPoolManagerInstance</code>  是用来从 <code>DiskManager</code>  中获取数据库的页的，以及在内存中存储它们。 <code>BufferPoolManagerInstance</code>  也可以将脏页 (dirty page) 写到磁盘上，当它被明确指示的时候，或者当它需要驱逐一个页面来腾出空间给新的页面的时候。(计组和 OS 的知识)。</p>\n<p>为了确保我们的实现能和系统的其他部分正常工作，本项目将提供一些已经填写好的函数。我们也不需要实现向磁盘实际读写数据的代码 (这些在我们的实现中被称为:  <code>DiskManager</code> )。本项目将提供这一功能。</p>\n<p>系统中的所有内存页都由 <code>Page</code>  对象表示。 <code>BufferPoolManagerInstance</code>  不需要理解这些页面的内容。但是作为系统开发者，我们必须了解 <code>Page</code>  对象只是缓冲池中内容的容器，因此并不特定于某个独立的页面。也就是说，每个 <code>Page</code>  对象都包含一个内存块， <code>DiskManager</code>  将把它作为一个位置来复制从磁盘读取的物理页的内容。</p>\n<p><code>BufferPoolManagerInstance</code>  将重复使用同一个 <code>Page</code>  对象来存储数据，因为它从磁盘来回移动。这意味着在系统的整个生命周期中，同一个 <code>Page</code>  对象可能包含不同的物理页。 <code>Page</code>  对象的标识符 ( <code>page_id</code> ) 可以跟踪它所包含的物理页。如果一个 <code>Page</code>  对象不包含一个物理页，那么 <code>page_id</code>  被设为 <code>INVALID_PAGE_ID</code></p>\n<p>每个页面对象也维护一个计数器，用于记录 Pinned 该页面的线程数量。我们的 <code>BufferPoolManagerInstance</code>  不允许释放一个被 Pinned 住的页面！每个页面对象也会记录它是否是脏的，我们的工作就是记录一个页面在被解除 Pinned 住之前，是否被修改过。 我们的 <code>BufferPoolManagerInstance</code>  必须将一个脏页的内容写回到磁盘上。然后该对象才能被重新使用。</p>\n<p>我们的 <code>BufferPoolManagerInstance</code>  实现将使用我们在本作业中前几步中创建的 <code>ExtendibleHashTable</code>  和 <code>LRUReplacer</code>  类。它将使用 <code>ExtendibleHashTable</code>  表来映射 <code>page_id</code>  到 <code>frame_id</code> 。它还将使用 <code>LRUKReplacer</code>  来跟踪 <code>Page</code>  对象被访问的时间，这样当它必须释放一个 frame 以便为从磁盘复制一个新的物理页腾出空间的时候，它就可以决定驱逐哪个。</p>\n<p>我们需要实现定义在头文件 ( <code>src/include/buffer/buffer_pool_manager_instance.h</code> ) 的源文件 ( <code>src/buffer/buffer_pool_manager_instance.cpp</code> )</p>\n<ul>\n<li><code>FetchPgImp(page_id)</code></li>\n<li><code>UnpinPgImp(page_id, is_dirty)</code></li>\n<li><code>FlushPgImp(page_id)</code></li>\n<li><code>NewPgImp(page_id)</code></li>\n<li><code>DeletePgImp(page_id)</code></li>\n<li><code>FlushAllPagesImpl()</code></li>\n</ul>\n<p>函数的解释：</p>\n<ul>\n<li>\n<p>For  <code>FetchPgImp</code> , 如果空闲列表没有可用的页面，并且所有的其他页面目前都被 Pinned 住了，我们应该返回 <code>nullptr</code> 。 <code>FlushPgImp</code>  应该刷新一个页面，不管它的 pin status 如何。</p>\n</li>\n<li>\n<p>For  <code>UnpinPgImp</code> ,  <code>is_dirty</code>  参数记录了一个页面在 Pin 住的时候是否被修改。</p>\n</li>\n<li>\n<p>当我们向在 <code>NewPgImp()</code>  创建一个新的页面的时候， <code>AllocatePage</code>  私有方法为 <code>BufferPoolManager</code>  提供了一个唯一的新页面 ID。另一个方面， <code>DeallocatePage()</code>  方法是一个模仿释放磁盘上的页面的 no-op，我们应该在 <code>DeletePgImp()</code>  实现中调用，</p>\n<blockquote>\n<p>原文：<br>\nOn the other hand, the  <code>DeallocatePage()</code>  method is a no-op that imitates freeing a page on the disk and you should call this in your  <code>DeletePgImp()</code>  implementation.</p>\n</blockquote>\n</li>\n<li>\n<p>最后请参考函数文档，来了解如何实现这些函数，以及 <code>BufferPoolManagerInstance</code>  如何与 <code>LRUKReplacer</code>  互动的细节。不要碰那些 non-impl 版本，本项目需要这些来评分。</p>\n</li>\n</ul>\n<p>Disk Manager</p>\n<p>磁盘管理器类 ( <code>src/include/storage/disk/disk_manager.h</code> ), 从磁盘读取和写入页面数据。当我们的缓冲池管理器将在需要向缓冲池获取页面，或者向磁盘刷新页面的时候，使用 <code>DiskManager::ReadPage()</code>  和 <code>DiskManager::WritePage()</code> 。</p>\n<h2 id=\"难点\"><a class=\"markdownIt-Anchor\" href=\"#难点\">#</a> 难点</h2>\n<ol>\n<li>NewPage 和 FetchPage 两个函数有什么区别？</li>\n<li>page 和 frame 是什么关系？</li>\n<li>flush 到磁盘后要不要清空 page 中的数据？</li>\n<li>pip-count 引用计数不为 0 能不能 flush 刷新到磁盘？</li>\n</ol>\n<h2 id=\"架构关系图\"><a class=\"markdownIt-Anchor\" href=\"#架构关系图\">#</a> 架构关系图</h2>\n<ul>\n<li></li>\n</ul>\n",
            "tags": [
                "DataBase"
            ]
        },
        {
            "id": "https://adventure-yx.github.io/2023/03/06/CMU15-445%20Project0/",
            "url": "https://adventure-yx.github.io/2023/03/06/CMU15-445%20Project0/",
            "title": "CMU15-445 Project#0 字典树trie",
            "date_published": "2023-03-06T12:10:50.000Z",
            "content_html": "<p><img data-src=\"image-20230422131532761.png\" alt=\"image-20230422131532761\"></p>\n<h1 id=\"什么是字典树前缀树trie\"><a class=\"markdownIt-Anchor\" href=\"#什么是字典树前缀树trie\">#</a> 什么是字典树 / 前缀树 /trie</h1>\n<p>前缀树，又称字典树。是  <code>N叉树</code>  的一种特殊形式。<strong>前缀树用于存储、查找字符串</strong>。前缀树的每一个节点代表一个字符串（前缀）。每一个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。子节点代表的字符串是由节点本身的<strong>原始字符串</strong> ，以及<strong>通往该子节点路径上所有的字符</strong>组成的。</p>\n<p><img data-src=\"screen-shot-2018-01-31-at-163403.png\" alt=\"img\"></p>\n<p>在上图示例中，我们在节点中标记的值是该节点对应表示的字符串。例如，我们从根节点开始，选择第二条路径 ‘b’，然后选择它的第一个子节点 ‘a’，接下来继续选择子节点 ‘d’，我们最终会到达叶节点 “bad”。节点的值是由从根节点开始，与其经过的路径中的字符按顺序形成的。</p>\n<p>值得注意的是，根节点表示<strong>空字符串</strong>。</p>\n<p>前缀树的一个重要的特性是，节点所有的后代都与该节点相关的字符串有着共同的前缀。这就是 前缀树 名称的由来。</p>\n<p>我们再来看这个例子。例如，以节点 “b” 为根的子树中的节点表示的字符串，都具有共同的前缀 “b”。反之亦然，具有公共前缀 “b” 的字符串，全部位于以 “b” 为根的子树中，并且具有不同前缀的字符串来自不同的分支。</p>\n<p>前缀树有着广泛的应用，例如自动补全，拼写检查等等。</p>\n<h1 id=\"如何表示一个前缀树\"><a class=\"markdownIt-Anchor\" href=\"#如何表示一个前缀树\">#</a> 如何表示一个前缀树</h1>\n<ol>\n<li>\n<p>用<strong>数组</strong>存储子节点</p>\n<p>例如，如果我们只存储含有字母 <code>a</code>  到  <code>z</code>  的字符串，我们可以在每个节点中声明一个大小为 26 的数组来存储其子节点。对于特定字符  <code>c</code>  ，我们可以使用  <code>c - 'a'</code>  作为索引来查找数组中相应的子节点。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">N</span> <span class=\"token expression\"><span class=\"token number\">26</span></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">TrieNode</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    TrieNode<span class=\"token operator\">*</span> children<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// you might need some extra values according to different cases</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">/** Usage:</pre></td></tr><tr><td data-num=\"10\"></td><td><pre> *  Initialization: TrieNode root = new TrieNode();</pre></td></tr><tr><td data-num=\"11\"></td><td><pre> *  Return a specific child node with char c: (root->children)[c - 'a']</pre></td></tr><tr><td data-num=\"12\"></td><td><pre> */</span></pre></td></tr></table></figure><p>访问子节点十分快捷。访问一个特定的子节点比较容易，因为在大多数情况下，我们很容易将一个字符转换为索引。但并非所有的子节点都需要这样的操作，所以这可能会导致<strong>空间的浪费</strong>。</p>\n</li>\n<li>\n<p>用 Hashmap 来存储子节点</p>\n<p>我们可以在每个节点中声明一个 Hashmap 。Hashmap 的键是字符，值是相对应的子节点。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">TrieNode</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    unordered_map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">char</span><span class=\"token punctuation\">,</span> TrieNode<span class=\"token operator\">*</span><span class=\"token operator\">></span> children<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// you might need some extra values according to different cases</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">/** Usage:</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> *  Initialization: TrieNode root = new TrieNode();</pre></td></tr><tr><td data-num=\"9\"></td><td><pre> *  Return a specific child node with char c: (root->children)[c]</pre></td></tr><tr><td data-num=\"10\"></td><td><pre> */</span></pre></td></tr></table></figure><p>通过相应的字符来访问特定的子节点更为容易。但它可能比使用数组稍慢一些。但是，由于我们只存储我们需要的子节点，因此节省了空间。这个方法也更加灵活，因为我们不受到固定长度和固定范围的限制。</p>\n</li>\n</ol>\n<blockquote>\n<p>我们已经提到过如何表示前缀树中的子节点。除此之外，我们也需要用到一些其他的值。</p>\n<p>例如，我们知道，前缀树的每个节点表示一个字符串，但并不是所有由前缀树表示的字符串都是有意义的。如果我们只想在前缀树中存储单词，那么我们可能需要在每个节点中声明一个布尔值（Boolean）作为标志，来表明该节点所表示的字符串是否为一个单词。</p>\n</blockquote>\n<h1 id=\"前缀树中的插入操作\"><a class=\"markdownIt-Anchor\" href=\"#前缀树中的插入操作\">#</a> 前缀树中的插入操作</h1>\n<p>review：如何在二叉搜索树中插入一个新的节点？</p>\n<p>当我们在二叉搜索树中插入目标值时，在每个节点中，我们都需要根据 节点值 和 目标值 之间的关系，来确定目标值需要去往哪个子节点。同样地，当我们向前缀树中插入一个目标值时，我们也需要根据插入的 目标值 来决定我们的路径。</p>\n<p>更具体地说，如果我们在前缀树中插入一个字符串  <code>S</code> ，我们要从根节点开始。 我们将根据  <code>S[0]</code> （S 中的第一个字符），选择一个子节点或添加一个新的子节点。然后到达第二个节点，并根据  <code>S[1]</code>  做出选择。 再到第三个节点，以此类推。 最后，我们依次遍历  <code>S</code>  中的所有字符并到达末尾。 末端节点将是表示字符串  <code>S</code>  的节点。</p>\n<p>通常情况情况下，你需要自己构建前缀树。构建前缀树实际上就是多次调用插入函数。但请记住在插入字符串之前<strong>要初始化根节点</strong></p>\n<h1 id=\"实现trie经典的字典树\"><a class=\"markdownIt-Anchor\" href=\"#实现trie经典的字典树\">#</a> 实现 trie (经典的字典树)</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtdHJpZS1wcmVmaXgtdHJlZS8=\">208. 实现 Trie (前缀树) - 力扣（LeetCode）</span></p>\n<p>请你实现 Trie 类：</p>\n<ul>\n<li><code>Trie()</code>  初始化前缀树对象。</li>\n<li><code>void insert(String word)</code>  向前缀树中插入字符串  <code>word</code>  。</li>\n<li><code>boolean search(String word)</code>  如果字符串  <code>word</code>  在前缀树中，返回  <code>true</code> （即，在检索之前已经插入）；否则，返回  <code>false</code>  。</li>\n<li><code>boolean startsWith(String prefix)</code>  如果之前已经插入的字符串  <code>word</code>  的前缀之一为  <code>prefix</code>  ，返回  <code>true</code>  ；否则，返回  <code>false</code>  。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>p</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 输入</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token string\">\"Trie\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"insert\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"search\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"search\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"startsWith\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"insert\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"search\"</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"app\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"app\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"app\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"app\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 输出</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">[</span>null<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">// 解释</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>Trie trie <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">Trie</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>trie<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>trie<span class=\"token punctuation\">.</span><span class=\"token function\">search</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"apple\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 返回 True</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>trie<span class=\"token punctuation\">.</span><span class=\"token function\">search</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"app\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 返回 False</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>trie<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"app\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 返回 True</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>trie<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"app\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>trie<span class=\"token punctuation\">.</span><span class=\"token function\">search</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"app\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 返回 True</span></pre></td></tr></table></figure><p>提示：</p>\n<ul>\n<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>\n<li><code>word</code>  和  <code>prefix</code>  仅由小写英文字母组成</li>\n<li><code>insert</code> 、 <code>search</code>  和  <code>startsWith</code>  调用次数总计不超过 3 * 10^^4 次</li>\n</ul>\n<p><strong>力扣解析：</strong></p>\n<blockquote>\n<p><strong>字典树，一棵有根树，其每个节点包含以下字段</strong>：</p>\n<ul>\n<li>指向子节点的指针数组  <code>children</code> 。对于本题而言，数组长度为 26，即小写英文字母的数量。此时 <code>children[0]</code>  对应小写字母 a， <code>children[1]</code>  对应小写字母 b，…， <code>children[25]</code>  对应小写字母 z。</li>\n<li>布尔字段  <code>isEnd</code> ，表示该节点是否为字符串的结尾。</li>\n</ul>\n<p><strong>插入字符串</strong></p>\n<p>我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：</p>\n<ul>\n<li>子节点存在。沿着指针移动到子节点，继续处理下一个字符。</li>\n<li>子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。</li>\n</ul>\n<p>重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。</p>\n<p><strong>查找前缀</strong></p>\n<p>我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：</p>\n<ul>\n<li>子节点存在。沿着指针移动到子节点，继续搜索下一个字符。</li>\n<li>子节点不存在。说明字典树中不包含该前缀，返回空指针。</li>\n</ul>\n<p>重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。</p>\n<p>若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，若前缀末尾对应节点的 <code>isEnd</code>  为真，则说明字典树中存在该字符串。</p>\n</blockquote>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>p</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Trie</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vector<span class=\"token operator\">&lt;</span>Trie<span class=\"token operator\">*</span><span class=\"token operator\">></span> children<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">bool</span> isEnd<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    Trie<span class=\"token operator\">*</span> <span class=\"token function\">searchPrefix</span><span class=\"token punctuation\">(</span>string prefix<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        Trie<span class=\"token operator\">*</span> node <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> ch <span class=\"token operator\">:</span> prefix<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            ch <span class=\"token operator\">-=</span> <span class=\"token char\">'a'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token operator\">-></span>children<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                <span class=\"token keyword\">return</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            node <span class=\"token operator\">=</span> node<span class=\"token operator\">-></span>children<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token function\">Trie</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token function\">children</span><span class=\"token punctuation\">(</span><span class=\"token number\">26</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">isEnd</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>string word<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        Trie<span class=\"token operator\">*</span> node <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> ch <span class=\"token operator\">:</span> word<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            ch <span class=\"token operator\">-=</span> <span class=\"token char\">'a'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node<span class=\"token operator\">-></span>children<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>                node<span class=\"token operator\">-></span>children<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">Trie</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            node <span class=\"token operator\">=</span> node<span class=\"token operator\">-></span>children<span class=\"token punctuation\">[</span>ch<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        node<span class=\"token operator\">-></span>isEnd <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token keyword\">bool</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>string word<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        Trie<span class=\"token operator\">*</span> node <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token operator\">-></span><span class=\"token function\">searchPrefix</span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token keyword\">return</span> node <span class=\"token operator\">!=</span> <span class=\"token keyword\">nullptr</span> <span class=\"token operator\">&amp;&amp;</span> node<span class=\"token operator\">-></span>isEnd<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token keyword\">bool</span> <span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span>string prefix<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token operator\">-></span><span class=\"token function\">searchPrefix</span><span class=\"token punctuation\">(</span>prefix<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">nullptr</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><strong>首先构建节点（Node）；弄清了节点的结构和含义，一棵树（Tree）的构建就会水到渠成</strong></p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>p</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">TrieNode</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    boolean isWord<span class=\"token punctuation\">;</span>\t\t\t\t\t\t\t  <span class=\"token comment\">// 从 root 根节点至此是否是一个完整的单词（即这个节点是否是一个单词的结尾）</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\tTrieNode<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> children <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> TrieNode<span class=\"token punctuation\">[</span><span class=\"token number\">26</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// 巧妙的用数组的下标作为 26 个字母；数组的值则为子节点</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token keyword\">public</span> <span class=\"token function\">TrieNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\t\t<span class=\"token comment\">// 无参构造函数 (不写也行)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><blockquote>\n<p>如果没有 a-z 的限制，就不能用数组，而使用<strong>哈希表</strong>。</p>\n</blockquote>\n<p><strong>构建好了节点，下面开始构建树，并写出树的一些方法：</strong></p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>p</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">TrieNode</span> <span class=\"token punctuation\">&#123;</span>\t\t<span class=\"token comment\">// 节点</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">bool</span> isWord<span class=\"token punctuation\">;</span>\t\t\t\t\t\t\t\t</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\tTrieNode<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> children <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> TrieNode<span class=\"token punctuation\">[</span><span class=\"token number\">26</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\t\t</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Trie</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    TrieNode root<span class=\"token punctuation\">;</span>       <span class=\"token comment\">// 根节点</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token function\">Trie</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\troot <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">TrieNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 构造字典树，就是先构造出一个空的根节点</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token comment\">//【向字典树插入单词 word】</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token comment\">// 思路：按照 word 的字符，从根节点开始，一直向下走：</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token comment\">// 如果遇到 null，就 new 出新节点；如果节点已经存在，cur 顺着往下走就可以</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>string word<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        TrieNode cur <span class=\"token operator\">=</span> root<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">// 先指向根节点</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span> word<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token comment\">// 如果是【后缀树】而不是【前缀树】，把单词倒着插就可以了，即 for (len-1; 0; i--)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>             <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> word<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token char\">'a'</span><span class=\"token punctuation\">;</span>           <span class=\"token comment\">// (关键) 将一个字符用数字表示出来，并作为下标</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>             <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>                cur<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token function\">TrieNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>             cur <span class=\"token operator\">=</span> cur<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        cur<span class=\"token punctuation\">.</span>isWord <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token comment\">//【判断一个单词 word 是否完整存在于字典树中】</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token comment\">// 思路：cur 从根节点开始，按照 word 的字符一直尝试向下走：</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token comment\">// 如果走到了 null，说明这个 word 不是前缀树的任何一条路径，返回 false;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token comment\">// 如果按照 word 顺利的走完，就要判断此时 cur 是否为单词尾端：如果是，返回 true；如果不是，说明 word 仅仅是一个前缀，并不完整，返回 false</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token keyword\">bool</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>string word<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        TrieNode cur <span class=\"token operator\">=</span> root<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> word<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>            <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> word<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token char\">'a'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>                <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>            cur <span class=\"token operator\">=</span> cur<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>\t    <span class=\"token keyword\">return</span> cur<span class=\"token punctuation\">.</span>isWord<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"46\"></td><td><pre>    <span class=\"token comment\">//【判断一个单词 word 是否是字典树中的前缀】</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    <span class=\"token comment\">// 思路：和 sesrch 方法一样，根据 word 从根节点开始一直尝试向下走：</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>    <span class=\"token comment\">// 如果遇到 null 了，说明这个 word 不是前缀树的任何一条路径，返回 false;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>    <span class=\"token comment\">// 如果安全走完了，直接返回 true 就行了 ——— 我们并不关心此事 cur 是不是末尾 (isWord)</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    <span class=\"token keyword\">bool</span> <span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span>string prefix<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>        TrieNode cur <span class=\"token operator\">=</span> root<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"53\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> word<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>            <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> word<span class=\"token punctuation\">.</span><span class=\"token function\">charAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token char\">'a'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cur<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>                <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>            cur <span class=\"token operator\">=</span> cur<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre></pre></td></tr><tr><td data-num=\"64\"></td><td><pre><span class=\"token comment\">/**</pre></td></tr><tr><td data-num=\"65\"></td><td><pre> * Your Trie object will be instantiated and called as such:</pre></td></tr><tr><td data-num=\"66\"></td><td><pre> * Trie* obj = new Trie();</pre></td></tr><tr><td data-num=\"67\"></td><td><pre> * obj->insert(word);</pre></td></tr><tr><td data-num=\"68\"></td><td><pre> * bool param_2 = obj->search(word);</pre></td></tr><tr><td data-num=\"69\"></td><td><pre> * bool param_3 = obj->startsWith(prefix);</pre></td></tr><tr><td data-num=\"70\"></td><td><pre> */</span></pre></td></tr></table></figure><h1 id=\"单词的压缩编码\"><a class=\"markdownIt-Anchor\" href=\"#单词的压缩编码\">#</a> 单词的压缩编码</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zaG9ydC1lbmNvZGluZy1vZi13b3Jkcy8=\">820. 单词的压缩编码 - 力扣（LeetCode）</span></p>\n<p>单词数组 words 的 有效编码 由任意助记字符串 s 和下标数组 indices 组成，且满足：</p>\n<ul>\n<li>words.length == indices.length</li>\n<li>助记字符串 s 以 ‘#’ 字符结尾</li>\n<li>对于每个下标 indices [i] ，s 的一个从 indices [i] 开始、到下一个 ‘#’ 字符结束（但不包括 ‘#’）的 子字符串 恰好与 words [i] 相等</li>\n</ul>\n<p>给你一个单词数组 words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。</p>\n<p>示例 1：</p>\n<p>输入：words = [“time”, “me”, “bell”]<br>\n 输出：10<br>\n 解释：一组有效编码为 s = “time#bell#” 和 indices = [0, 2, 5] 。<br>\nwords [0] = “time” ，s 开始于 indices [0] = 0 到下一个 ‘#’ 结束的子字符串，如加粗部分所示 “time#bell#”<br>\nwords [1] = “me” ，s 开始于 indices [1] = 2 到下一个 ‘#’ 结束的子字符串，如加粗部分所示 “time#bell#”<br>\nwords [2] = “bell” ，s 开始于 indices [2] = 5 到下一个 ‘#’ 结束的子字符串，如加粗部分所示 “time#bell#”</p>\n<p>示例 2：</p>\n<p>输入：words = [“t”]<br>\n 输出：2<br>\n 解释：一组有效编码为 s = “t#” 和 indices = [0] 。</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= words.length &lt;= 2000</code></li>\n<li><code>1 &lt;= words[i].length &lt;= 7</code></li>\n<li><code>words[i]</code>  仅由小写字母组成</li>\n</ul>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>p</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> <span class=\"token function\">minimumLengthEncoding</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> words<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure>",
            "tags": [
                "DataBase"
            ]
        },
        {
            "id": "https://adventure-yx.github.io/2023/03/06/CMU15-445/",
            "url": "https://adventure-yx.github.io/2023/03/06/CMU15-445/",
            "title": "CMU15-445（2022Fall）",
            "date_published": "2023-03-05T16:03:56.000Z",
            "content_html": "<p>Schedule | CMU 15-445/645 :: Intro to Database Systems (Fall 2022)](<span class=\"exturl\" data-url=\"aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMjIvc2NoZWR1bGUuaHRtbA==\">https://15445.courses.cs.cmu.edu/fall2022/schedule.html</span>)</p>\n<h1 id=\"lesson01-关系模型关系代数\"><a class=\"markdownIt-Anchor\" href=\"#lesson01-关系模型关系代数\">#</a> Lesson#01. 关系模型 &amp; 关系代数</h1>\n<p>Relational Model &amp; Relational Algebra</p>\n<h2 id=\"数据库\"><a class=\"markdownIt-Anchor\" href=\"#数据库\">#</a> 数据库</h2>\n<p>数据库 (Database,DB) 是一个有组织的、互相关联的、对现实世界的某些方面进行建模的集合。</p>\n<p>严格来讲，数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度 ()、较高的数据独立性 () 和易扩展性 ()，并可为各种用户共享。</p>\n<p>本笔记中，用一个存储着艺术家和对应的专辑信息的数据库作为例子，亦即数字音乐商店 (A database that models a digital music store)。</p>\n<h2 id=\"flat-file-strawman\"><a class=\"markdownIt-Anchor\" href=\"#flat-file-strawman\">#</a> Flat File Strawman</h2>\n<p>数据库常常以 CSV (comma-separated value) 文件的形式存储，由 DBMS 进行管理。每次应用程序要读取或者更新记录时，都必须解析文件 (parse files)。</p>\n<p>以数字音乐商店的例子，会有两个文件，一是艺术家，二是专辑。</p>\n<p>每个实体都有自己的属性集，所以在每个文件中，不同的记录都用新的行来划分，而一条记录中的每个相应属性都用逗号隔开。</p>\n<p>例子：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Name</th>\n<th style=\"text-align:left\">Year</th>\n<th style=\"text-align:left\">Country</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Wu-Tang Clan</td>\n<td style=\"text-align:left\">1992</td>\n<td style=\"text-align:left\">USA</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Notorious BIG</td>\n<td style=\"text-align:left\">1992</td>\n<td style=\"text-align:left\">USA</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GZE</td>\n<td style=\"text-align:left\">1990</td>\n<td style=\"text-align:left\">USA</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Issues with Flat File</strong></p>\n<ul>\n<li>\n<p>Data Integrity</p>\n<p>数据完整性</p>\n</li>\n<li>\n<p>Implementation<br>\n 执行</p>\n</li>\n<li>\n<p>Durability<br>\n 耐受性</p>\n</li>\n</ul>\n<h2 id=\"数据库管理系统\"><a class=\"markdownIt-Anchor\" href=\"#数据库管理系统\">#</a> 数据库管理系统</h2>\n<p>一个 Database Management System (DBMS) 是一个能让应用在数据库中保存与分析数据的软件</p>\n<p>通常，DBMS 设计的目的是允许定义、创建、查询、更新和管理符合某种数据模型的数据库。</p>\n<ul>\n<li>\n<p><strong>Data model：</strong><br>\n数据模型是描述数据库中数据的概念的集合。A data model is a collection of concepts for describing the data in database.</p>\n<p>Example: Relational (most common), NoSQL (key/value, graph, Document, Column-family), array/matrix/vectors</p>\n<ul>\n<li><strong>Relational</strong></li>\n<li>Key/Value (Redis)</li>\n<li>Graph</li>\n<li>Document</li>\n<li>Column-family 列族数据库</li>\n<li>Array/Matrix (machine learning)</li>\n</ul>\n</li>\n<li>\n<p><strong>Schema：</strong><br>\n模式是对基于数据模型的特定数据集合的描述。</p>\n</li>\n</ul>\n<p>Early DBMSs</p>\n<p>早期，数据库应用很难建立和维护，因为逻辑层和物理层之间存在着高度耦合 (a tight coupling between logical and physical layers)。</p>\n<ul>\n<li>逻辑层：<br>\n描述了数据库有哪些实体和属性。</li>\n<li>物理层：<br>\n是这些实体和属性的存储方式。</li>\n</ul>\n<p>所以早期的数据库，一旦改变了物理层，逻辑层也得跟着变。</p>\n<h2 id=\"关系模型\"><a class=\"markdownIt-Anchor\" href=\"#关系模型\">#</a> 关系模型</h2>\n<p>人们每次改变物理层都要重新写数据管理系统，故 Ted Codd 注意到后提出了关系模型（Relational Model）。</p>\n<ul>\n<li>\n<p><strong>Relational Model：</strong></p>\n<p>关系模型定义了一个基于关系的数据库抽象概念，有 3 个关键点：</p>\n<ul>\n<li>Store database in simple data structures (relations).</li>\n<li>Access data through high-level language, DBMS figures out best execution strategy.</li>\n<li>Physical storage left up to the DBMS implementation.</li>\n</ul>\n<p>简单来说就是：用简单的数据结构保存，用高级语言来访问，并让 DBMS 来执行最优策略以及处理物理层存储。</p>\n</li>\n<li>\n<p><strong>关系模型定义的三个概念：</strong></p>\n<ul>\n<li><strong>Structure：</strong><br>\n关系定义和内容。也就是关系具有的属性以及可以有的值。</li>\n<li><strong>Integrity：</strong><br>\n确保数据库的内容满足约束条件。比如：年份必须是数字。</li>\n<li><strong>Manipulation：</strong><br>\n如何访问和修改数据库的内容。</li>\n</ul>\n</li>\n<li>\n<p><strong>关系 (relation)：</strong><br>\n关系是一个<strong>无序的集合 (an unordered set)</strong>，包含代表的实体的属性关系。因为是无序的，所以 DBMS 可以用它想要的任何方式存储它们，并允许优化。</p>\n</li>\n<li>\n<p><strong>元组 (tuple)：</strong><br>\n元组指的是<strong>关系中的一组属性值 (a set of attribute values in the relation, also known as its domain)</strong>。</p>\n<p>Originally, values had to be atomic or scalar, but now values can also be lists or nested data structures. Every attribute can be a special value, NULL, which means for a given tuple the attribute is undefined.</p>\n<p>起初，值必须是<strong>原子的 (atomic)<strong> 或者</strong>标量 (scalar)</strong>，但现在值也可以是一个特殊的值 <code>NULL</code> ，表示为定义。</p>\n</li>\n<li>\n<p><strong>有 n 个属性的关系，叫做：n-ary relation</strong>。</p>\n</li>\n<li>\n<p>一张二维表，每行对应一个元组，每列对应一个域。</p>\n</li>\n<li>\n<p><strong>Keys：</strong><br>\n一个关系的<strong> primary key</strong> 唯一的定义了单个元组。很多 DBMS 都支持 auto-generated keys，所以程序就不需要手动增加了，但 primary key 还是在某些 DBMS 是需要的。</p>\n<ul>\n<li>Primary key / 主键：唯一的定义了单个元组。</li>\n<li>Foreign key / 外键：指定一个关系中的属性必须映射到另一个关系中的元组。</li>\n</ul>\n<p><img data-src=\"image-20230312011848991.png\" alt=\"image-20230312011848991\"></p>\n</li>\n</ul>\n<h2 id=\"数据操纵语言\"><a class=\"markdownIt-Anchor\" href=\"#数据操纵语言\">#</a> 数据操纵语言</h2>\n<p>DML（data manipulation language）是数据操纵语言：它们是 SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这 4 条命令是用来对数据库里的数据进行操作的语言。</p>\n<p>DDL（data definition language）是数据定义语言：DDL 比 DML 要多，主要的命令有 CREATE、ALTER、DROP 等，DDL 主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。</p>\n<p>DCL（Data Control Language）是数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke 等）语句。</p>\n<p>有两类语言去保存和检索在数据库中的信息。</p>\n<ul>\n<li>Procedural：<br>\nThe query specifies the (high-level) strategy the DBMS should use to find the desired result based on sets / bags. (<strong>relational algebra</strong>)</li>\n<li>Non-Procedural (Declarative 声明式的)：<br>\nThe query specifies only what data is wanted and not how to find it. (<strong>relational calculus</strong>)</li>\n</ul>\n<p>一般现在都是用第二种的，我不管 DBMS 用什么策略，我只需要你给我我想要的数据。</p>\n<h2 id=\"关系代数\"><a class=\"markdownIt-Anchor\" href=\"#关系代数\">#</a> 关系代数</h2>\n<p>关系代数 (Relational Algebra) 就是一组基本操作，用于检索和操作关系中的图元。</p>\n<p>每个操作符都需要一个或多个关系作为输入，并输出一个新的关系。为了编写查询，我们可以把这些运算符 &quot;链&quot; 在一起，以创建更复杂的操作。</p>\n<p><img data-src=\"image-20230312012338736.png\" alt=\"image-20230312012338736\"></p>\n<p><strong>Select</strong> takes in a relation and outputs a subset of the tuples from that relation that satisfy a selection predicate. The predicate acts like a filter, and we can combine multiple predicates using conjunctions and disjunctions.</p>\n<p><img data-src=\"image-20230312012550025.png\" alt=\"image-20230312012550025\"></p>\n<p><strong>Projection</strong> takes in a relation and outputs a relation with tuples that contain only specified attributes. You can rearrange the ordering of the attributes in the input relation as well as manipulate the values.</p>\n<p><img data-src=\"image-20230312012612509.png\" alt=\"image-20230312012612509\"></p>\n<p><strong>Union</strong> takes in two relations and outputs a relation that contains all tuples that appear in at least one of the input relations. Note: The two input relations have to have the exact same attributes.</p>\n<p><img data-src=\"image-20230312012638191.png\" alt=\"image-20230312012638191\"></p>\n<p><strong>Intersection</strong> takes in two relations and outputs a relation that contains all tuples that appear in both of the input relations. Note: The two input relations have to have the exact same attributes.</p>\n<p><img data-src=\"image-20230312012655770.png\" alt=\"image-20230312012655770\"></p>\n<p><strong>Difference</strong> takes in two relations and outputs a relation that contains all tuples that appear in the first relation but not the second relation. Note: The two input relations have to have the exact same attributes.</p>\n<p><img data-src=\"image-20230312012712525.png\" alt=\"image-20230312012712525\"></p>\n<p><strong>Product</strong> (笛卡尔积) takes in two relations and outputs a relation that contains all possible combinations for tuples from the input relations.</p>\n<p><img data-src=\"image-20230312012728132.png\" alt=\"image-20230312012728132\"></p>\n<p><strong>Join</strong> takes in two relations and outputs a relation that contains all the tuples that are a combination of two tuples where for each attribute that the two relations share, the values for that attribute of both tuples is the same.</p>\n<p><img data-src=\"image-20230312012750042.png\" alt=\"image-20230312012750042\"></p>\n<h1 id=\"lesson02-高级sql\"><a class=\"markdownIt-Anchor\" href=\"#lesson02-高级sql\">#</a> Lesson#02. 高级 SQL</h1>\n<p>Advanced SQL</p>\n<p><strong>SQL</strong> (Structured Query Language: 结构化查询语言) 是用于管理关系数据库管理系统（RDBMS）。 SQL 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。</p>\n<p>DML（data manipulation language）是数据操纵语言：它们是 SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这 4 条命令是用来对数据库里的数据进行操作的语言。</p>\n<p>DDL（data definition language）是数据定义语言：DDL 比 DML 要多，主要的命令有 CREATE、ALTER、DROP 等，DDL 主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。</p>\n<p>DCL（Data Control Language）是数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke 等）语句。</p>\n<p>用户只需要使用声明性语言（即 SQL）来指定他们想要的结果。DBMS 负责确定产生该答案的最有效计划。</p>\n<p>关系代数基于 sets (unordered, no duplicates)。<br>\nSQL 基于 bags (unordered, allows duplicates)</p>\n<h2 id=\"sql基础语法\"><a class=\"markdownIt-Anchor\" href=\"#sql基础语法\">#</a> SQL 基础语法</h2>\n<ul>\n<li>\n<p><strong>SELECT 语句</strong></p>\n<p>SELECT 语句用于从数据库中选取数据。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> table_name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> table_name<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>SELECT DISTINCT 语句用于返回唯一不同的值。在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。</p>\n<p><strong>DISTINCT 关键词</strong>用于返回唯一不同的值。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">DISTINCT</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> table_name<span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p><strong>WHERE 子句</strong></p>\n<p>WHERE 子句用于提取那些满足指定条件的记录。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> table_name</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> condition<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> Websites <span class=\"token keyword\">WHERE</span> country<span class=\"token operator\">=</span><span class=\"token string\">'CN'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>WHERE 子句中的运算符</p>\n<p>下面的运算符可以在 WHERE 子句中使用：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">运算符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">=</td>\n<td style=\"text-align:left\">等于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;&gt;</td>\n<td style=\"text-align:left\">不等于。注释：在 SQL 的一些版本中，该操作符可被写成！=</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&gt;</td>\n<td style=\"text-align:left\">大于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;</td>\n<td style=\"text-align:left\">小于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">大于等于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;=</td>\n<td style=\"text-align:left\">小于等于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">BETWEEN</td>\n<td style=\"text-align:left\">在某个范围内</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LIKE</td>\n<td style=\"text-align:left\">搜索某种模式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IN</td>\n<td style=\"text-align:left\">指定针对某个列的多个可能值</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p><strong>AND &amp; OR 运算符</strong></p>\n<p>AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。</p>\n<p>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</p>\n<p>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> Websites</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">WHERE</span> alexa <span class=\"token operator\">></span> <span class=\"token number\">15</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">AND</span> <span class=\"token punctuation\">(</span>country<span class=\"token operator\">=</span><span class=\"token string\">'CN'</span> <span class=\"token operator\">OR</span> country<span class=\"token operator\">=</span><span class=\"token string\">'USA'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p><strong>ORDER BY 关键字</strong></p>\n<p>ORDER BY 关键字用于对结果集进行排序，对结果集按照一个列或者多个列进行排序。</p>\n<p>默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> table_name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">ASC</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">DESC</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p><strong>INSERT INTO 语句</strong></p>\n<p>INSERT INTO 语句用于向表中插入新记录。</p>\n<p>第一种形式无需指定要插入数据的列名，只需提供被插入的值即可（<strong>需要列出插入行的每一列数据</strong>）：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> table_name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span>value1<span class=\"token punctuation\">,</span>value2<span class=\"token punctuation\">,</span>value3<span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>第二种形式需要指定列名及被插入的值：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> table_name <span class=\"token punctuation\">(</span>column1<span class=\"token punctuation\">,</span>column2<span class=\"token punctuation\">,</span>column3<span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span>value1<span class=\"token punctuation\">,</span>value2<span class=\"token punctuation\">,</span>value3<span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p><strong>UPDATE 语句</strong></p>\n<p>UPDATE 语句用于更新表中已存在的记录。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">UPDATE</span> table_name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SET</span> column1 <span class=\"token operator\">=</span> value1<span class=\"token punctuation\">,</span> column2 <span class=\"token operator\">=</span> value2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> condition<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">UPDATE</span> Websites </pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">SET</span> alexa<span class=\"token operator\">=</span><span class=\"token string\">'5000'</span><span class=\"token punctuation\">,</span> country<span class=\"token operator\">=</span><span class=\"token string\">'USA'</span> </pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">WHERE</span> name<span class=\"token operator\">=</span><span class=\"token string\">'菜鸟教程'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>如果我们省略了 WHERE 子句，执行以上代码会将 Websites 表中所有数据的 alexa 改为 5000，country 改为 USA。</p>\n</li>\n<li>\n<p><strong>DELETE 语句</strong></p>\n<p>DELETE 语句用于删除表中的行。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> table_name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">WHERE</span> condition<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>删除所有数据</p>\n<p>您可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> table_name<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>** 注释：** 在删除记录时要格外小心！因为您不能重来！</p>\n</li>\n</ul>\n<h2 id=\"joins\"><a class=\"markdownIt-Anchor\" href=\"#joins\">#</a> Joins</h2>\n<p>结合一个或多个表的列，产生一个新的表。用来表达涉及跨越多个表的数据的查询，</p>\n<ul>\n<li>\n<p>本节课举例用的例子：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> student <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    sid <span class=\"token keyword\">INT</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    name <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    login <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">UNIQUE</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    age <span class=\"token keyword\">SMALLINT</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    gpa <span class=\"token keyword\">FLOAT</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> course <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    cid <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    name <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> enrolled <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    sid <span class=\"token keyword\">INT</span> <span class=\"token keyword\">REFERENCES</span> student <span class=\"token punctuation\">(</span>sid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    cid <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">REFERENCES</span> course <span class=\"token punctuation\">(</span>cid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    grade <span class=\"token keyword\">CHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>哪个学生在 15-721 拿到了 A?</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> s<span class=\"token punctuation\">.</span>name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> enrolled <span class=\"token keyword\">AS</span> e<span class=\"token punctuation\">,</span> student <span class=\"token keyword\">AS</span> s</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> e<span class=\"token punctuation\">.</span>grade <span class=\"token operator\">=</span> <span class=\"token string\">'A'</span> <span class=\"token operator\">AND</span> e<span class=\"token punctuation\">.</span>cid <span class=\"token operator\">=</span> <span class=\"token string\">'15-721'</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token operator\">AND</span> e<span class=\"token punctuation\">.</span>sid <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span>sid<span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"aggregate函数\"><a class=\"markdownIt-Anchor\" href=\"#aggregate函数\">#</a> Aggregate 函数</h2>\n<p>聚合函数接受一组列表，然后产生一个单一的标量值作为其输出。基本上只能在 SELECT 输出列表中使用！</p>\n<ul>\n<li>\n<p>AVG(COL): The average of the values in COL</p>\n</li>\n<li>\n<p>MIN(COL): The minimum value in COL</p>\n</li>\n<li>\n<p>MAX(COL): The maximum value in COL</p>\n</li>\n<li>\n<p>SUM(COL)</p>\n</li>\n<li>\n<p>COUNT(COL): The number of tuples in the relation</p>\n</li>\n<li>\n<p>例子 1：</p>\n<p>Get # of students with a ‘@cs’ login.</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> login <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%@cs'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span>login<span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> login <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%@cs'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> login <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%@cs'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>例子 2：</p>\n<p>Get # of students and their average GPA with a ‘@cs’ login.</p>\n<p>得到 <code>@cs</code>  登录的学生的人数和平均 GPA</p>\n<pre><code class=\"language-SQL\">SELECT AVG(gpa), COUNT(sid)\n  FROM student WHERE login LIKE '%@cs';\n</code></pre>\n<p>有些聚合函数支持 <code>DISTINCT</code>  关键字</p>\n<p>Get # of unique students and their average GPA with a ‘@cs’ login.</p>\n<p>得到通过 <code>@cs</code>  登录的学生数量，以及他们的 GPA, 要求学生不能重复！</p>\n<pre><code class=\"language-SQL\">SELECT COUNT(DISTINCT login)\n  FROM student WHERE login LIKE '%@cs';\n</code></pre>\n</li>\n<li>\n<p>Non-aggregated values in SELECT output clause must appear in GROUP BY clause</p>\n<p>例子 3：Get the average GPA of students in each course.</p>\n<p>得到在每个课上的学生的平均 GPA</p>\n<pre><code class=\"language-SQL\">SELECT AVG(s.gpa), e.cid\n  FROM enrolled AS e, student AS s\n WHERE e.sid = s.sid\n GROUP BY e.cid;\n</code></pre>\n</li>\n<li>\n<p>HAVING 子句在聚合计算的基础上过滤输出结果。这使得 HAVING 的行为像一个 GROUP BY 的 WHERE 子句。</p>\n<p>The HAVING clause filters output results based on aggregation computation.</p>\n<p>This make HAVING behave like a WHERE clause for a GROUP BY.</p>\n<p>例子 5：获取学生平均 GPA 大于 3.9 的课程。</p>\n<pre><code class=\"language-SQL\">SELECT AVG(s.gpa) AS avg_gpa, e.cid\n  FROM enrolled AS e, student AS s\n WHERE e.sid = s.sid\n GROUP BY e.cid\nHAVING avg_gpa &gt; 3.9;\n</code></pre>\n<p>上述查询语法被许多主要的数据库系统所支持，但不符合 SQL 标准。</p>\n<p>为了使查询符合标准，我们必须在 AVG (S.GPA) 的主体中重复使用 HAVING 子句</p>\n<pre><code class=\"language-SQL\">SELECT AVG(s.gpa), e.cid\nFROM enrolled AS e, student AS s\nWHERE e.sid = s.sid\nGROUP BY e.cid\nHAVING AVG(s.gpa) &gt; 3.9;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"string-operations\"><a class=\"markdownIt-Anchor\" href=\"#string-operations\">#</a> String Operations</h2>\n<p>SQL 标准是区分大小写的，而且只能是单引号！有一些函数可以处理字符串，可以在查询的任何部分使用。</p>\n<ul>\n<li>\n<p>Pattern Matching:</p>\n<p><strong>LIKE 操作符</strong>用于在 WHERE 子句中搜索列中的指定模式。</p>\n<pre><code class=\"language-SQL\">SELECT column1, column2, ...\nFROM table_name\nWHERE column LIKE pattern;\n</code></pre>\n</li>\n<li>\n<p>通配符</p>\n<ul>\n<li><code>%</code>  替代 0 个或多个字符</li>\n<li><code>_</code> 替代一个字符</li>\n</ul>\n</li>\n<li>\n<p><strong>String Function:</strong><br>\n <code>SUBSTRING(S, B, E)</code> <br>\n <code>UPPER(S)</code></p>\n</li>\n<li>\n<p><strong>Concatenation:</strong><br>\n<img data-src=\"image-20230313134548756.png\" alt=\"image-20230313134548756\"></p>\n</li>\n</ul>\n<h2 id=\"date-and-time\"><a class=\"markdownIt-Anchor\" href=\"#date-and-time\">#</a> Date and Time</h2>\n<ul>\n<li>\n<p>时间函数</p>\n<ol>\n<li>当前日期时间<br>\n <code>NOW()</code> ,  <code>CURRENT_TIMESTAMP()</code></li>\n<li>当前 UNIX 时间戳<br>\n <code>UNIX_TIMESTAMP()</code></li>\n<li>当前日期<br>\n <code>CURRENT_DATE()</code></li>\n<li>当前时间<br>\n <code>CURRENT_TIME()</code></li>\n</ol>\n</li>\n<li>\n<p>日期时间转换函数</p>\n<ol>\n<li>\n<p>当前时间戳转换为北京时间<br>\n <code>FROM_UNIXTIME()</code></p>\n</li>\n<li>\n<p>北京时间转换为时间戳<br>\n <code>UNIX_TIMESTAMP()</code></p>\n</li>\n<li>\n<p>时间中解析年月日时间<br>\n <code>DATE_FORMAT(date, format)</code></p>\n<pre><code>select DATE_FORMAT('2021-01-01 08:30:50','%Y-%m-%d')\n</code></pre>\n</li>\n</ol>\n</li>\n<li>\n<p>日期时间运算函数</p>\n<ol>\n<li>\n<p>在某个时间的基础上加上或者减去某个时间<br>\n <code>DATE_ADD(date,INTERVAL expr unit)</code> <br>\n <code>DATE_SUB(date,INTERVAL expr unit)</code></p>\n</li>\n<li>\n<p>返回两个日期值之间的天数<br>\n <code>DATEDIFF(expr1,expr2))</code></p>\n<pre><code>select DATEDIFF('2021-01-02','2021-01-01')\n</code></pre>\n</li>\n<li>\n<p>时间差函数<br>\n <code>TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)</code></p>\n<p>unit：天 (DAY)、小时 (HOUR），分钟 (MINUTE) 和秒 (SECOND)，TIMESTAMPDIFF 函数比 DATEDIFF 函数用起来更加灵活</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"输出重定向\"><a class=\"markdownIt-Anchor\" href=\"#输出重定向\">#</a> 输出重定向</h2>\n<p>Output Redirection</p>\n<p>你可以告诉 DBMS 将查询结果存储到另一个表中，而不是将查询结果返回给客户端（例如，终端）。结果存储到另一个表中。然后你可以在随后的查询中访问这些数据</p>\n<ul>\n<li>\n<p>New Table: 将查询的输出存储到一个新的（永久）表中</p>\n<pre><code>SELECT DISTINCT cid INTO CourseIds FROM enrolled;\n</code></pre>\n</li>\n<li>\n<p>Exustubg Table:</p>\n<p>将查询的输出存储到数据库中已经存在的表中。该表 目标表必须有与目标表相同数量和相同类型的列，但输出查询中的列名不需要匹配。</p>\n<pre><code>INSERT INTO CourseIds (SELECT DISTINCT cid FROM enrolled)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"输出控制\"><a class=\"markdownIt-Anchor\" href=\"#输出控制\">#</a> 输出控制</h2>\n<p>Output Control</p>\n<p>因为 SQL 是无序的，我们可以用 ORDER BY 来对输出进行排序</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> sid<span class=\"token punctuation\">,</span> grade <span class=\"token keyword\">FROM</span> enrolled <span class=\"token keyword\">WHERE</span> cid <span class=\"token operator\">=</span> <span class=\"token string\">'15-721'</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> grade<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>后面可以加 <code>DESC</code> ,  <code>ASC</code>  来指定排序策略</p>\n<p>输出的数量可以用 <code>LIMIT n</code>  进行指定</p>\n<p>当然也可以用 <code>OFFSET</code>  来提供一个 bias。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> sid<span class=\"token punctuation\">,</span> name <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> login <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%@cs'</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">LIMIT</span> <span class=\"token number\">20</span> <span class=\"token keyword\">OFFSET</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"内部查询查询嵌套\"><a class=\"markdownIt-Anchor\" href=\"#内部查询查询嵌套\">#</a> 内部查询 / 查询嵌套</h2>\n<p>Nested Queries</p>\n<p>在其他查询中调用查询，在单个查询中执行更复杂的逻辑。嵌套查询往往难以优化。</p>\n<p>外部查询的范围包括在内部查询中（即内部查询可以访问来自外部<br>\n查询），反之不行。</p>\n<ul>\n<li>\n<p>内部查询几乎可以出现在一个查询的任何部分。</p>\n<p><code>SELECT</code>  Output Targets</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> one <span class=\"token keyword\">FROM</span> student<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><code>FROM</code>  Clause:</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">AS</span> s<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> sid <span class=\"token keyword\">FROM</span> enrolled<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> e</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">WHERE</span> s<span class=\"token punctuation\">.</span>sid <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>sid<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><code>WHERE</code>  Clause</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> name <span class=\"token keyword\">FROM</span> student</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">WHERE</span> sid <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">SELECT</span> sid <span class=\"token keyword\">FROM</span> enrolled <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>例子： 获取在 15-445 中注册的学生名字</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> name <span class=\"token keyword\">FROM</span> student</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">WHERE</span> sid <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">SELECT</span> sid <span class=\"token keyword\">FROM</span> enrolled</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">WHERE</span> cid <span class=\"token operator\">=</span> <span class=\"token string\">'15-445'</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n<p>请注意，根据它在查询中出现的位置，sid 有不同的范围。</p>\n<ul>\n<li>\n<p>例子：<br>\n找到注册了至少一门课的最大的学生 id</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> student<span class=\"token punctuation\">.</span>sid<span class=\"token punctuation\">,</span> name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token keyword\">FROM</span> student</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">JOIN</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> <span class=\"token function\">MAX</span><span class=\"token punctuation\">(</span>sid<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> sid</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">FROM</span> enrolled<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> max_e</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">ON</span> student<span class=\"token punctuation\">.</span>sid <span class=\"token operator\">=</span> max_e<span class=\"token punctuation\">.</span>sid<span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n<p>Nested Query Results Expressions:</p>\n<ul>\n<li>\n<p>关键字：</p>\n<ul>\n<li><code>ALL</code> <br>\nMust satisfy expression for all rows in sub-query</li>\n<li><code>ANY</code> <br>\nMust satisfy expression for at least one row in sub-query.</li>\n<li><code>IN</code> <br>\nEquivalent to =ANY().</li>\n<li><code>EXISTS</code> <br>\nAt least one row is returned.</li>\n</ul>\n</li>\n<li>\n<p>例子：</p>\n<p>找到所有没有学生注册的课</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> course</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">WHERE</span> <span class=\"token operator\">NOT</span> <span class=\"token keyword\">EXISTS</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> enrolled</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">WHERE</span> course<span class=\"token punctuation\">.</span>cid <span class=\"token operator\">=</span> enrolled<span class=\"token punctuation\">.</span>cid</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"窗口函数\"><a class=\"markdownIt-Anchor\" href=\"#窗口函数\">#</a> 窗口函数</h2>\n<p>A <strong>window function</strong> perform “sliding” calculation across a set of tuples that are related. Like an aggregation but tuples are not grouped into a single output tuple.</p>\n<ul>\n<li>\n<p>函数： 窗口函数可以是我们上面讨论的任何一个聚合函数。也有一些特殊的窗口函数。</p>\n<ol>\n<li><code>ROW_NUMBER</code> : 当前列的数字</li>\n<li><code>RANK</code> : 当前列的顺序</li>\n</ol>\n</li>\n<li>\n<p>Grouping: <strong>OVER 子句指定了在计算窗口函数时如何对图元进行分组</strong>。使用 PARTITION BY 来指定分组</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> cid<span class=\"token punctuation\">,</span> sid<span class=\"token punctuation\">,</span> ROW_NUMBER<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">OVER</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">PARTITION</span> <span class=\"token keyword\">BY</span> cid<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token keyword\">FROM</span> enrolled <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> cid<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们也可以在 OVER 中放入 ORDER BY，以确保结果的确定性排序，即使数据库内部发生变化。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> ROW_NUMBER<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">OVER</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> cid<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">FROM</span> enrolled <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> cid<span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p><strong>重要提示：</strong></p>\n</li>\n<li>\n<p>DBMS 在窗函数排序后计算 <code>RANK</code> ，而在排序前计算 <code>ROW_NUMBER</code> 。</p>\n<ul>\n<li>\n<p>找到每门课程中成绩第二高的学生</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> RANK<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">OVER</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">PARTITION</span> <span class=\"token keyword\">BY</span> cid</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> grade <span class=\"token keyword\">ASC</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> rank</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">FROM</span> enrolled<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> ranking</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">WHERE</span> ranking<span class=\"token punctuation\">.</span>rank <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"通用表表达式\"><a class=\"markdownIt-Anchor\" href=\"#通用表表达式\">#</a> 通用表表达式</h2>\n<p>在编写更复杂的查询时，通用表表达式（CTE，Commom Table Expressions）是窗口或嵌套查询的一种替代方法。复杂的查询时，可以替代窗口或嵌套查询。它们提供了一种方法来为用户在一个更大的查询中编写辅助语句.</p>\n<p>可以理解为一个辅助表。</p>\n<p><code>WITH</code>  子句将内部查询的输出与一个具有该名称的临时结果绑定。</p>\n<ul>\n<li>\n<p>例子：<br>\n生成一个名为 cteName 的 CTE，其中包含一个单一属性设置为 &quot;1&quot; 的元组。从这个 CTE 中选择所有属性。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">WITH</span> cteName <span class=\"token keyword\">AS</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">SELECT</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> cteName<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们可以在 AS 之前将输出列绑定到名称上</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">WITH</span> cteName <span class=\"token punctuation\">(</span>col1<span class=\"token punctuation\">,</span> col2<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">SELECT</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">SELECT</span> col1 <span class=\"token operator\">+</span> col2 <span class=\"token keyword\">FROM</span> cteName<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>一个查询可能包含多个 CTE 声明</p>\n<pre><code>WITH cte1 (col1) AS (SELECT 1), cte2 (col2) AS (SELECT 2)\nSELECT * FROM cte1, cte2;\n</code></pre>\n</li>\n<li>\n<p>递归能力<br>\n在 WITH 后面添加 RECURSIVE 关键字允许 CTE 引用自己。这使得在 SQL 查询中可以实现递归。有了递归的 CTE，SQL 被证明是图灵完备的，这意味着它在计算上的表现力不亚于更多的通用编程语言</p>\n</li>\n<li>\n<p>例子：打印从 1 到 10 的数字</p>\n<pre><code>WITH RECURSIVE cteSource (counter) AS (\n    ( SELECT 1 )\n    UNION\n    ( SELECT counter + 1 FROM cteSource\n    \tWHERE counter &lt; 10 )\n)\nSELECT * FROM cteSource;\n</code></pre>\n</li>\n</ul>\n<h1 id=\"lesson0304-存储引擎\"><a class=\"markdownIt-Anchor\" href=\"#lesson0304-存储引擎\">#</a> Lesson#03&amp;04. 存储引擎</h1>\n<h2 id=\"storage\"><a class=\"markdownIt-Anchor\" href=\"#storage\">#</a> Storage</h2>\n<ul>\n<li>\n<p>我们将关注一个 &quot;面向磁盘 (disk-oriented)&quot; 的 DBMS 架构，它假定<strong>数据库的主要存储位置是在非易失性磁盘上（落盘）</strong>。越接近 CPU，存储就越快，容量越小，也更贵。</p>\n<ul>\n<li>Volatile Devices （MEMORY）</li>\n<li>Non-Volatile Devices （DISK）</li>\n</ul>\n<blockquote>\n<p>注意：本课程不讨论 NVMe SSD – non-volatile memory express.</p>\n</blockquote>\n</li>\n<li>\n<p>We will focus on hiding the latency of the disk rather than optimizations with registers and caches since getting data from disk is so slow. 我们将专注于隐藏磁盘的延迟，而不是使用寄存器和缓存进行优化，因为从磁盘获取数据非常缓慢。</p>\n<p><img data-src=\"image-20230313140745881.png\" alt=\"image-20230313140745881\"></p>\n</li>\n<li>\n<p>SQUENTIAL ACCESS VS. RANDOM ACCESS</p>\n</li>\n</ul>\n<h2 id=\"disk-oriented-dbms-overview\"><a class=\"markdownIt-Anchor\" href=\"#disk-oriented-dbms-overview\">#</a> Disk-Oriented DBMS Overview</h2>\n<p>数据库都在磁盘上，数据库文件中的数据被组织成页，第一页是目录页。为了对数据进行操作，DBMS 需要将数据引入内存。</p>\n<ul>\n<li>它通过拥有<strong>一个缓冲池来管理数据在磁盘和内存之间的交换</strong></li>\n<li>DBMS 也有一个执行查询的执行引擎。执行引擎将要求缓冲池提供一个特定的页面，而缓冲池将负责把该页面带入内存，并给执行引擎一个指向内存中该页面的指针<br>\n缓冲池管理器将确保在执行引擎对该部分内存进行操作时，该页就在那里。</li>\n</ul>\n<h2 id=\"dbms-vs-os\"><a class=\"markdownIt-Anchor\" href=\"#dbms-vs-os\">#</a> DBMS vs. OS</h2>\n<ul>\n<li>DBMS 的一个高级设计目标是支持超过可用内存量的数据库。因为访问 disk 的代价很大，所以使用 disk 应该要小心。我们不希望从磁盘上访问数据时停顿太久，从而拖慢其他一切。我们希望 DBMS 能够处理在等待从磁盘获取数据时，能够处理其他查询。</li>\n<li>这个高层次的设计目标就像虚拟内存一样，有一个大的地址空间和一个供操作系统从磁盘引入页面的地方。</li>\n<li>实现这种虚拟内存的方法之一是使用 mmap 来映射进程地址空间中的文件内容，这使得操作系统负责在磁盘和内存之间来回移动页面。<br>\n但不幸的是，如果 mmap 遇到页面故障，进程将会被阻塞。\n<ul>\n<li>如果你需要写入，你永远不想在你的 DBMS 中使用 mmap。</li>\n<li>DBMS（几乎）总是想自己控制事情，而且可以做得更好，因为它知道更多关于被访问的数据和被处理的查询。</li>\n<li>操作系统不是你的朋友。</li>\n</ul>\n</li>\n<li>可以通过使用操作系统：\n<ul>\n<li><code>madvise</code> : 告诉操作系统你打算何时读某些页面。</li>\n<li><code>mlock</code> : 告诉操作系统不要把内存范围换到磁盘上。</li>\n<li><code>msync</code> : 告诉操作系统将内存范围刷新到磁盘。</li>\n</ul>\n</li>\n</ul>\n<p><strong>出于正确性和性能的考虑，我们不建议在 DBMS 中使用 <code>mmap</code> 。</strong></p>\n<blockquote>\n<p>Even though the system will have functionalities that seem like something the OS can provide, having the DBMS implement these procedures itself gives it better control and performance</p>\n</blockquote>\n<h2 id=\"file-storage\"><a class=\"markdownIt-Anchor\" href=\"#file-storage\">#</a> File Storage</h2>\n<ul>\n<li>在其最基本的形式中，DBMS 将数据库存储为磁盘上的文件。有些可能使用文件层次结构，有些则可能使用单个文件</li>\n<li>操作系统对这些文件的内容一无所知。只有 DBMS 知道如何解读它们的内容，因为它是以 DBMS 特有的方式编码的。</li>\n<li>DBMS 的存储管理器负责管理数据库的文件。它将文件表示为一个 页的集合。它还跟踪哪些数据被读和写到了页面上，以及这些页面有多少可用空间。这些页面中还有多少可用空间。</li>\n</ul>\n<h2 id=\"database-pages\"><a class=\"markdownIt-Anchor\" href=\"#database-pages\">#</a> Database Pages</h2>\n<ul>\n<li>\n<p>DBMS 将数据库组织在一个或多个文件中的固定大小的数据块，称为页。页面可以包含不同种类的数据（tuple、indexes 等）。</p>\n</li>\n<li>\n<p>大多数系统不会将这些类型混合在一页中。<br>\n有些系统会要求页面是自成一体（self-contained）的，也就是说，阅读每个页面所需的所有信息都在页面本身。读取每一页的所有信息都在页面本身</p>\n</li>\n<li>\n<p>每个页面都有一个独特的标识符 identifier</p>\n<ul>\n<li>\n<p>如果数据库是一个单一的文件，那么页面 ID 可以是文件的偏移量。</p>\n</li>\n<li>\n<p>大多数 DBMS 有一个中介层（indirection layer），将页面 ID 映射到文件路径和偏移量。 系统的上层会要求提供一个特定的页号。然后，存储管理程序将把这个页号变成一个文件和一个偏移量以找到该页。</p>\n</li>\n<li>\n<p>大多数 DBMS 使用固定大小的页面，以避免支持可变大小页面所需的工程开销。</p>\n<p>因为，对于可变大小的页面，删除一个页面会在文件中产生一个 hole，而 DBMS 难以用新的页面来填补。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>页在 DBMS 的 3 个概念</p>\n<ol>\n<li>Hardware page (usually 4 KB).</li>\n<li>OS page (4 KB).</li>\n<li>Database page (1-16 KB）</li>\n</ol>\n</li>\n<li>\n<p>存储设备保证写的操作是 atomic 原子的。<br>\n这意味着，如果我们的数据库页面比我们的硬件页面大，DBMS 将不得不采取额外的措施 以确保数据被安全地写出来。 因为当系统崩溃时，程序可能已经完成了将数据库页面写入磁盘的一部分</p>\n</li>\n</ul>\n<h2 id=\"database-heap\"><a class=\"markdownIt-Anchor\" href=\"#database-heap\">#</a> Database Heap</h2>\n<ul>\n<li>有几种方法可以找到 DBMS 在磁盘上想要的页面的位置，堆文件组织是其中一种方法</li>\n</ul>\n<p>堆文件是一个无序的页面集合，其中的图元是按照随机顺序存储。</p>\n<ul>\n<li>\n<p>DBMS 可以通过使用页面的链接列表或页面目录在磁盘上找到一个给定的页面 ID</p>\n<ol>\n<li>\n<p>Linked List:<br>\nHeader page 持有指向自由页列表和数据页列表的指针。然而，如果 DBMS 正在寻找一个特定的页面，它必须在数据页列表上进行顺序扫描，直到它找到它要找的页面。</p>\n</li>\n<li>\n<p>Page Directory:</p>\n<p>DBMS 维护特殊的页面，跟踪数据页的位置以及每页的可用空间。</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"page-layout\"><a class=\"markdownIt-Anchor\" href=\"#page-layout\">#</a> Page Layout</h2>\n<ul>\n<li>\n<p>每个页面都包括一个 header，记录关于页面内容的元数据。</p>\n<ul>\n<li>Page size</li>\n<li>Checksum</li>\n<li>DBMS version</li>\n<li>Transaction visibility</li>\n<li>Self-containment (Some systems like Oracle require this.)</li>\n</ul>\n</li>\n<li>\n<p>放置数据的一个 strawman 方法是 追踪 DBMS 在一个页面中存储了多少个 tuples，然后在每次添加新的 tuples 的时候追加到最后面。然而，问题出现在当 tuples 被删除或者是变长 variable-length 属性的时候</p>\n</li>\n<li>\n<p>有 2 个主流方法去在一个 page 中放置数据：</p>\n<ol>\n<li>\n<p><strong>slotted-page</strong><br>\n 页面将 slots 映射到 offsets</p>\n<ul>\n<li>Most common approach used in DBMSs today.</li>\n<li>Header keeps track of the number of used slots, the offset of the starting location of the last used slot, and a slot array, which keeps track of the location of the start of each tuple.</li>\n<li>To add a tuple, the slot array will grow from the beginning to the end, and the data of the tuples will grow from end to the beginning. The page is considered full when the slot array and the tuple data meet</li>\n</ul>\n</li>\n<li>\n<p><strong>log-structured</strong></p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"tuple-layout\"><a class=\"markdownIt-Anchor\" href=\"#tuple-layout\">#</a> Tuple Layout</h2>\n<p>tuples 本质上是一个字节序列。DBMS 的工作是将这些字节解释为属性类型和值。</p>\n<ul>\n<li>\n<p>Tuple Header：包含了 tuple 的元数据</p>\n<ul>\n<li>DBMS 的并发控制协议的可见性信息。关于哪个事务创建 / 修改了该元组</li>\n<li>NULL 值的位图。</li>\n<li>注意，DBMS 不需要在这里存储关于数据库模式的元数据。</li>\n</ul>\n</li>\n<li>\n<p>Tuple Data：数据的实际属性</p>\n<ul>\n<li>属性通常按照你创建表时指定的顺序存储</li>\n<li>大多数 DBMS 不允许一个 tuple 超过一个页面的大小。</li>\n</ul>\n</li>\n<li>\n<p>Unique Identifier</p>\n<ul>\n<li>数据库中的每个 tuple 都被分配一个唯一的标识符</li>\n<li>一般是： <code>page_id + (offset or slow)</code></li>\n<li>一个应用程序<strong>不能</strong>依赖这些 ID 来表示任何东西</li>\n</ul>\n</li>\n<li>\n<p>De-normalized Tuple Data:</p>\n<p>如果两个表是相关的，DBMS 可以 &quot;pre-join&quot; 它们，所以这些表最终会出现在<br>\n在同一个页面上。这使得读取速度加快，因为 DBMS 只需要加载一个页面而不是两个<br>\n独立的页面。然而，这使得更新更加昂贵，因为 DBMS 需要更多的空间给每个<br>\n tuples</p>\n</li>\n</ul>\n<h2 id=\"log-structured-storage\"><a class=\"markdownIt-Anchor\" href=\"#log-structured-storage\">#</a> Log-Structured Storage</h2>\n<p>（也叫 Append-only Sequence of Data） 参考: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbXV6aG9uZ2ppYW5nL3AvMTUxNTE3NTguaHRtbA==\">Log-Structured 结构</span></p>\n<ul>\n<li>\n<p>与 Slotted-Page Design 有关的问题是：</p>\n<ul>\n<li>\n<p>Fragmentation:</p>\n<p>删除 tuple 会在 page 中留下空隙。</p>\n</li>\n<li>\n<p>Useless Disk I/O:</p>\n<p>由于非易失性存储的 block-oriented 的性质，需要读取整个块来获取 tuple。</p>\n</li>\n<li>\n<p>Random Disk I/O:</p>\n<p>磁盘阅读器可能不得不跳到 20 个不同的地方来更新 20 个不同的 tuples，这可能会非常慢。</p>\n</li>\n</ul>\n<p>如果我们在一个只允许创建新数据而不允许覆盖的系统上工作呢？日志结构的存储模型与这个假设相配合，解决了上面列出的一些问题。</p>\n</li>\n<li>\n<p><strong>Log-Structured Storage:</strong> DBMS 不存储 tuples，只存储日志记录。</p>\n<ul>\n<li>将数据库如何被修改的记录存储到文件中（放入和删除）。每条日志包含 tuples 的唯一标识符</li>\n<li>要读取一条记录，DBMS 会从最新的到最旧的逆向扫描日志文件，并 &quot;重新创建&quot; 这个 tuple。</li>\n<li>写的快，读的可能慢。磁盘写入是连续的，现有的页面是不可改变的，这导致了随机磁盘 I/O 的减少。</li>\n<li>在 append-only 的存储上工作得很好，因为 DBMS 不能回溯并更新数据。</li>\n<li>为了避免长时间的读取，DBMS 可以有索引来允许它跳到日志中的特定位置。它还可以定期地压缩日志。(如果它有一个 tuple，然后对其进行了更新，它可以将其压缩到只插入更新的 tuple）。</li>\n<li>由于不再需要时间信息，数据库可以将日志压缩到一个按 id 排序的表中。这些被称为分类字符串表（SSTables），它们可以使 tuple 搜索非常快。</li>\n<li>紧凑化的问题是，DBMS 最终会出现写入放大的情况。(它一次又一次地重写相同的数据）。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"data-representation\"><a class=\"markdownIt-Anchor\" href=\"#data-representation\">#</a> Data Representation</h2>\n<ul>\n<li>\n<p>tuple 的数据本质就是字节数组！DBMS 要知道如何解释这些字节，来推导出属性的值。数据表示方案 (data representation scheme) 是 DBMS 如何为一个值存储字节。</p>\n</li>\n<li>\n<p>有 5 种 high level datatypes 可以存储在 tuples 中：integer，variable-precision numbers，fixed-point precision numbers，variable length values， dates/times</p>\n<ul>\n<li>\n<p>Integers</p>\n<p>大多数 DBMS 使用 IEEE-754 标准规定的 &quot;native&quot;C/C++ 类型来存储整数。这些值是固定长度的。</p>\n<ul>\n<li>例子：<br>\n <code>INTEGER, BIGINT, SMALLINT, TINYINT.</code></li>\n</ul>\n</li>\n<li>\n<p>Variable Precision Numbers</p>\n<p>这些是不精确的、可变精度的数字类型，使用 IEEE-754 规定的 &quot;native&quot;C/C<ins> 类型。标准规定的 &quot;native&quot;C/C</ins> 类型。这些值也是固定长度的。</p>\n<p>变精度数的运算比任意精度数的运算更快，因为 CPU 可以直接对其执行指令。然而，在进行计算时可能会出现精度损失！</p>\n<ul>\n<li>例子：<br>\n <code>FLOAT, REAL</code></li>\n</ul>\n</li>\n<li>\n<p>Fixed-Point Precision Numbers<br>\n 这些是具有任意精度和比例的数字数据类型。它们通常以精确的、可变长度的二进制表示法（像一个字符串）来存储，并带有额外的元数据，这些数据将告诉系统诸如数据的长度和小数点应该在哪里。<br>\n当误差不可接受的时候，DBMS 就要付出性能的代价来提高精度。</p>\n<ul>\n<li>例子：<br>\n <code>NUMERIC, DECIMAL.</code></li>\n</ul>\n</li>\n<li>\n<p>Variable-Length Data</p>\n<ul>\n<li>代表任意长度的数据类型。它们通常是用一个 header 来存储的，这个 header 可以追踪到字符串的长度，以便于跳转到下一个值。它还可能包含一个数据的校验和。</li>\n<li><strong>大多数 DBMS 不允许一个 tuple 超过一个页面的大小。</strong> ** 但是！** 那些允许的系统将数据存储在一个特殊的 &quot;溢出&quot; 页上，并让 tuple 包含一个对该页的引用。这些溢出页可以包含指向其他溢出页的指针，直到所有的数据都可以被存储。</li>\n<li>有些系统会让你把这些大的数值存储在一个外部文件中，然后元组会包含一个指向该文件的指针。例如，如果数据库存储的是照片信息，DBMS 可以将照片存储在外部文件中，而不是让它们占用 DBMS 中的大量空间。这样做的一个缺点是，DBMS 不能操作这个文件的内容。因此，没有耐久性或交易 保护。</li>\n<li>例子：<br>\n <code>VARCHAR, VARBINARY, TEXT, BLOB.</code></li>\n</ul>\n</li>\n<li>\n<p>Dates and Times<br>\n 不同的系统对日期 / 时间的表示方法不同。通常情况下，它们被表示为一些单位时间 (自 unix 时代的（微 / 毫）秒）。</p>\n<ul>\n<li>例子：<br>\n <code>TIME, DATE, TIMESTAMP.</code></li>\n</ul>\n</li>\n<li>\n<p>System Catalogs</p>\n<p>为了使 DBMS 能够识别 tuple 的内容，它维护了一个内部目录来告诉它关于数据库的元数据。元数据将包含关于数据库有哪些表和列的信息，以及它们的类型和值的顺序。</p>\n<p>大多数 DBMS 将其目录以其表的格式存储在自己的内部。他们使用<br>\n特殊代码来 &quot;bootstrap&quot; 这些目录表。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<ul>\n<li>数据库的数据是按页组织的，把页拼在一起就是一个数据库</li>\n<li>怎么找到页（链表、目录）</li>\n<li>页怎么存（slots、log-structured）</li>\n<li>页里的元组怎么存</li>\n</ul>\n<h1 id=\"lesson05-存储模型数据压缩\"><a class=\"markdownIt-Anchor\" href=\"#lesson05-存储模型数据压缩\">#</a> Lesson#05. 存储模型 &amp; 数据压缩</h1>\n<p>（Storage Models &amp; Compression）</p>\n<h2 id=\"数据库工作负载\"><a class=\"markdownIt-Anchor\" href=\"#数据库工作负载\">#</a> 数据库工作负载</h2>\n<p>Database Workloads</p>\n<p><strong>OLTP: Online Transaction Processing 在线事务处理</strong></p>\n<ul>\n<li>OLTP work load 的特点是快速、短时运行的操作，一次对单个实体进行操作的简单查询，以及重复性的操作。<br>\n<strong>一个 OLTP work load 通常会处理更多的写而不是读。</strong></li>\n<li>一个 OLTP work load 的例子是亚马逊的店面。用户可以把东西添加到他们的 Manag 购物车，他们可以 进行购买，但这些行为只影响他们的账户。</li>\n</ul>\n<p><strong>OLAP: Online Analytical Processing 在线分析处理</strong></p>\n<ul>\n<li>OLAP work load 的特点是<strong>长期运行的、复杂的查询</strong>，<strong>对数据库的很大一部分进行读取</strong>。在 OLAP 工作中，数据库系统正在分析并从 OLTP-side 收集的现有数据中得出新的数据。</li>\n<li>一个 OLAP 工作负载的例子是亚马逊计算匹兹堡在下雨天购买最多的商品。</li>\n</ul>\n<p><strong>HTAP: Hybrid Transaction + Analytical Processing</strong></p>\n<ul>\n<li>最近流行的一种新的 work load 类型是 HTAP，它就像一个组合，试图在同一个数据库上做 OLTP 和 OLAP。 Manag Manag</li>\n</ul>\n<h2 id=\"存储模型\"><a class=\"markdownIt-Anchor\" href=\"#存储模型\">#</a> 存储模型</h2>\n<p>Storage Models</p>\n<p>DBMS 的存储模型规定了它如何在磁盘和内存中物理地组织 tuple。</p>\n<ul>\n<li>选择 #1：N-ary 存储模型，即行存 (NSM)</li>\n<li>选择 #2：分解存储模型，即列存 (DSM : Decomposition Storage Model)</li>\n<li>选择 #3：混合存储模型 (PAX)</li>\n</ul>\n<h3 id=\"nsmn-ary-storage-model\"><a class=\"markdownIt-Anchor\" href=\"#nsmn-ary-storage-model\">#</a> NSM，N-ary Storage Model</h3>\n<p>行式存储模型。数据的物理结构和他们的逻辑结构是一样的。磁盘是由一个一个 block 组成的，因此连续的数据也分在了连续的 block 里。</p>\n<p>这种方法是 OLTP work load 的理想选择，在这种 work load 中，请求是大量插入的，而事务往往只操作一个单独的实体。<br>\n它是理想的，因为它只需要一次获取就可以得到一个元组的所有的所有属性</p>\n<ul>\n<li>优点：\n<ul>\n<li>插入、更新、删除快速 Manag Manag</li>\n<li>对需要整个 tuple 的查询有利</li>\n</ul>\n</li>\n<li>缺点：\n<ul>\n<li>不利于扫描表的大部分和 / 或属性的一个子集。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"dsmdecomposition-storage-model\"><a class=\"markdownIt-Anchor\" href=\"#dsmdecomposition-storage-model\">#</a> DSM，Decomposition Storage Model</h3>\n<p>在 DSM 中，DBMS 将所有 tuples 的单一属性（列）连续地存储在一个数据块中。</p>\n<blockquote>\n<p>其实是关系表的一种设计方式，即每一行记录都分解成二元关系表，每个二元表对应一个属性加一个 ID 主键，这样两张表还可以 Join 起来。</p>\n</blockquote>\n<p>因此，它也被称为 “<strong>列存储</strong>”。这种模式是 OLAP 工作负载的理想选择，它有许多只读查询，在表的属性子集上进行大量扫描。</p>\n<ul>\n<li>\n<p>优点：</p>\n<ul>\n<li>减少了 I/O 的浪费，因为 DBMS 只读取它需要 Manag 的数据来进行查询。</li>\n<li>更好的查询处理和数据压缩</li>\n</ul>\n</li>\n<li>\n<p>缺点：</p>\n<ul>\n<li>因为 tuple 之间是 spliting 和 stitching 的，所以点查询、插入、更新和删除的速度很慢。</li>\n</ul>\n</li>\n<li>\n<p>在使用列存储时，要把 tuple 重新组合起来，有两种常见的方法</p>\n<ol>\n<li>\n<p>(常用) 固定长度的偏移量。<br>\n知道一个给定的列中的值将与另一列中相同偏移量的值相匹配，它们将对应于同一个 tuple。因此，列内的每一个值都必须是相同的长度。</p>\n</li>\n<li>\n<p>(更不常用) 使用嵌入式元组 ID。</p>\n<p>对于列中的每个属性，DBMS 存储一个 Manag 元组 ID（例如：一个主键）与它。然后，系统还将存储一个映射，告诉它如何跳到具有该 ID 的每个属性。<br>\n<strong>请注意，这种方法有很大的存储开销，因为它需要为每个属性条目存储一个元组 ID。</strong></p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"数据库压缩database-compression\"><a class=\"markdownIt-Anchor\" href=\"#数据库压缩database-compression\">#</a> 数据库压缩 Database Compression</h2>\n<ul>\n<li>\n<p>压缩操作被在<strong> disk-based</strong> DBMSs 广泛应用。因为 disk 的 I/O 总是瓶颈，所以压缩可以让系统提升性能，尤其是只读 analyt Managical workloads 上。</p>\n<p>如果事先对 tuples 进行了压缩，DBMS 可以获取更多有用的 tuple，但代价是要付出更大的压缩和解压的计算开销。</p>\n</li>\n<li>\n<p>内存中的 DBMS 更加复杂，因为它们不必从磁盘中获取数据来执行一个查询。<br>\n内存比磁盘快得多，但压缩数据库可以减少 DRAM 需求和处理。</p>\n<p>而且必须在速度和压缩率中取得一个平衡。压缩数据库可以减少 DRAM 的需求和查询执行过程中的 CPU 成本。</p>\n</li>\n<li>\n<p>如果数据集是完全随机的 bits，那么我们没有办法进行压缩。然而，现实世界中的数据集有一些 key properties 是可以进行压缩的。</p>\n<ul>\n<li>数据集往往具有高度倾斜的属性值分布（例如，Brown 语料库的 Zipfian 分布）。</li>\n<li>数据集往往在同一元组的属性之间有很高的相关性（例如，邮政编码到城市。订单日期与发货日期）。 Manag</li>\n</ul>\n</li>\n<li>\n<p>鉴于此，我们希望一个数据库压缩方案具有以下特性。</p>\n<ul>\n<li>必须产生固定长度的值。唯一的例外是存储在独立池中的变长数据。这因为 DBMS 应该遵循单词对齐的原则，并且能够使用偏移量访问数据。</li>\n<li><strong>允许 DBMS 在查询执行过程中尽可能地推迟解压</strong> （late materialization）</li>\n<li>必须是<strong>无损方案</strong>，因为人们不喜欢丢失数据。任何种类的有损压缩都必须在应用层面上进行</li>\n</ul>\n</li>\n</ul>\n<p>压缩颗粒度 Compression Granularity</p>\n<p>在给 DBMS 增加压缩功能之前，我们需要决定我们要压缩什么样的数据。这个决定决定了压缩方案的可用性。有四个级别的压缩 Manag 颗粒度（granularity）</p>\n<ul>\n<li>\n<p>Block Level:<br>\n 压缩同一张表的 tuple 块。</p>\n</li>\n<li>\n<p>Tuple Level:<br>\n 压缩整个 tuples 的内容（仅 NSM）。</p>\n</li>\n<li>\n<p>Attribute Level:<br>\n 在一个 tuple 内压缩单个属性值。可以针对同一 tuple 的多个属性。</p>\n</li>\n<li>\n<p>Columnar Level:</p>\n<p>为多个 tuple 存储的一个或多个属性压缩多个值<br>\n (只限于 DSM)。这允许更复杂的压缩方案。</p>\n</li>\n</ul>\n<h2 id=\"naive-compression\"><a class=\"markdownIt-Anchor\" href=\"#naive-compression\">#</a> Naive Compression</h2>\n<ul>\n<li>\n<p>DBMS 使用一个通用的算法对数据进行压缩 (e.g., gzip, LZO, LZ4, Snappy, Brotli, Oracle OZIP, Zstd)。 尽管 DBMS 可以使用几种压缩算法，但工程师们往往选择那些经常提供较低压缩率以换取更快的压缩 / 解压的算法。</p>\n</li>\n<li>\n<p>naive compression 例子： <strong>MySQL InnoDB</strong></p>\n<p>DBMS 对磁盘页面进行压缩，将其压缩到 2KB 的幂数，并将其存储到缓冲池中。然而，每次 DBMS 试图读取数据时，缓冲池中的压缩数据必须被解压</p>\n</li>\n<li>\n<p>由于访问数据需要对压缩的数据进行解压，这就限制了压缩方案的范围。<br>\n如果目标是将整个表压缩成一个巨大的块，使用 naive compression 方案是不可能的，因为每次访问都需要对整个表进行压缩 / 解压缩。<br>\n因此，对于 MySQL 来说，由于压缩范围有限，它将表分解成更小的块状。</p>\n</li>\n<li>\n<p>另一个问题是，这些 naive 方案也没有考虑到数据的高级含义或语义。<br>\n该算法既不考虑数据的结构，也不考虑查询打算如何访问 数据。因此，这就失去了利用 late materialization 的机会，因为 DBMS 不能知道它何时能够延迟数据的解压。</p>\n</li>\n</ul>\n<h2 id=\"列压缩columnar-compression\"><a class=\"markdownIt-Anchor\" href=\"#列压缩columnar-compression\">#</a> <strong>列压缩</strong> Columnar Compression</h2>\n<ol>\n<li>\n<p>游程编码</p>\n</li>\n<li>\n<p>字典编码</p>\n</li>\n<li>\n<p>位图编码</p>\n</li>\n<li>\n<p>增量编码 Delta Encoding</p>\n</li>\n<li>\n<p>比特打包 Bit-Packing</p>\n</li>\n</ol>\n<h1 id=\"lesson06-内存管理\"><a class=\"markdownIt-Anchor\" href=\"#lesson06-内存管理\">#</a> Lesson#06. 内存管理</h1>\n",
            "tags": [
                "DataBase"
            ]
        }
    ]
}