{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"linux\" tag",
    "description": "",
    "home_page_url": "https://adventure-yx.github.io",
    "items": [
        {
            "id": "https://adventure-yx.github.io/2023/04/18/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/",
            "url": "https://adventure-yx.github.io/2023/04/18/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/",
            "title": "C++网络编程",
            "date_published": "2023-04-18T15:07:30.000Z",
            "content_html": "<h1 id=\"套接字socket\"><a class=\"markdownIt-Anchor\" href=\"#套接字socket\">#</a> 套接字 socket</h1>\n<h2 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h2>\n<ul>\n<li>\n<p>局域网和广域网</p>\n<ul>\n<li>局域网：局域网将一定区域内的各种计算机、外部设备和数据库连接起来形成计算机通信的私有网络。</li>\n<li>广域网：又称广域网、外网、公网。是连接不同地区局域网或城域网计算机通信的远程公共网络。</li>\n</ul>\n</li>\n<li>\n<p>IP（Internet Protocol）：本质是一个整形数，用于表示计算机在网络中的地址。IP 协议版本有两个：IPv4 和 IPv6</p>\n<ul>\n<li>\n<p>IPv4（Internet Protocol version4）：</p>\n<ul>\n<li>使用一个 32 位的整形数描述一个 IP 地址，4 个字节，int 型</li>\n<li>也可以使用一个点分十进制字符串描述这个 IP 地址： 192.168.247.135</li>\n<li>分成了 4 份，每份 1 字节，8bit（char），最大值为 255</li>\n<li>0.0.0.0 是最小的 IP 地址</li>\n<li>255.255.255.255 是最大的 IP 地址</li>\n<li>按照 IPv4 协议计算，可以使用的 IP 地址共有 232 个</li>\n</ul>\n</li>\n<li>\n<p>IPv6（Internet Protocol version6）：</p>\n<ul>\n<li>使用一个 128 位的整形数描述一个 IP 地址，16 个字节</li>\n<li>也可以使用一个字符串描述这个 IP 地址：2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b</li>\n<li>分成了 8 份，每份 2 字节，每一部分以 16 进制的方式表示</li>\n<li>按照 IPv6 协议计算，可以使用的 IP 地址共有 2128 个</li>\n</ul>\n</li>\n<li>\n<p>查看 IP 地址</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># linux</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ <span class=\"token function\">ifconfig</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># windows</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>$ ipconfig</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 测试网络是否畅通</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\"># 主机 a: 192.168.1.11</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\"># 当前主机: 192.168.1.12</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>$ <span class=\"token function\">ping</span> <span class=\"token number\">192.168</span>.1.11     <span class=\"token comment\"># 测试是否可用连接局域网</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>$ <span class=\"token function\">ping</span> www.baidu.com    <span class=\"token comment\"># 测试是否可用连接外网</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\"># 特殊的 IP 地址: 127.0.0.1  ==> 和本地的 IP 地址是等价的</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\"># 假设当前电脑没有联网，就没有 IP 地址，又要做网络测试，可用使用 127.0.0.1 进行本地测试</span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>\n<p>端口</p>\n<p>端口的作用是定位到主机上的某一个进程，通过这个端口进程就可以接受到对应的网络数据了。</p>\n<blockquote>\n<p>比如：在电脑上运行了微信和 QQ, 小明通过客户端给我的的微信发消息，电脑上的微信就收到了消息，为什么？</p>\n<p>运行在电脑上的微信和 QQ 都绑定了不同的端口<br>\n通过 IP 地址可以定位到某一台主机，通过端口就可以定位到主机上的某一个进程<br>\n通过指定的 IP 和端口，发送数据的时候对端就能接受到数据了</p>\n</blockquote>\n<p>端口也是一个整形数  <code>unsigned short</code>  ，一个 16 位整形数，有效端口的取值范围是：0 ~ 65535 (0 ~ 216-1)</p>\n<blockquote>\n<p>提问：计算机中所有的进程都需要关联一个端口吗，一个端口可以被重复使用吗？</p>\n<p>不需要，如果这个进程不需要网络通信，那么这个进程就不需要绑定端口的</p>\n<p>一个端口只能给某一个进程使用，多个进程不能同时使用同一个端口</p>\n</blockquote>\n</li>\n<li>\n<p>OSI/ISO 网络分层模型</p>\n<p>OSI（Open System Interconnect），即开放式系统互联。 一般都叫 OSI 参考模型，是 ISO（国际标准化组织组织）在 1985 年研究的网络互联模型。</p>\n<table>\n\t<tr>\n\t    <th colspan=\"3\">计算机网络分层模型</th>\n\t</tr >\n\t<tr>\n\t    <td >OSI七层网络模型</td>\n\t    <td>TCP/IP四层概念模型</td>\n\t    <td>对应网络协议</td>  \n\t</tr >\n\t<tr >\n\t    <td>应用层（Application）</td>\n\t    <td rowspan=\"3\">应用层</td>\n\t    <td>HTTP、TFTP、FTP、NFS、WAIS、SMTP</td>\n\t</tr>\n\t<tr>\n\t    <td>表示层（Presentation）</td>\n        <td>Telnet、Rlogin、SNMP、Gopher</td>\n\t</tr>\n\t<tr>\n\t    <td>会话层（Session）</td>\n        <td>SMTP、DNS</td>\n\t</tr>\n\t<tr>\n\t    <td>传输层（Transport）</td>\n\t    <td>传输层</td>\n       \t<td>TCP、UDP</td>\n\t</tr>\n\t<tr>\n       \t<td>网络层（Network）</td>\n\t    <td>网络层</td>\n       \t<td>IP、ICMP、ARP、RARP、AKP、UUCP</td>\n\t</tr>\n\t<tr>\n\t    <td>数据链路层(Data Link)</td>\n\t    <td rowspan=\"2\">网络接口层</td>\n       <td>FDDI、Ethernet、Arpanet、PDN、SLIP、PPP</td>\n\t</tr>\n\t<tr>\n\t    <td>物理层(Physical)</td>\n\t    <td>IEEE802.1A、IEEE802.2-IEEE802.11</td>\n\t</tr>\n</table>\n<ul>\n<li>\n<p>物理层</p>\n<p>负责最后将信息编码成电流脉冲或其它信号用于网上传输</p>\n</li>\n<li>\n<p>数据链路层</p>\n<p>数据链路层通过物理网络链路供数据传输。<br>\n规定了 0 和 1 的分包形式，确定了网络数据包的形式；</p>\n</li>\n<li>\n<p>网络层</p>\n<p>网络层负责在源和终点之间建立连接；<br>\n此处需要确定计算机的位置，通过 IPv4，IPv6 格式的 IP 地址来找到对应的主机</p>\n</li>\n<li>\n<p>传输层</p>\n<p>传输层向高层提供可靠的端到端的网络数据流服务。<br>\n每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信</p>\n</li>\n<li>\n<p>会话层</p>\n<p>会话层建立、管理和终止表示层与实体之间的通信会话；<br>\n建立一个连接（自动的手机信息、自动的网络寻址）;</p>\n</li>\n<li>\n<p>表示层:</p>\n<p>对应用层数据编码和转化，确保以一个系统应用层发送的信息 可以被另一个系统应用层识别；</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"网络协议\"><a class=\"markdownIt-Anchor\" href=\"#网络协议\">#</a> 网络协议</h2>\n<p>网络协议指的是计算机网络中互相通信的对等实体之间交换信息时所必须遵守的规则的集合。一般系统网络协议包括五个部分：通信环境，传输服务，词汇表，信息的编码格式，时序、规则和过程。先来通过下面几幅图了解一下常用的网络协议的格式：</p>\n<ul>\n<li>TCP 协议 -&gt; 传输层协议</li>\n<li>UDP 协议 -&gt; 传输层协议</li>\n<li>IP 协议 -&gt; 网络层协议</li>\n<li>以太网帧协议 -&gt; 网络接口层协议</li>\n</ul>\n<p>数据的封装</p>\n<p>在网络通信的时候，程序猿需要负责的应用层数据的处理 (最上层)</p>\n<ul>\n<li>应用层的数据可以使用某些协议进行封装，也可以不封装</li>\n<li>程序猿需要调用发送数据的接口函数，将数据发送出去</li>\n<li>程序猿调用的 API 做底层数据处理\n<ul>\n<li>传输层使用传输层协议打包数据</li>\n<li>网络层使用网络层协议打包数据</li>\n<li>网络接口层使用网络接口层协议打包数据</li>\n<li>数据被发送到 internet</li>\n</ul>\n</li>\n<li>接收端接收到发送端的数据\n<ul>\n<li>程序猿调用接收数据的函数接收数据</li>\n<li>调用的 API 做相关的底层处理:\n<ul>\n<li>网络接口层拆包 ==&gt; 网络层的包</li>\n<li>网络层拆包 ==&gt; 网络层的包</li>\n<li>传输层拆包 ==&gt; 传输层数据</li>\n</ul>\n</li>\n<li>如果应用层也使用了协议对数据进行了封装，数据的包的解析需要程序猿做</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"socket编程\"><a class=\"markdownIt-Anchor\" href=\"#socket编程\">#</a> socket 编程</h2>\n<p>Socket 套接字由远景研究规划局（Advanced Research Projects Agency, ARPA）资助加里福尼亚大学伯克利分校的一个研究组研发。其目的是将 TCP/IP 协议相关软件移植到 UNIX 类系统中。设计者开发了一个接口，以便应用程序能简单地调用该接口通信。这个接口不断完善，最终形成了 Socket 套接字。Linux 系统采用了 Socket 套接字，因此，Socket 接口就被广泛使用，到现在已经成为事实上的标准。与套接字相关的函数被包含在头文件  <code>sys/socket.h</code>  中。</p>\n<p>socket 直译插座，通过上面的描述可以得知，套接字对应程序猿来说就是一套网络通信的接口，使用这套接口就可以完成网络通信。网络通信的主体主要分为两部分：客户端和服务器端。在客户端和服务器通信的时候需要频繁提到三个概念：IP、端口、通信数据，下面介绍一下需要注意的一些细节问题。</p>\n<h3 id=\"字节序\"><a class=\"markdownIt-Anchor\" href=\"#字节序\">#</a> 字节序</h3>\n<p>在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编 / 译码从而导致通信失败。</p>\n<p>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，也就是说对于单字符来说是没有字节序问题的，字符串是单字符的集合，因此字符串也没有字节序问题。</p>\n<p>目前在各种体系的计算机中通常采用的字节存储机制主要有两种：Big-Endian 和 Little-Endian，下面先从字节序说起。</p>\n<ul>\n<li>Little-Endian -&gt; 主机字节序 (小端)\n<ul>\n<li>数据的低位字节存储到内存的低地址位，数据的高位字节存储到内存的高地址位</li>\n<li>我们使用的 PC 机，数据的存储默认使用的是小端</li>\n</ul>\n</li>\n<li>Big-Endian -&gt; 网络字节序 (大端)\n<ul>\n<li>数据的低位字节存储到内存的高地址位，数据的高位字节存储到内存的低地址位</li>\n<li>套接字通信过程中操作的数据都是大端存储的，包括：接收 / 发送的数据、IP 地址、端口。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ip地址转换\"><a class=\"markdownIt-Anchor\" href=\"#ip地址转换\">#</a> IP 地址转换</h3>\n<h3 id=\"sockaddr-数据结构\"><a class=\"markdownIt-Anchor\" href=\"#sockaddr-数据结构\">#</a> sockaddr 数据结构</h3>\n<h3 id=\"套接字函数\"><a class=\"markdownIt-Anchor\" href=\"#套接字函数\">#</a> 套接字函数</h3>\n<h1 id=\"tcp通信流程\"><a class=\"markdownIt-Anchor\" href=\"#tcp通信流程\">#</a> TCP 通信流程</h1>\n<p>TCP 是一个<strong>面向连接的</strong>，<strong>安全的</strong>，<strong>流式传输协议</strong>，这个协议是一个传输层协议。</p>\n<ul>\n<li>面向连接：是一个双向连接，通过三次握手完成，断开连接需要通过四次挥手完成。</li>\n<li>安全：tcp 通信过程中，会对发送的每一数据包都会进行校验，如果发现数据丢失，会自动重传</li>\n<li>流式传输：发送端和接收端处理数据的速度，数据的量都可以不一致</li>\n</ul>\n<p><img data-src=\"tcp.jpg\" alt=\"img\"></p>\n<h2 id=\"服务器端通信流程\"><a class=\"markdownIt-Anchor\" href=\"#服务器端通信流程\">#</a> 服务器端通信流程</h2>\n<ol>\n<li>\n<p>创建用于监听的套接字，这个套接字是一个文件描述符 (监听的)</p>\n<p><code>int lfd = socket();</code></p>\n</li>\n<li>\n<p>将得到的监听的文件描述符和本地的 IP 端口进行绑定</p>\n<p><code>bind();</code></p>\n</li>\n<li>\n<p>设置监听 (成功之后开始监听，监听的是客户端的连接)</p>\n<p><code>listen();</code></p>\n</li>\n<li>\n<p>等待并接受客户端的连接请求，建立新的连接，会得到一个新的文件描述符 (通信的)，没有新连接请求就阻塞</p>\n<p><code>int cfd = accept();</code></p>\n</li>\n<li>\n<p>通信，读写操作默认都是阻塞的</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 接收数据</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">/</span> <span class=\"token function\">recv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 发送数据</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">/</span> <span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>断开连接，关闭套接字</p>\n<p><code>close();</code></p>\n</li>\n</ol>\n<blockquote>\n<p>在 tcp 的服务器端，有两类文件描述符</p>\n<ul>\n<li>监听的文件描述符\n<ul>\n<li>只需要有一个</li>\n<li>不负责和客户端通信，负责检测客户端的连接请求，检测到之后调用 accept 就可以建立新的连接</li>\n</ul>\n</li>\n<li>通信的文件描述符\n<ul>\n<li>负责和建立连接的客户端通信</li>\n<li>如果有 N 个客户端和服务器建立了新的连接，通信的文件描述符就有 N 个，每个客户端和服务器都对应一个通信的文件描述符</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><img data-src=\"1558084711685.png\" alt=\"1558084711685\"></p>\n<ul>\n<li>文件描述符对应的内存结构：\n<ul>\n<li>一个文件文件描述符对应两块内存，一块内存是读缓冲区，一块内存是写缓冲区</li>\n<li>读数据：通过文件描述符将内存中的数据读出，这块内存称之为读缓冲区</li>\n<li>写数据：通过文件描述符将数据写入到某块内存中，这块内存称之为写缓冲区</li>\n</ul>\n</li>\n<li>监听的文件描述符:\n<ul>\n<li>客户端的连接请求会发送到服务器端监听的文件描述符的读缓冲区中</li>\n<li>读缓冲区中有数据，说明有新的客户端连接</li>\n<li>调用 accept () 函数，这个函数会检测监听文件描述符的读缓冲区\n<ul>\n<li>检测不到数据，该函数阻塞</li>\n<li>如果检测到数据，解除阻塞，新的连接建立</li>\n</ul>\n</li>\n<li>通信的文件描述符:\n<ul>\n<li>客户端和服务器端都有通信的文件描述符</li>\n<li>发送数据：调用函数 write () /send ()，数据进入到内核中\n<ul>\n<li>数据并没有被发送出去，而是将数据写入到了通信的文件描述符对应的写缓冲区中</li>\n<li>内核检测到通信的文件描述符写缓冲区中有数据，内核会将数据发送到网络中</li>\n</ul>\n</li>\n<li>接收数据：调用的函数 read () /recv (), 从内核读数据\n<ul>\n<li>数据如何进入到内核程序猿不需要处理，数据进入到通信的文件描述符的读缓冲区中</li>\n<li>数据进入到内核，必须使用通信的文件描述符，将数据从读缓冲区中读出即可</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>基于 tcp 的服务器端通信代码:</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// server.c</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;arpa/inet.h></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// 1. 创建监听的套接字</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">int</span> lfd <span class=\"token operator\">=</span> <span class=\"token function\">socket</span><span class=\"token punctuation\">(</span>AF_INET<span class=\"token punctuation\">,</span> SOCK_STREAM<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>lfd <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token function\">perror</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"socket\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token comment\">// 2. 将 socket () 返回值和本地的 IP 端口绑定到一起</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sockaddr_in</span> addr<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    addr<span class=\"token punctuation\">.</span>sin_family <span class=\"token operator\">=</span> AF_INET<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    addr<span class=\"token punctuation\">.</span>sin_port <span class=\"token operator\">=</span> <span class=\"token function\">htons</span><span class=\"token punctuation\">(</span><span class=\"token number\">10000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 大端端口</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token comment\">// INADDR_ANY 代表本机的所有 IP, 假设有三个网卡就有三个 IP 地址</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token comment\">// 这个宏可以代表任意一个 IP 地址</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token comment\">// 这个宏一般用于本地的绑定操作</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    addr<span class=\"token punctuation\">.</span>sin_addr<span class=\"token punctuation\">.</span>s_addr <span class=\"token operator\">=</span> INADDR_ANY<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 这个宏的值为 0 == 0.0.0.0</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token comment\">//    inet_pton(AF_INET, \"192.168.237.131\", &amp;addr.sin_addr.s_addr);</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> <span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>lfd<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sockaddr</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>addr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>addr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>ret <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token function\">perror</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bind\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token comment\">// 3. 设置监听</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    ret <span class=\"token operator\">=</span> <span class=\"token function\">listen</span><span class=\"token punctuation\">(</span>lfd<span class=\"token punctuation\">,</span> <span class=\"token number\">128</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>ret <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token function\">perror</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"listen\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    <span class=\"token comment\">// 4. 阻塞等待并接受客户端连接</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sockaddr_in</span> cliaddr<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>    <span class=\"token keyword\">int</span> clilen <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>cliaddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    <span class=\"token keyword\">int</span> cfd <span class=\"token operator\">=</span> <span class=\"token function\">accept</span><span class=\"token punctuation\">(</span>lfd<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sockaddr</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>cliaddr<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>clilen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cfd <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>        <span class=\"token function\">perror</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"accept\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>        <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>    <span class=\"token comment\">// 打印客户端的地址信息</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>    <span class=\"token keyword\">char</span> ip<span class=\"token punctuation\">[</span><span class=\"token number\">24</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"客户端的IP地址: %s, 端口: %d\\n\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>           <span class=\"token function\">inet_ntop</span><span class=\"token punctuation\">(</span>AF_INET<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>cliaddr<span class=\"token punctuation\">.</span>sin_addr<span class=\"token punctuation\">.</span>s_addr<span class=\"token punctuation\">,</span> ip<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>ip<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>           <span class=\"token function\">ntohs</span><span class=\"token punctuation\">(</span>cliaddr<span class=\"token punctuation\">.</span>sin_port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>    <span class=\"token comment\">// 5. 和客户端通信</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>        <span class=\"token comment\">// 接收数据</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>        <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token number\">1024</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>        <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>        <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> <span class=\"token function\">read</span><span class=\"token punctuation\">(</span>cfd<span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>len <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"客户端say: %s\\n\"</span><span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>            <span class=\"token function\">write</span><span class=\"token punctuation\">(</span>cfd<span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">,</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>len  <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"客户端断开了连接...\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>        <span class=\"token keyword\">else</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>            <span class=\"token function\">perror</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"read\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"79\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre></pre></td></tr><tr><td data-num=\"81\"></td><td><pre>    <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>cfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"82\"></td><td><pre>    <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>lfd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"83\"></td><td><pre></pre></td></tr><tr><td data-num=\"84\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"85\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"客户端的通信流程\"><a class=\"markdownIt-Anchor\" href=\"#客户端的通信流程\">#</a> 客户端的通信流程</h2>\n<blockquote>\n<p>在单线程的情况下客户端通信的文件描述符有一个，没有监听的文件描述符</p>\n</blockquote>\n<ol>\n<li>\n<p>创建一个通信的套接字</p>\n<p><code>int cfd = socket();</code></p>\n</li>\n<li>\n<p>连接服务器，需要知道服务器绑定的 IP 和端口</p>\n<p><code>connect();</code></p>\n</li>\n<li>\n<p>通信</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>p</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 接收数据</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">/</span> <span class=\"token function\">recv</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 发送数据</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">/</span> <span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>断开连接，关闭文件描述符 (套接字)</p>\n<p><code>close();</code></p>\n</li>\n</ol>\n<p>基于 tcp 通信的客户端通信代码:</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// client.c</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;arpa/inet.h></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// 1. 创建通信的套接字</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">int</span> fd <span class=\"token operator\">=</span> <span class=\"token function\">socket</span><span class=\"token punctuation\">(</span>AF_INET<span class=\"token punctuation\">,</span> SOCK_STREAM<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>fd <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token function\">perror</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"socket\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token comment\">// 2. 连接服务器</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sockaddr_in</span> addr<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    addr<span class=\"token punctuation\">.</span>sin_family <span class=\"token operator\">=</span> AF_INET<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    addr<span class=\"token punctuation\">.</span>sin_port <span class=\"token operator\">=</span> <span class=\"token function\">htons</span><span class=\"token punctuation\">(</span><span class=\"token number\">10000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 大端端口</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token function\">inet_pton</span><span class=\"token punctuation\">(</span>AF_INET<span class=\"token punctuation\">,</span> <span class=\"token string\">\"192.168.237.131\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>addr<span class=\"token punctuation\">.</span>sin_addr<span class=\"token punctuation\">.</span>s_addr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">int</span> ret <span class=\"token operator\">=</span> <span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">sockaddr</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>addr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>addr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>ret <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token function\">perror</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"connect\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token comment\">// 3. 和服务器端通信</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token keyword\">int</span> number <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token comment\">// 发送数据</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token number\">1024</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>        <span class=\"token function\">sprintf</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> <span class=\"token string\">\"你好, 服务器...%d\\n\"</span><span class=\"token punctuation\">,</span> number<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token function\">write</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">,</span> <span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token comment\">// 接收数据</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>        <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> <span class=\"token function\">read</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>len <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"服务器say: %s\\n\"</span><span class=\"token punctuation\">,</span> buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>len  <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>            <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"服务器断开了连接...\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>        <span class=\"token keyword\">else</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>            <span class=\"token function\">perror</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"read\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>        <span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 每隔 1s 发送一条数据</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>    <span class=\"token function\">close</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"tcp协议介绍\"><a class=\"markdownIt-Anchor\" href=\"#tcp协议介绍\">#</a> TCP 协议介绍</h2>\n<p>TCP 协议是一个安全的、面向连接的、流式传输协议，所谓的面向连接就是三次握手，对于程序猿来说只需要在客户端调用 connect () 函数，三次握手就自动进行了。先通过下图看一下 TCP 协议的格式，然后再介绍三次握手的具体流程。</p>\n<h2 id=\"tcp三次握手\"><a class=\"markdownIt-Anchor\" href=\"#tcp三次握手\">#</a> TCP 三次握手</h2>\n<h2 id=\"tcp四次挥手\"><a class=\"markdownIt-Anchor\" href=\"#tcp四次挥手\">#</a> TCP 四次挥手</h2>\n<h2 id=\"流量控制\"><a class=\"markdownIt-Anchor\" href=\"#流量控制\">#</a> 流量控制</h2>\n<h2 id=\"tcp状态转换\"><a class=\"markdownIt-Anchor\" href=\"#tcp状态转换\">#</a> TCP 状态转换</h2>\n<h1 id=\"服务器并发\"><a class=\"markdownIt-Anchor\" href=\"#服务器并发\">#</a> 服务器并发</h1>\n<h1 id=\"tcp-数据粘包的处理\"><a class=\"markdownIt-Anchor\" href=\"#tcp-数据粘包的处理\">#</a> TCP 数据粘包的处理</h1>\n<h1 id=\"套接字通信类的封装\"><a class=\"markdownIt-Anchor\" href=\"#套接字通信类的封装\">#</a> 套接字通信类的封装</h1>\n<h1 id=\"io-多路复用之-select\"><a class=\"markdownIt-Anchor\" href=\"#io-多路复用之-select\">#</a> IO 多路复用之 select</h1>\n<h1 id=\"io-多路复用之-poll\"><a class=\"markdownIt-Anchor\" href=\"#io-多路复用之-poll\">#</a> IO 多路复用之 poll</h1>\n<h1 id=\"io-多路复用之-epoll\"><a class=\"markdownIt-Anchor\" href=\"#io-多路复用之-epoll\">#</a> IO 多路复用之 epoll</h1>\n",
            "tags": [
                "C++",
                "Linux",
                "计算机网络"
            ]
        },
        {
            "id": "https://adventure-yx.github.io/2023/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%97%E5%A4%A72023%EF%BC%89/",
            "url": "https://adventure-yx.github.io/2023/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%97%E5%A4%A72023%EF%BC%89/",
            "title": "操作系统（南大2023）",
            "date_published": "2023-03-15T09:56:33.000Z",
            "content_html": "<p>南京大学 2023《操作系统：设计与实现》- 蒋炎岩</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVh4NHkxVjdKWg==\">https://www.bilibili.com/video/BV1Xx4y1V7JZ</span></p>\n<h1 id=\"操作系统概述\"><a class=\"markdownIt-Anchor\" href=\"#操作系统概述\">#</a> 操作系统概述</h1>\n<h2 id=\"什么是操作系统\"><a class=\"markdownIt-Anchor\" href=\"#什么是操作系统\">#</a> 什么是操作系统？</h2>\n<blockquote>\n<p>Operating System: A body of software, in fact, that is responsible for making it easy to run programs(even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that.     ——《OSTEP》</p>\n</blockquote>\n<p>操作系统发展历程：……</p>\n<p><strong>今天的操作系统：通过 “虚拟化硬件” 资源为程序运行提供服务的软件</strong></p>\n<ul>\n<li>更复杂的的处理器和内存\n<ul>\n<li>非对称对处理器（ARM big.LITTLE；Intel P/E-cores）</li>\n<li>Non-uniform Memory Access (NUMA)</li>\n<li>更多的硬件机制</li>\n</ul>\n</li>\n<li>更多的设备和资源\n<ul>\n<li>网卡、SSD、GPU、FPGA……</li>\n</ul>\n</li>\n<li>复杂的应用需求和应用环境\n<ul>\n<li>服务器、个人电脑、智能手机、手环、IoT……</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"理解操作系统\"><a class=\"markdownIt-Anchor\" href=\"#理解操作系统\">#</a> 理解操作系统</h2>\n<p>三个根本问题：</p>\n<ol>\n<li>操作系统服务谁？\n<ul>\n<li><strong>程序 = 状态机</strong></li>\n<li>本课程涉及：多线程 Linux 应用程序</li>\n</ul>\n</li>\n<li>操作系统为程序提供什么服务？（设计 / 应用视角）\n<ul>\n<li><strong>操作系统 = 对象 + API</strong></li>\n<li>本课程涉及：POSIX + 部分 Linux 特性</li>\n</ul>\n</li>\n<li>如何实现操作系统提供的服务（实现 / 硬件视角）？\n<ul>\n<li><strong>操作系统 = C 程序</strong>\n<ul>\n<li>完成初始化后就成为 interrupt/trap/fault handler</li>\n</ul>\n</li>\n<li>本课程涉及：xv6，自制迷你操作系统</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"应用视角的操作系统\"><a class=\"markdownIt-Anchor\" href=\"#应用视角的操作系统\">#</a> 应用视角的操作系统</h1>\n<p><strong>背景回顾</strong>：操作系统有三条主线：“软件 (应用)”、“硬件 (计算机)”、“操作系统 (软件直接访问硬件带来麻烦太多而引入的中间件)”。想要理解操作系统，对操作系统的服务对象 (应用程序) 有精确的理解是必不可少的。</p>\n<p>操作系统 = 对象 + API (应用视角 / 设计) = C 程序 (硬件视角 / 实现)</p>\n<p><strong>本讲内容</strong>：指令序列和高级语言的状态机模型；回答以下问题：</p>\n<ul>\n<li>什么是软件 (程序)？</li>\n<li>如何在操作系统上构造最小 / 一般 / 图形界面应用程序？</li>\n<li>什么是编译器？编译器把一段程序翻译成什么样的指令序列才算 “正确”？</li>\n</ul>\n<h2 id=\"什么是程序源代码视角\"><a class=\"markdownIt-Anchor\" href=\"#什么是程序源代码视角\">#</a> 什么是程序（源代码视角）</h2>\n<p><strong>C 程序的状态机模型</strong>（语义，semantics）</p>\n<ul>\n<li>状态 = 堆 + 栈</li>\n<li>初始状态 = main 的第一条语句</li>\n<li>迁移 = 执行一条简单语句\n<ul>\n<li>任何 C 程序都可以改写成 “非复合语句” 的 C 代码</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>这还只是粗浅的理解</p>\n<p>任何真正的理解都应该落实到可以执行的代码</p>\n</blockquote>\n<ul>\n<li>状态 = stack frame 的列表（每个 frame 有 PC）+ 全局变量</li>\n<li>初始状态 = main (argc, argv), 全局变量初始化</li>\n<li>迁移 = 执行 top stack frame PC 的语句；PC++（PC 是计数器，存下一条指令地址）\n<ul>\n<li>函数调用 = push frame (frame.PC = 入口)</li>\n<li>函数返回 = pop frame</li>\n</ul>\n</li>\n</ul>\n<p>C 语言程序是由很多栈帧组成的，每次函数调用创建一个新的栈帧</p>\n<p>应用：将任何递归程序就地转为非递归（还是一样的 call ()，但放入不同的 frame）</p>\n<h2 id=\"什么是程序二进制代码视角\"><a class=\"markdownIt-Anchor\" href=\"#什么是程序二进制代码视角\">#</a> 什么是程序（二进制代码视角）</h2>\n<ul>\n<li>状态 = 内存 M + 寄存器 R</li>\n<li>初始状态</li>\n<li>迁移 = 执行一条指令</li>\n</ul>\n<p>操作系统上的程序</p>\n<ul>\n<li>所有的指令都只能<strong>计算</strong>\n<ul>\n<li>deterministic: mov, add, sub, call…</li>\n<li>non-deterministic: rdrand …</li>\n<li>但这些指令甚至都无法使程序停下来（NEMU：加条 trap 指令）</li>\n</ul>\n</li>\n<li>一条特殊的指令：调用操作系统 <code>syscall</code>\n<ul>\n<li>把（M,R）完全交给操作系统，任其修改</li>\n<li>实现与操作系统中的其它对象交互\n<ul>\n<li>读写文件 / 操作系统状态（例如把文件内容写入 M）</li>\n<li>改变进程（运行中状态机）的状态，例如创建进程 / 销毁自己</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>程序 = 计算 + syscall</strong></li>\n</ul>\n<h2 id=\"如何在程序的两个视角之间切换\"><a class=\"markdownIt-Anchor\" href=\"#如何在程序的两个视角之间切换\">#</a> 如何在程序的两个视角之间切换</h2>\n<p><strong>编译器</strong>：源代码 S（状态机） → 二进制代码 C（状态机）</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>C</mi><mo>=</mo><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>e</mi><mtext>（</mtext><mi>S</mi><mtext>）</mtext></mrow><annotation encoding=\"application/x-tex\">C = complie（S）\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">e</span><span class=\"mord cjk_fallback\">（</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord cjk_fallback\">）</span></span></span></span></span></p>\n<h2 id=\"操作系统中的一般程序\"><a class=\"markdownIt-Anchor\" href=\"#操作系统中的一般程序\">#</a> 操作系统中的一般程序</h2>\n<p>系统中常见的应用程序</p>\n<ul>\n<li>\n<p>Core Utilities(coreutils)</p>\n<ul>\n<li>standard programs for text and file manipulation</li>\n<li>系统中安装的是 GNU Coreutils</li>\n</ul>\n</li>\n<li>\n<p>系统 / 工具程序</p>\n<ul>\n<li>bash, binutils, apt, ip, ssh, vim, tmux, jdk, python, …</li>\n</ul>\n</li>\n<li>\n<p>其他应用程序</p>\n<ul>\n<li>浏览器、音乐播放器</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>面试题 (1)：一个普通的、人畜无害的 Hello World C 程序执行的第一条指令在哪里？</p>\n</blockquote>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>gdb a.out</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> start</pre></td></tr></table></figure><p>main () 之前发生了什么？</p>\n<p><code>ld-linux-x86-64.so</code>  加载了 libc</p>\n<p>之后 libc 完成了自己的初始化</p>\n<ul>\n<li>RTFM: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9odXJkL2dsaWJjL3N0YXJ0dXAuaHRtbA==\">libc startup</span> on Hurd</li>\n<li><code>main()</code>  的开始 / 结束并不是整个程序的开始 / 结束</li>\n<li>例子：hello-goodbye.c</li>\n</ul>\n<blockquote>\n<p>面试题 (2)：main 执行之前、执行中、执行后，发生了哪些操作系统 API 调用？</p>\n</blockquote>\n<blockquote>\n<p>In general, trace refers to the process of following <em>anything</em> from the beginning to the end. For example, the  <code>traceroute</code>  command follows each of the network hops as your computer connects to another computer.</p>\n</blockquote>\n<p>这门课中很重要的工具：strace</p>\n<ul>\n<li>system call trace</li>\n<li>理解程序运行时使用的系统调用\n<ul>\n<li>demo:  <code>strace ./hello-goodbye</code></li>\n<li>在这门课中，你能理解 strace 的输出并在你自己的操作系统里实现相当一部分系统调用 (mmap, execve, …)</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>本质上，所有程序都和 Hello World 类似</p>\n<p>程序 = 状态机 = 计算 → syscall → 计算 →</p>\n<ul>\n<li>被操作系统加载\n<ul>\n<li>通过另一个进程执行 execve 设置为初始状态</li>\n</ul>\n</li>\n<li>状态机执行\n<ul>\n<li>进程管理：fork, execve, exit, …</li>\n<li>文件 / 设备管理：open, close, read, write, …</li>\n<li>存储管理：mmap, brk, …</li>\n</ul>\n</li>\n<li>直到 _exit (exit_group) 退出</li>\n</ul>\n<hr>\n<p>(初学者对这一点会感到有一点惊讶)</p>\n<p>说好的浏览器、游戏、杀毒软件、病毒呢？都是这些 API 吗</p>\n<p>Yes! - 这些 API 就是操作系统的全部</p>\n<p>编译器 (gcc)，代表其他工具程序</p>\n<ul>\n<li>\n<p>主要的系统调用：execve, read, write</p>\n</li>\n<li>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">strace</span> <span class=\"token parameter variable\">-f</span> gcc a.c</pre></td></tr></table></figure><p>(gcc 会启动其他进程)</p>\n<ul>\n<li>可以管道给编辑器  <code>vim -</code></li>\n<li>编辑器里还可以  <code>%!grep</code>  (细节 / 技巧)</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>图形界面程序 (xedit)，代表其他图形界面程序 (例如 vscode)</p>\n<ul>\n<li>\n<p>主要的系统调用：poll, recvmsg, writev</p>\n</li>\n<li>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">strace</span> xedit</pre></td></tr></table></figure><ul>\n<li>图形界面程序和 X-Window 服务器按照 X11 协议通信</li>\n<li>虚拟机中的 xedit 将 X11 命令通过 ssh (X11 forwarding) 转发到 Host</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>本次课回答的问题</p>\n<ul>\n<li>\n<p><strong>Q</strong>: 到底什么是 “程序”？</p>\n</li>\n<li>\n<p>程序 = 状态机</p>\n<ul>\n<li>源代码 <em>S</em>: 状态迁移 = 执行语句</li>\n<li>二进制代码 <em>C</em>: 状态迁移 = 执行指令</li>\n<li>编译器 C = compile (S)</li>\n</ul>\n</li>\n<li>\n<p>应用视角的操作系统</p>\n<ul>\n<li><strong>就是一条 syscall 指令</strong></li>\n</ul>\n</li>\n<li>\n<p>计算机系统不存在玄学；一切都建立在确定的机制上</p>\n<ul>\n<li>理解操作系统的重要工具：gcc, binutils, gdb, strace</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"硬件视角的操作系统\"><a class=\"markdownIt-Anchor\" href=\"#硬件视角的操作系统\">#</a> 硬件视角的操作系统</h1>\n<p><strong>本讲内容</strong>：计算机硬件的状态机模型；回答以下问题：</p>\n<ul>\n<li>什么是计算机硬件？</li>\n<li>计算机硬件和程序员之间是如何约定的？</li>\n<li>听说操作系统也是程序。那到底是鸡生蛋还是蛋生鸡？</li>\n</ul>\n<blockquote>\n<p>状态机复习</p>\n<p>数字逻辑电路：</p>\n<ul>\n<li>状态 = 寄存器保存的值（flip-flop）</li>\n<li>初始状态 = RESET (implementation dependent)</li>\n<li>迁移 = 组合逻辑电路计算寄存器下一周期的值</li>\n</ul>\n</blockquote>\n<p>数字系统本身是状态机</p>\n<p>所有的程序都是运行在数字系统上的，<strong>程序也是状态机</strong></p>\n<h1 id=\"调试理论与实践\"><a class=\"markdownIt-Anchor\" href=\"#调试理论与实践\">#</a> 调试理论与实践</h1>\n<h2 id=\"调试理论\"><a class=\"markdownIt-Anchor\" href=\"#调试理论\">#</a> 调试理论</h2>\n<p><strong>本讲内容</strong>：调试理论：Fault, Error 和 Failure；GDB 使用技巧。</p>\n<p>“软件” 的两层含义</p>\n<ul>\n<li>人类需求在信息世界的投影\n<ul>\n<li>理解错需求 → bug</li>\n</ul>\n</li>\n<li>计算过程的精确 (数学) 描述\n<ul>\n<li>实现错误 → bug</li>\n</ul>\n</li>\n</ul>\n<p>调试 (debugging)</p>\n<ul>\n<li>已知程序有 bug，如何找到？</li>\n</ul>\n<p><strong>调试困难的根本原因</strong></p>\n<p>因为 bug 的触发经历了漫长的过程</p>\n<ul>\n<li>需求 → 设计 → 代码 (状态机) → Fault (bug) → Error (程序状态错) → Failure\n<ul>\n<li>我们只能观测到 failure (可观测的结果错)</li>\n<li>我们可以检查状态的正确性 (但非常费时)</li>\n<li>无法预知 bug 在哪里 (每一行 “看起来” 都挺对的)</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>调试理论：如果我们能判定任意程序状态的正确性，那么给定一个 failure，我们可以通过二分查找定位到第一个 error 的状态，此时的代码就是 fault (bug)。</p>\n</blockquote>\n<p>调试理论：推论</p>\n<ul>\n<li>\n<p>为什么我们喜欢 “单步调试”？</p>\n<ul>\n<li>从一个假定正确的状态出发</li>\n<li>每个语句的行为有限，容易判定是否是 error</li>\n</ul>\n</li>\n<li>\n<p>为什么调试理论看起来很没用？</p>\n<ul>\n<li>\n<p>因为判定程序状态的正确性非常困难</p>\n<p>(是否在调试 DP 题 / 图论算法时陷入时间黑洞？)</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>实际中的调试：观察状态机执行 (trace) 的某个侧面</p>\n<ul>\n<li>缩小错误状态 (error) 可能产生的位置</li>\n<li>作出适当的假设</li>\n<li>再进行细粒度的定位和诊断</li>\n</ul>\n<p><strong>最重要的两个工具</strong></p>\n<ul>\n<li>printf → 自定义 log 的 trace\n<ul>\n<li>灵活可控、能快速定位问题大概位置、适用于大型软件</li>\n<li>无法精确定位、大量的 logs 管理起来比较麻烦</li>\n</ul>\n</li>\n<li>gdb → 指令 / 语句级 trace\n<ul>\n<li>精确、指令级定位、任意查看程序内部状态</li>\n<li>耗费大量时间</li>\n</ul>\n</li>\n</ul>\n<p>调试理论给了大家在遇到 “任何问题” 时候 self-check 的列表：</p>\n<ol>\n<li>是怎样的程序 (状态机) 在运行？</li>\n<li>我们遇到了怎样的 failure？</li>\n<li>我们能从状态机的运行中从易到难得到什么信息？</li>\n<li>如何二分检查这些信息和 error 之间的关联？</li>\n</ol>\n<h2 id=\"编程基本准则回顾\"><a class=\"markdownIt-Anchor\" href=\"#编程基本准则回顾\">#</a> 编程基本准则：回顾</h2>\n<blockquote>\n<p>Programs are meant to be read by humans (AIs) and only incidentally for computers to execute. — <em>D. E. Knuth</em></p>\n<p>(程序首先是拿给人读的，其次才是被机器执行。)</p>\n</blockquote>\n<p>好的程序</p>\n<ul>\n<li>\n<p>不言自明：能知道是做什么的 (specification)</p>\n<ul>\n<li>因此代码风格很重要</li>\n</ul>\n</li>\n<li>\n<p>不言自证：能确认代码和 specification 一致</p>\n<ul>\n<li>因此代码中的逻辑流很重要</li>\n</ul>\n</li>\n<li>\n<p>人类新纪元的评判标准</p>\n<ul>\n<li>AI 是否能正确理解 / 维护你的代码</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"调试理论的最重要应用\"><a class=\"markdownIt-Anchor\" href=\"#调试理论的最重要应用\">#</a> 调试理论的最重要应用</h2>\n<blockquote>\n<p>写好读、易验证的代码</p>\n<p>在代码中添加更多的断言 (assertions)</p>\n</blockquote>\n<p>断言的意义</p>\n<ul>\n<li>把代码中隐藏的 specification 写出来\n<ul>\n<li>Fault → Error (靠测试)</li>\n<li>Error → Failure (靠断言)\n<ul>\n<li>Error 暴露的越晚，越难调试</li>\n<li>追溯导致 assert failure 的变量值 (slice) 通常可以快速定位到 bug</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"gdb\"><a class=\"markdownIt-Anchor\" href=\"#gdb\">#</a> GDB</h2>\n<h1 id=\"python-建模操作系统\"><a class=\"markdownIt-Anchor\" href=\"#python-建模操作系统\">#</a> Python 建模操作系统</h1>\n<h1 id=\"并发\"><a class=\"markdownIt-Anchor\" href=\"#并发\">#</a> = 并发 =</h1>\n<h1 id=\"多处理器编程\"><a class=\"markdownIt-Anchor\" href=\"#多处理器编程\">#</a> 多处理器编程</h1>\n<h2 id=\"并发-2\"><a class=\"markdownIt-Anchor\" href=\"#并发-2\">#</a> 并发</h2>\n<blockquote>\n<p>Concurrent: existing, happening, or done <em>at the same time</em>.</p>\n<p>In computer science, concurrency refers to the ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in partial order, without affecting the final outcome. (Wikipedia)</p>\n</blockquote>\n<p>操作系统作为 “状态机的管理者”，引入了共享的状态</p>\n<ul>\n<li>带来了并发</li>\n<li>(操作系统是最早的并发程序)</li>\n</ul>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">Tprint</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    sys_write<span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f'</span><span class=\"token interpolation\"><span class=\"token punctuation\">&#123;</span>name<span class=\"token punctuation\">&#125;</span></span><span class=\"token string\">'</span></span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">for</span> name <span class=\"token keyword\">in</span> <span class=\"token string\">'AB'</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        sys_spawn<span class=\"token punctuation\">(</span>Tprint<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><ul>\n<li>使用 model checker 绘制状态图</li>\n</ul>\n<hr>\n<p><strong>多线程共享内存并发</strong></p>\n<p>线程：共享内存的执行流</p>\n<ul>\n<li>执行流拥有独立的堆栈 / 寄存器</li>\n</ul>\n<p>简化的线程 API (thread.h)</p>\n<ul>\n<li><code>spawn(fn)</code>\n<ul>\n<li>创建一个入口函数是 <code>fn</code>  的线程，并立即开始执行\n<ul>\n<li><code>void fn(int tid) &#123; ... &#125;</code></li>\n<li>参数  <code>tid</code>  从 1 开始编号</li>\n</ul>\n</li>\n<li>行为： <code>sys_spawn(fn, tid)</code></li>\n</ul>\n</li>\n<li><code>join()</code>\n<ul>\n<li>等待所有运行线程的返回 (也可以不调用)</li>\n<li>行为： <code>while (done != T) sys_sched()</code></li>\n</ul>\n</li>\n</ul>\n<p>多处理器编程：一个 API 搞定</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"thread.h\"</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Ta</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Tb</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token function\">create</span><span class=\"token punctuation\">(</span>Ta<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token function\">create</span><span class=\"token punctuation\">(</span>Tb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ul>\n<li>这个程序可以利用系统中的多处理器\n<ul>\n<li>操作系统会自动把线程放置在不同的处理器上</li>\n<li>CPU 使用率超过了 100%</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"原子性互斥\"><a class=\"markdownIt-Anchor\" href=\"#原子性互斥\">#</a> 原子性 (互斥)</h2>\n<h2 id=\"执行顺序\"><a class=\"markdownIt-Anchor\" href=\"#执行顺序\">#</a> 执行顺序</h2>\n<h2 id=\"处理器间的可见性\"><a class=\"markdownIt-Anchor\" href=\"#处理器间的可见性\">#</a> 处理器间的可见性</h2>\n<h1 id=\"并发控制基础\"><a class=\"markdownIt-Anchor\" href=\"#并发控制基础\">#</a> 并发控制基础</h1>\n<p><strong>背景回顾</strong>：虽然 “线程库” 入门简单，但多处理器编程 + 编译优化会给我们带来很多意想不到的惊喜。在编写多线程程序时，必须放弃许多对顺序程序编程时的基本假设，这也是并发编程困难的原因。</p>\n<p><strong>本讲内容</strong>：并发编程困难不代表我们只能摆烂 —— 我们还可以创造出新的手段，帮助我们编写正确的并发程序：</p>\n<ul>\n<li>互斥问题和 Peterson 算法</li>\n<li>Peterson 算法的正确性和模型检验</li>\n<li>Peterson 算法在现代多处理器系统上的实现</li>\n<li>实现并发控制的硬件和编译器机制</li>\n</ul>\n<h2 id=\"peterson算法\"><a class=\"markdownIt-Anchor\" href=\"#peterson算法\">#</a> Peterson 算法</h2>\n<p>在共享内容上实现互斥</p>\n<h2 id=\"模型验证model-checker\"><a class=\"markdownIt-Anchor\" href=\"#模型验证model-checker\">#</a> 模型验证 (model checker)</h2>\n<h2 id=\"原子指令\"><a class=\"markdownIt-Anchor\" href=\"#原子指令\">#</a> 原子指令</h2>\n<p>并发编程困难的解决：普通的变量读写在编译器 + 处理器的双重优化下行为变得复杂</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>retry<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>locked <span class=\"token operator\">!=</span> UNLOCK<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">goto</span> retry<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  locked <span class=\"token operator\">=</span> LOCK<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>解决方法：编译器和硬件共同提供不可优化、不可打断的指令</p>\n<ul>\n<li>“原子指令” + compiler barrier</li>\n</ul>\n<h1 id=\"并发控制互斥\"><a class=\"markdownIt-Anchor\" href=\"#并发控制互斥\">#</a> 并发控制：互斥</h1>\n<p><strong>背景回顾</strong>：互斥 (Peterson 算法)：为了掌控并发程序的复杂行为，使程序退回到 “串行执行” 的 lock &amp; unlock。</p>\n<p><strong>本讲内容</strong>：现代多处理器系统上的互斥实现：</p>\n<ul>\n<li>互斥问题的定义和假设</li>\n<li>自旋锁</li>\n<li>互斥锁和 Futex</li>\n</ul>\n<p>review：并发编程（理解并发的工具）</p>\n<ul>\n<li>线程 = 人 (大脑能完成局部存储和计算)</li>\n<li>共享内存 = 物理世界 (物理世界天生并行)</li>\n<li>一切都是状态机 (debugger &amp; model checker)</li>\n</ul>\n<h2 id=\"互斥问题\"><a class=\"markdownIt-Anchor\" href=\"#互斥问题\">#</a> 互斥问题</h2>\n<p>互斥 (mutual exclusion)，“互相排斥”</p>\n<ul>\n<li>\n<p>实现  <code>lock_t</code>  数据结构和  <code>lock/unlock</code>  API:</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span> <span class=\"token class-name\">lock_t</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>lk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">lock_t</span> <span class=\"token operator\">*</span>lk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>一把 “排他性” 的锁 —— 对于锁对象  <code>lk</code></p>\n</li>\n<li>\n<p>如果某个线程持有锁，则其他线程的  <code>lock</code>  不能返回 (Safety)</p>\n</li>\n<li>\n<p>在多个线程执行  <code>lock</code>  时，至少有一个可以返回 (Liveness)</p>\n</li>\n<li>\n<p>能<strong>正确处理处理器乱序、宽松内存模型和编译优化</strong></p>\n</li>\n</ul>\n<h1 id=\"并发控制同步\"><a class=\"markdownIt-Anchor\" href=\"#并发控制同步\">#</a> 并发控制：同步</h1>\n<p><strong>背景回顾</strong>：我们已经了解如何通过 “不可优化、保证顺序” 的原子指令实现自旋锁，以及借助操作系统 (系统调用) 实现线程的睡眠，从而不致于出现 CPU 空转的浪费。然而，互斥并不总是能满足多个并发线程协作完成任务的需求，例如大家试着在完成 Minilab 时应该已经遇到了一些困难。如何能便捷地让共享内存的线程协作以共同完成计算任务？</p>\n<p><strong>本讲内容</strong>：并发控制：同步</p>\n<ul>\n<li>同步问题的定义</li>\n<li>生产者 - 消费者问题</li>\n<li>条件变量</li>\n<li>信号量</li>\n<li>信号量适合解决什么问题</li>\n<li>哲学家吃饭问题</li>\n</ul>\n<h2 id=\"同步问题\"><a class=\"markdownIt-Anchor\" href=\"#同步问题\">#</a> 同步问题</h2>\n<p>同步 (Synchronization)：两个或两个以上随时间变化的量在变化过程中保持一定的相对关系。</p>\n<h1 id=\"真实世界的并发编程\"><a class=\"markdownIt-Anchor\" href=\"#真实世界的并发编程\">#</a> 真实世界的并发编程</h1>\n<p><strong>背景回顾</strong>：我们已经掌握了多种并发控制技术：自旋锁、互斥锁、条件变量、信号量。我们已经可以实现共享内存系统上的任意并发 / 并行计算。然而，大家也在使用这些 “底层” 并发控制时发现使用的困难。那么，真实世界的程序员是怎么实现并发程序的？</p>\n<p><strong>本讲内容</strong>：(本节为科普) 并发编程模型与底层同步机制的封装</p>\n<ul>\n<li>高性能计算中的并行编程 (embarrassingly parallel 的数值计算)</li>\n<li>数据中心中的并发编程 (协程、Goroutine 和 channel)</li>\n<li>人工智能时代的分布式机器学习 (GPU 和 Parameter Server)</li>\n<li>用户身边的并发编程 (Web 和异步编程)</li>\n</ul>\n<h1 id=\"并发-bugs\"><a class=\"markdownIt-Anchor\" href=\"#并发-bugs\">#</a> 并发 Bugs</h1>\n<p><strong>常见的并发 bugs</strong></p>\n<ul>\n<li>死锁</li>\n<li>数据竞争</li>\n<li>原子性和顺序违反</li>\n</ul>\n<h1 id=\"并发-bug-的应对\"><a class=\"markdownIt-Anchor\" href=\"#并发-bug-的应对\">#</a> 并发 Bug 的应对</h1>\n<p><strong>背景回顾</strong>：我们在编写并发程序时，难免会遇到死锁、数据竞争、原子性 / 顺序违反等类型的并发 bugs。即便我们知道它们的定义和触发条件，直接在编程时消灭它们依然是十分困难的。以数据竞争为例，它的定义貌似简单：两个线程同时访问同一内存地址，并且至少有一个是写。但 “访问内存” 则可能出其不意 —— 例如 ret 指令和栈上数据的修改产生的数据竞争。那么，我们应该如何应对这些并发 bugs？</p>\n<p><strong>本讲内容</strong>：<strong>一节真正的 “编程” 课</strong>：如何正确地 (并发) 编程：</p>\n<ul>\n<li>Lock ordering</li>\n<li>防御性编程</li>\n<li>运行时检查</li>\n</ul>\n<h1 id=\"多处理器系统与中断机制\"><a class=\"markdownIt-Anchor\" href=\"#多处理器系统与中断机制\">#</a> 多处理器系统与中断机制</h1>\n<p><strong>背景回顾</strong>：我们已经了解并发编程实践需要的几乎全部内容 —— 线程、内存模型、互斥、同步和并发 bugs 的应对。但我们一直是在简化的线程模型 (thread.h) 上讲解的。但我们还没有回答一个关键问题：线程到底在计算机硬件上是如何实现的？即便系统中只有一个处理器，我们依然可以创建很多并发执行的线程。</p>\n<p><strong>本讲内容</strong>：操作系统内核实现</p>\n<ul>\n<li>多处理器和中断</li>\n<li>AbstractMachine API</li>\n<li>50 行实现嵌入式操作系统</li>\n</ul>\n<h1 id=\"虚拟化\"><a class=\"markdownIt-Anchor\" href=\"#虚拟化\">#</a> = 虚拟化 =</h1>\n<h1 id=\"操作系统上的进程\"><a class=\"markdownIt-Anchor\" href=\"#操作系统上的进程\">#</a> 操作系统上的进程</h1>\n<p><strong>背景回顾</strong>：有关状态机、并发和中断的讨论给我们真正理解操作系统奠定了基础，现在我们正式进入操作系统和应用程序的 “边界” 了。让我们把视角回到单线程应用程序，即 “执行计算指令和系统调用指令的状态机”，开始对操作系统和进程的讨论。</p>\n<p><strong>本讲内容</strong>：操作系统上的进程</p>\n<ul>\n<li>线程、进程和操作系统</li>\n<li>UNIX/Linux 进程管理 API</li>\n</ul>\n<h2 id=\"进程process线程\"><a class=\"markdownIt-Anchor\" href=\"#进程process线程\">#</a> 进程（Process）&amp; 线程（）</h2>\n<blockquote>\n<p>进程映像（静态）由程序段，数据段和进程控制块 (PCB) 组成</p>\n<p>进程（动态）是具有独立功能的程序在一个数据集合上运行的过程</p>\n<p>进程是系统进行资源分配基本单位，线程是处理机分配的基本单元。</p>\n</blockquote>\n<p>进程状态：</p>\n<ul>\n<li>运行态</li>\n<li>就绪态</li>\n<li>阻塞态</li>\n<li>创建态</li>\n<li>结束态</li>\n</ul>\n<blockquote>\n<p>线程即 “轻量型进程”，他是一个基本的 CPU 执行单元，是程序执行流的最小单元。</p>\n<p>线程由线程 ID、程序计数器、寄存器集合和堆栈组成。</p>\n<p>线程自己不拥有资源，和同一进程的其他线程共享进程的所有资源。</p>\n</blockquote>\n<p><strong>引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量；</strong></p>\n<p><strong>引入线程的目的是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</strong></p>\n<h1 id=\"linux-操作系统\"><a class=\"markdownIt-Anchor\" href=\"#linux-操作系统\">#</a> Linux 操作系统</h1>\n<h1 id=\"进程的地址空间\"><a class=\"markdownIt-Anchor\" href=\"#进程的地址空间\">#</a> 进程的地址空间</h1>\n<h1 id=\"系统调用和-unix-shell\"><a class=\"markdownIt-Anchor\" href=\"#系统调用和-unix-shell\">#</a> 系统调用和 UNIX Shell</h1>\n<h1 id=\"c-标准库的实现\"><a class=\"markdownIt-Anchor\" href=\"#c-标准库的实现\">#</a> C 标准库的实现</h1>\n<h1 id=\"可执行文件的加载\"><a class=\"markdownIt-Anchor\" href=\"#可执行文件的加载\">#</a> 可执行文件的加载</h1>\n<h1 id=\"处理器调度\"><a class=\"markdownIt-Anchor\" href=\"#处理器调度\">#</a> 处理器调度</h1>\n<h1 id=\"进程-线程与系统调用\"><a class=\"markdownIt-Anchor\" href=\"#进程-线程与系统调用\">#</a> 进程、线程与系统调用</h1>\n<h1 id=\"持久化\"><a class=\"markdownIt-Anchor\" href=\"#持久化\">#</a> = 持久化 =</h1>\n<h1 id=\"存储设备原理\"><a class=\"markdownIt-Anchor\" href=\"#存储设备原理\">#</a> 存储设备原理</h1>\n<h1 id=\"输入输出设备\"><a class=\"markdownIt-Anchor\" href=\"#输入输出设备\">#</a> 输入输出设备</h1>\n<h1 id=\"设备驱动程序\"><a class=\"markdownIt-Anchor\" href=\"#设备驱动程序\">#</a> 设备驱动程序</h1>\n<h1 id=\"文件系统-api\"><a class=\"markdownIt-Anchor\" href=\"#文件系统-api\">#</a> 文件系统 API</h1>\n<h1 id=\"fat-和-unix-文件系统\"><a class=\"markdownIt-Anchor\" href=\"#fat-和-unix-文件系统\">#</a> FAT 和 UNIX 文件系统</h1>\n<h1 id=\"持久数据的可靠性\"><a class=\"markdownIt-Anchor\" href=\"#持久数据的可靠性\">#</a> 持久数据的可靠性</h1>\n",
            "tags": [
                "Linux",
                "操作系统"
            ]
        },
        {
            "id": "https://adventure-yx.github.io/2023/03/01/Linux/",
            "url": "https://adventure-yx.github.io/2023/03/01/Linux/",
            "title": "Linux",
            "date_published": "2023-03-01T14:03:56.000Z",
            "content_html": "<h1 id=\"linux-配置\"><a class=\"markdownIt-Anchor\" href=\"#linux-配置\">#</a> Linux 配置</h1>\n<p>windows powershell</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>wsl <span class=\"token parameter variable\">--installl</span> <span class=\"token parameter variable\">-d</span> Ubuntu-20.04</pre></td></tr></table></figure><p>linux</p>\n<p>uname -r ： 显示操作系统的发行版号<br>\n uname -a ：显示系统名、节点名称、操作系统的发行版号、内核版本等等。</p>\n<p><img data-src=\"image-20230420174648351.png\" alt=\"image-20230420174648351\"></p>\n<blockquote>\n<p><strong>系统名：</strong></p>\n<p>Linux</p>\n<p><strong>节点名称：</strong></p>\n<p>LAPTOP-G8CK4FEN</p>\n<p><strong>操作系统的发行版号：</strong></p>\n<p>5.10.16.3-microsoft-standard-WSL2</p>\n<p><strong>硬件平台：</strong><br>\nx86_64</p>\n<p><strong>机器硬件名：</strong><br>\nx86_64</p>\n<p><strong>系统处理器的体系结构：</strong><br>\nx86_64</p>\n<p><strong>操作系统：</strong><br>\nGNU/Linux</p>\n</blockquote>\n<p>更新软件包</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">apt-get</span> update</pre></td></tr></table></figure><p>安装最常用 linux 桌面程序 gedit</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">apt</span> <span class=\"token function\">install</span> gedit</pre></td></tr></table></figure><p>安装编译工具 gcc+cmake</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">apt</span> <span class=\"token function\">install</span> build-essential</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">apt</span> <span class=\"token function\">install</span> cmake</pre></td></tr></table></figure><figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> <span class=\"token function\">vim</span></pre></td></tr></table></figure><ul>\n<li>\n<p>Linux yum 命令</p>\n<p><code>yum</code> （ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。</p>\n<p>基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p>\n<p><code>yum</code>  提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>\n</li>\n<li>\n<p>Linux apt 命令</p>\n<p><code>apt</code> （Advanced Packaging Tool）是一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。</p>\n<p><code>apt</code>  命令提供了查找、安装、升级、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>\n<p><code>apt</code>  命令执行需要超级管理员权限 (root)。</p>\n</li>\n</ul>\n<h1 id=\"linux基础\"><a class=\"markdownIt-Anchor\" href=\"#linux基础\">#</a> Linux 基础</h1>\n<h2 id=\"一些名词\"><a class=\"markdownIt-Anchor\" href=\"#一些名词\">#</a> 一些名词</h2>\n<p>在学习和使用 Linux 的过程中，经常会见到一些特有名词:</p>\n<ul>\n<li>GNU：Gnu’s Not Unix. 可以理解成一种口号，最早由 Richard Stallman 呼吁并倡导的，号召软件自由。</li>\n<li>GPL：General Public License. GNU 通用公共许可证，GPL 授予程序的接受方下述的权利，即 GPL 所倡导的 “自由”：\n<ul>\n<li>可以以任何目的运行所购买的程序；</li>\n<li>在得到程序代码的前提下，可以以学习为目的，对源程序进行修改；</li>\n<li>可以对复制件进行再发行；</li>\n<li>对所购买的程序进行改进，并进行公开发布。</li>\n</ul>\n</li>\n<li>LGPL (GNU Lesser General Public License): LGPL 是 GPL 的一个为主要为类库使用设计的开源协议。\n<ul>\n<li>LGPL 允许商业软件通过类库引用 (link) 方式使用 LGPL 类库而不需要开源商业软件的代码。</li>\n<li>采用 LGPL 协议的开源代码可以被商业软件作为类库引用并发布和销售。</li>\n</ul>\n</li>\n<li>BSD 开源协议: BSD 开源协议是一个给于使用者很大自由的协议。基本上使用者可以” 为所欲为”，以 BSD 协议代码为基础做二次开发自己的产品时，需要满足三个条件：\n<ul>\n<li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的 BSD 协议。</li>\n<li>不可以用开源代码的作者 / 机构名字和原来产品的名字做市场推广。</li>\n<li>BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。</li>\n</ul>\n</li>\n<li>FSF：自由软件基本会，给 GNU 提供资金支付的，毕竟没钱难成事啊。</li>\n<li>自由软件：GNU 项目下的所有软件都基于 GPL 许可证（非 GNU 项目也可使用 GPL），都是自由软件。</li>\n<li>开源软件：是美国 Open Source Initiative 协会定义，软件开放源代码。</li>\n<li>POSIX：（Portable Operating System Interface for Computing Systems）是由 IEEE 和 ISO/IEC 开发的一套标准。POSIX 标准是对 UNIX 操作系统的经验和实践的总结，对操作系统调用的服务接口进行了标准化，保证所编制的应用程序在源代码一级可以在多种操作系统上进行移植。</li>\n</ul>\n<h2 id=\"linux-内核\"><a class=\"markdownIt-Anchor\" href=\"#linux-内核\">#</a> Linux 内核</h2>\n<p>Linux 系统从应用角度来看，分为内核空间和用户空间两个部分。内核空间是 Linux 操作系统的主要部分，但是仅有内核的操作系统是不能完成用户任务的。丰富并且功能强大的应用程序包是一个操作系统成功的必要件。</p>\n<p>Linux 的内核主要由 5 个子系统组成：** 进程调度、内存管理、虚拟文件系统、网络接口、进程间通信。** 下面将依次讲解这 5 个子系统。</p>\n<ul>\n<li>\n<p>进程调度 SCHED</p>\n<p>进程调度指的是系统对进程的多种状态之间转换的策略。Linux 下的进程调度有 3 种策略：SCHED_OTHER、SCHED_FIFO 和 SCHED_RR。</p>\n<ul>\n<li>SCHED_OTHER：分时调度策略（默认），是用于针对普通进程的时间片轮转调度策略。</li>\n<li>SCHED_FIFO：实时调度策略，是针对运行的实时性要求比较高、运行时间短的进程调度策略</li>\n<li>SCHED_RR：实时调度策略，是针对实时性要求比较高、运行时间比较长的进程调度策略。</li>\n</ul>\n</li>\n<li>\n<p>内存管理 MMU</p>\n<ul>\n<li>内存管理是多个进程间的内存共享策略。在 Linux 中，内存管理主要说的是虚拟内存。</li>\n<li>虚拟内存可以让进程拥有比实际物理内存更大的内存，可以是实际内存的很多倍。</li>\n<li>每个进程的虚拟内存有不同的地址空间，多个进程的虚拟内存不会冲突。</li>\n</ul>\n</li>\n<li>\n<p>虚拟文件系统 VFS</p>\n<ul>\n<li>在 Linux 下支持多种文件系统，如 ext、ext2、minix、umsdos、msdos、vfat、ntfs、proc、smb、ncp、iso9660、sysv、hpfs、affs 等。</li>\n<li>目前 Linux 下最常用的文件格式是 ext2 和 ext3。</li>\n</ul>\n</li>\n<li>\n<p>网络接口</p>\n<p>Linux 是在 Internet 飞速发展的时期成长起来的，所以 Linux 支持多种网络接口和协议。网络接口分为网络协议和驱动程序，网络协议是一种网络传输的通信标准，而网络驱动则是对硬件设备的驱动程序。Linux 支持的网络设备多种多样，几乎目前所有网络设备都有驱动程序。</p>\n</li>\n<li>\n<p>进程间通信</p>\n<p>Linux 操作系统支持多进程，进程之间需要进行数据的交流才能完成控制、协同工作等功能，Linux 的进程间通信是从 UNIX 系统继承过来的。Linux 下的进程间的通信方式主要有管道、信号、消息队列、共享内存和套接字等方法。</p>\n</li>\n</ul>\n<h2 id=\"linux-系统目录结构\"><a class=\"markdownIt-Anchor\" href=\"#linux-系统目录结构\">#</a> Linux 系统目录结构</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">ls</span> /</pre></td></tr></table></figure><p><img data-src=\"image-20230309080718084.png\" alt=\"image-20230309080718084\"></p>\n<p>树状目录结构：</p>\n<p><img data-src=\"d0c50-linux2bfile2bsystem2bhierarchy.jpg\" alt=\"img\"></p>\n<p><strong>系统启动必须：</strong></p>\n<ul>\n<li>\n<p><code>/boot</code> ：存放的启动 Linux 时使用的内核文件，包括连接文件以及镜像文件。</p>\n</li>\n<li>\n<p><code>/etc</code> ：<strong>存放</strong>所有<strong>的系统需要的</strong>配置文件<strong>和</strong>子目录列表，** 更改目录下的文件可能会导致系统不能启动。</p>\n</li>\n<li>\n<p><code>/lib</code> ：存放基本代码库（比如 c++ 库），其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p>\n</li>\n<li>\n<p><code>/sys</code> ： 这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中</p>\n</li>\n</ul>\n<p><strong>指令集合：</strong></p>\n<ul>\n<li>\n<p><code>/bin</code> ：存放着最常用的程序和指令</p>\n</li>\n<li>\n<p><code>/sbin</code> ：只有系统管理员能使用的程序和指令。是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p>\n</li>\n</ul>\n<p><strong>外部文件管理：</strong></p>\n<ul>\n<li>\n<p><code>/dev</code>  ：Device (设备) 的缩写，存放的是 Linux 的外部设备。<strong>注意</strong>：在 Linux 中访问设备和访问文件的方式是相同的。</p>\n</li>\n<li>\n<p><code>/media</code> ：类 windows 的<strong>其他设备</strong>，例如 U 盘、光驱等等，识别后 linux 会把设备放到这个目录下。</p>\n</li>\n<li>\n<p><code>/mnt</code> ：临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</p>\n</li>\n</ul>\n<p><strong>临时文件：</strong></p>\n<ul>\n<li>\n<p><code>/run</code> ：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p>\n</li>\n<li>\n<p><code>/lost+found</code> ：一般情况下为空的，系统非法关机后，这里就存放一些文件。</p>\n</li>\n<li>\n<p><code>/tmp</code> ：这个目录是用来存放一些临时文件的。</p>\n</li>\n</ul>\n<p><strong>账户：</strong></p>\n<ul>\n<li>\n<p><code>/root</code> ：系统管理员的用户主目录。</p>\n</li>\n<li>\n<p><code>/home</code> ：用户的主目录，以用户的账号命名的。</p>\n</li>\n<li>\n<p><code>/usr</code> ： usr 是 unix shared resources (共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p>\n</li>\n<li>\n<p><code>/usr/bin</code> ：系统用户使用的应用程序与指令。</p>\n</li>\n<li>\n<p><code>/usr/sbin</code> ：超级用户使用的比较高级的管理程序和系统守护程序。</p>\n</li>\n<li>\n<p><code>/usr/src</code> ：内核源代码默认的放置目录。</p>\n</li>\n</ul>\n<p><strong>运行过程中要用：</strong></p>\n<ul>\n<li>\n<p><code>/var</code> ：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。</p>\n</li>\n<li>\n<p><code>/proc</code> ：管理 ** 内存空间！** 虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</p>\n</li>\n</ul>\n<p><strong>扩展用的：</strong></p>\n<ul>\n<li>\n<p><code>/opt</code> ：默认是空的，我们安装额外软件可以放在这个里面。</p>\n</li>\n<li>\n<p><code>/srv</code> ：存放服务启动后需要提取的数据 **（不用服务器就是空）**</p>\n</li>\n</ul>\n<h2 id=\"linux-文件基本属性\"><a class=\"markdownIt-Anchor\" href=\"#linux-文件基本属性\">#</a> Linux 文件基本属性</h2>\n<p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。</p>\n<p>为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p>\n<p>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p>\n<ul>\n<li><code>chown</code>  (change owner) ： 修改所属用户与组。</li>\n<li><code>chmod</code>  (change mode) ： 修改用户的权限。</li>\n</ul>\n<p>在 Linux 中我们可以使用  <code>ll</code>  或者  <code>ls –l</code>  命令来显示一个文件的属性以及文件所属的用户和组，如：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>root@LAPTOP-G8CK4FEN:/<span class=\"token comment\"># ll</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>total <span class=\"token number\">1480</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>drwxr-xr-x  <span class=\"token number\">19</span> root root    <span class=\"token number\">4096</span> Mar  <span class=\"token number\">9</span> 08:01 ./</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>drwxr-xr-x  <span class=\"token number\">19</span> root root    <span class=\"token number\">4096</span> Mar  <span class=\"token number\">9</span> 08:01 <span class=\"token punctuation\">..</span>/</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>lrwxrwxrwx   <span class=\"token number\">1</span> root root       <span class=\"token number\">7</span> Apr <span class=\"token number\">23</span>  <span class=\"token number\">2020</span> bin -<span class=\"token operator\">></span> usr/bin/</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>drwxr-xr-x   <span class=\"token number\">2</span> root root    <span class=\"token number\">4096</span> Apr <span class=\"token number\">23</span>  <span class=\"token number\">2020</span> boot/</pre></td></tr></table></figure><p>实例中，<strong>boot</strong> 文件的第一个属性用 <strong>d</strong> 表示。<strong>d</strong> 在 Linux 中代表该文件是一个目录文件。</p>\n<p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p>\n<ul>\n<li>当为 <strong>d</strong> 则是目录</li>\n<li>当为 <strong>-</strong> 则是文件；</li>\n<li>若是 <strong>l</strong> 则表示为链接文档 (link file)；</li>\n<li>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备 (可随机存取装置)；</li>\n<li>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标 (一次性读取装置)。</li>\n</ul>\n<p>接下来的字符中，以三个为一组，且均为 <strong>rwx</strong> 的三个参数的组合。其中， <strong>r</strong> 代表可读 (read)、 <strong>w</strong> 代表可写 (write)、 <strong>x</strong> 代表可执行 (execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 <strong>-</strong> 而已。</p>\n<p><img data-src=\"file-llls22.jpg\" alt=\"img\"></p>\n<p><img data-src=\"363003_1227493859FdXT.png\" alt=\"363003_1227493859FdXT\"></p>\n<p>从左至右用 <strong>0-9</strong> 这些数字来表示。</p>\n<p>第 <strong>0</strong> 位确定文件类型，第 <strong>1-3</strong> 位确定属主（该文件的所有者）拥有该文件的权限。</p>\n<p>第 4-6 位确定属组（所有者的同组用户）拥有该文件的权限，第 7-9 位确定其他用户拥有该文件的权限。</p>\n<p>其中，第 <strong>1、4、7</strong> 位表示读权限，如果用 <strong>r</strong> 字符表示，则有读权限，如果用 <strong>-</strong> 字符表示，则没有读权限；第 <strong>2、5、8</strong> 位表示写权限，如果用 <strong>w</strong> 字符表示，则有写权限，如果用 <strong>-</strong> 字符表示没有写权限；第 <strong>3、6、9</strong> 位表示可执行权限，如果用 <strong>x</strong> 字符表示，则有执行权限，如果用 <strong>-</strong> 字符表示，则没有执行权限。</p>\n<h2 id=\"linux-文件与目录管理\"><a class=\"markdownIt-Anchor\" href=\"#linux-文件与目录管理\">#</a> Linux 文件与目录管理</h2>\n<p>我们知道 Linux 的目录结构为树状结构，最顶级的目录为根目录 <strong>/</strong>。</p>\n<p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p>\n<ul>\n<li><strong>绝对路径：</strong><br>\n路径的写法，由根目录 <strong>/</strong> 写起，例如： <code>/usr/share/doc</code>  这个目录。</li>\n<li><strong>相对路径：</strong><br>\n路径的写法，不是由 <strong>/</strong> 写起，例如由  <code>/usr/share/doc</code>  要到  <code>/usr/share/man</code>  底下时，可以写成：  <code>cd ../man</code>  这就是相对路径的写法。</li>\n</ul>\n<p><strong>“/” 在系统文件中表示绝对路径；</strong></p>\n<p>“/” 处于 Linux 文件系统<strong>树形结构</strong>的最顶端，我们称它为 Linux 文件系统的 root，<strong>它是 Linux 文件系统的入口</strong>；<br>\n所有的目录、文件、设备都在 “/” 之下，它是 Linux 文件系统最顶层的唯一的目录；<br>\n一般建议在根目录下面只有目录，不要直接存放文件；<br>\n根目录是 linux 系统启动时系统第一个载入的分区，所以启动过程中用到的文件应该都放在这个分区中；<br>\n其中 <code>/etc</code> 、 <code>/bin</code> 、 <code>/dev</code> 、 <code>/lib</code> 、 <code>/sbin</code>  这 5 个子目录都应该要与根目录连在一起，不可独立成为某个分区。</p>\n<p><strong>“./” 代表的意思是</strong>： ./ 代表当前文件目录，某一个文件（或者目录）的查找路径是从当前目录 “.” 下面开始进行查找。</p>\n<p><strong>“~” 代表的意思是</strong>：表示代码主目录，也就是当前登录用户的用户目录。</p>\n<p><strong>“…” 代表的意思是</strong>：“…” 表示上级目录</p>\n<h2 id=\"命令解析器\"><a class=\"markdownIt-Anchor\" href=\"#命令解析器\">#</a> 命令解析器</h2>\n<blockquote>\n<p>在 Linux 中需要通过终端执行对应的命令来完成某些操作，那么这些命令是如何被执行的呢？</p>\n<p>这些命令都是通过命令解析器解析完成并执行的，如果用户在终端输入是正确的内部指令，命令解析器就执行这个命令，如果不是正确的指令，则提示命令无法解析。</p>\n</blockquote>\n<h3 id=\"工作原理\"><a class=\"markdownIt-Anchor\" href=\"#工作原理\">#</a> 工作原理</h3>\n<p>命令解析器在 Linux 操作系统中就是一个进程 (运行的应用程序), 它的名字叫做 bash 通常我们更习惯将其称之为 shell (即: sh)。他们之间的渊源是这样的，在 Unix 操作系统诞生之后一个叫伯恩 (Bourne) 的人为其编写了命令解析器取名为 shell, Linux 操作系统诞生之后伯恩再次改写了 shell (sh), 将其称之为 bash (Bourne Again SHell), bash 就是 sh 的增强版本。</p>\n<p>在 Linux 操作系统中默认使用的命令解析器是 bash, 当然也同样支持使用 sh。当用户打开一个终端窗口，并输入相关指令， 按回车键， 这时候命令解析器就开始工作了， 具体步骤如下：</p>\n<ul>\n<li>\n<p>在 Linux 中有一个叫做 PATH 的环境变量，里边存储了一些系统目录 (windows 也有，叫 Path)</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 通过 echo 命令可以查看环境变量 PATH 中的值，在 shell 中变量名前加 $ 就是取值</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@VM-8-14-centos ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># echo $PATH</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</pre></td></tr></table></figure></li>\n<li>\n<p>命令解析器需要依次搜索 PATH 中的各个目录，检查这些目录中是否有用户输入的指令</p>\n<ul>\n<li>\n<p>如果找到了，执行该目录下的可执行程序，用户输入的命令就被执行完毕了</p>\n</li>\n<li>\n<p>如果没有找到，继续搜索其他目录，最后还是没有找到，会提示命令找不到，因此无法被执行</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@VM-8-14-centos ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># asdjflksd</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>-bash: asdjflksd: <span class=\"token builtin class-name\">command</span> not found</pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"命令提示行\"><a class=\"markdownIt-Anchor\" href=\"#命令提示行\">#</a> 命令提示行</h3>\n<p>在 Linux 终端中，输入要执行的指令之前会有想用的命令提示，我们将其称之为命令提示行，例如:</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@VM-8-14-centos ~/mywork/workspace<span class=\"token punctuation\">]</span><span class=\"token comment\">#</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>user01@VM-8-14-centos ~/mywork/workspace<span class=\"token punctuation\">]</span>$</pre></td></tr></table></figure><ul>\n<li><code>root</code>  : 当前登录的用户的用户名</li>\n<li><code>@</code> : at -&gt; 在</li>\n<li><code>VM-8-14-centos</code> : 主机名，在安装这个 linux 操作系统的时候手动指定，可以修改\n<ul>\n<li><code>~</code> : 当前用户的家目录\n<ul>\n<li>在 linux 中有很多用户，每个用户都用一个属于自己的目录，这个目录称之为家目录</li>\n<li>普通用户家目录 /home/ 用户名，root 用户家目录 /root</li>\n</ul>\n</li>\n<li><code>~/mywork/workspace</code> : 当前用户所在的工作目录，也可以使用 pwd 命令查看</li>\n<li><code>#</code> : 代表当前用户是  <code>root</code>  用户</li>\n<li><code>$:</code>  当前用户是普通用户，也就是说例子中的 <code>user01</code>  是一个普通用户</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"命令行快捷键\"><a class=\"markdownIt-Anchor\" href=\"#命令行快捷键\">#</a> 命令行快捷键</h3>\n<ul>\n<li><code>Tab</code> \t命令自动补齐\n<ul>\n<li>在终端中输入 某个命令的前一个或若干个字符，再按 Tab 键</li>\n<li>由于很多 shell 命令的开头字母是相同的，在这种情况下，按一次 Tab 是不会自动补齐的，我们可以连续按两次 Tab 键，在当前终端中就可以显示出所有匹配成功的 shell 命令</li>\n<li>为了能够快速补全 shell 指令，我们可以多输入一些前缀字符之后，再按 Tab 键</li>\n</ul>\n</li>\n<li><code>Ctrl+p</code> \t显示输入的上一个历史命令\n<ul>\n<li>从输入的最后一个命令往前倒，也可以使用 ↑键</li>\n</ul>\n</li>\n<li><code>Ctrl+n</code> \t显示输入的下一个历史命令\t也可以使用 ↓键</li>\n<li><code>Ctrl+a</code> \t光标移动命命令行首\t也可以使用 Home 键</li>\n<li><code>Ctrl+e</code> \t光标移动命命令行尾\t也可以使用 End 键</li>\n<li><code>Ctrl+u</code> \t删除光标前的部分字符串</li>\n<li><code>Ctrl+k</code> \t删除光标后的部分字符串</li>\n<li><code>Backspace/Delete</code> \t删除光标前 / 后的一个字符</li>\n</ul>\n<h2 id=\"处理目录的常用命令\"><a class=\"markdownIt-Anchor\" href=\"#处理目录的常用命令\">#</a> 处理目录的常用命令</h2>\n<ul>\n<li><code>ls</code> （英文全拼：list files）: 列出目录及文件名</li>\n<li><code>cd</code> （英文全拼：change directory）：切换目录</li>\n<li><code>pwd</code> （英文全拼：print work directory）：显示目前的目录</li>\n<li><code>mkdir</code> （英文全拼：make directory）：创建一个新的目录</li>\n<li><code>rmdir</code> （英文全拼：remove directory）：删除一个空的目录</li>\n<li><code>cp</code> （英文全拼：copy file）: 复制文件或目录</li>\n<li><code>rm</code> （英文全拼：remove）: 删除文件或目录</li>\n<li><code>mv</code> （英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li>\n</ul>\n<p>可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p>\n<h3 id=\"ls-列出目录\"><a class=\"markdownIt-Anchor\" href=\"#ls-列出目录\">#</a> ls (列出目录)</h3>\n<p>在 Linux 系统当中， ls 命令可能是最常被运行的。</p>\n<p>选项与参数：</p>\n<ul>\n<li>-a ：全部的文件，连同隐藏文件 (开头为。的文件) 一起列出来 (常用)</li>\n<li>-d ：仅列出目录本身，而不是列出目录内的文件数据 (常用)</li>\n<li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li>\n</ul>\n<h3 id=\"cd-切换目录\"><a class=\"markdownIt-Anchor\" href=\"#cd-切换目录\">#</a> cd (切换目录)</h3>\n<p>cd 是 Change Directory 的缩写，这是用来变换工作目录的命令。</p>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">cd</span> <span class=\"token punctuation\">[</span>相对路径或绝对路径<span class=\"token punctuation\">]</span></pre></td></tr></table></figure><figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#使用 mkdir 命令创建 runoob 目录</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># mkdir runoob</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">#使用绝对路径切换到 runoob 目录</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cd /root/runoob/</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">#使用相对路径切换到 runoob 目录</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cd ./runoob/</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\"># 表示回到自己的家目录，亦即是 /root 这个目录</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">[</span>root@www runoob<span class=\"token punctuation\">]</span><span class=\"token comment\"># cd ~</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\"># 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cd ..</span></pre></td></tr></table></figure><h3 id=\"pwd-显示目前所在的目录\"><a class=\"markdownIt-Anchor\" href=\"#pwd-显示目前所在的目录\">#</a> pwd (显示目前所在的目录)</h3>\n<p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># pwd [-P]</span></pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li><strong>-P</strong> ：显示出确实的路径，而非使用链接 (link) 路径。</li>\n</ul>\n<h3 id=\"mkdir-创建新目录\"><a class=\"markdownIt-Anchor\" href=\"#mkdir-创建新目录\">#</a> mkdir (创建新目录)</h3>\n<p>如果想要创建新的目录的话，那么就使用 mkdir (make directory) 吧。</p>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">mkdir</span> <span class=\"token punctuation\">[</span>-mp<span class=\"token punctuation\">]</span> 目录名称</pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li>\n<li>-p ：帮助你直接将所需要的目录 (包含上一级目录) 递归创建起来！</li>\n</ul>\n<p>实例：请到 /tmp 底下尝试创建数个新目录看看：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cd /tmp</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># mkdir test    &lt;== 创建一名为 test 的新目录</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># mkdir test1/test2/test3/test4</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>mkdir: cannot create directory `test1/test2/test3/test4': </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>No such <span class=\"token function\">file</span> or directory       <span class=\"token operator\">&lt;=</span><span class=\"token operator\">=</span> 没办法直接创建此目录啊！</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># mkdir -p test1/test2/test3/test4</span></pre></td></tr></table></figure><h3 id=\"rmdir-删除空的目录\"><a class=\"markdownIt-Anchor\" href=\"#rmdir-删除空的目录\">#</a> rmdir (删除空的目录)</h3>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">rmdir</span> <span class=\"token punctuation\">[</span>-p<span class=\"token punctuation\">]</span> 目录名称</pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>**-p ：** 从该目录起，一次删除多级空目录</li>\n</ul>\n<p>删除 runoob 目录</p>\n<pre><code>[root@www tmp]# rmdir runoob/\n</code></pre>\n<p>将 mkdir 实例中创建的目录 (/tmp 底下) 删除掉！</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># ls -l   &lt;== 看看有多少目录存在？</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>drwxr-xr-x  <span class=\"token number\">3</span> root  root <span class=\"token number\">4096</span> Jul <span class=\"token number\">18</span> <span class=\"token number\">12</span>:50 <span class=\"token builtin class-name\">test</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>drwxr-xr-x  <span class=\"token number\">3</span> root  root <span class=\"token number\">4096</span> Jul <span class=\"token number\">18</span> <span class=\"token number\">12</span>:53 test1</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>drwx--x--x  <span class=\"token number\">2</span> root  root <span class=\"token number\">4096</span> Jul <span class=\"token number\">18</span> <span class=\"token number\">12</span>:54 test2</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># rmdir test   &lt;== 可直接删除掉，没问题</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># rmdir test1  &lt;== 因为尚有内容，所以无法删除！</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>rmdir: `test1': Directory not empty</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># rmdir -p test1/test2/test3/test4</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># ls -l        &lt;== 您看看，底下的输出中 test 与 test1 不见了！</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>drwx--x--x  <span class=\"token number\">2</span> root  root <span class=\"token number\">4096</span> Jul <span class=\"token number\">18</span> <span class=\"token number\">12</span>:54 test2</pre></td></tr></table></figure><p>利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。</p>\n<p>不过要注意的是，这个 <strong>rmdir 仅能删除空的目录</strong>，你可以使用 <strong>rm 命令来删除非空目录</strong>。</p>\n<h3 id=\"cp-复制文件或目录\"><a class=\"markdownIt-Anchor\" href=\"#cp-复制文件或目录\">#</a> cp (复制文件或目录)</h3>\n<p>cp 即拷贝文件和目录。</p>\n<p>语法:</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cp [-adfilprsu] 来源档 (source) 目标档 (destination)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cp [options] source1 source2 source3 .... directory</span></pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>**-a：** 相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li>\n<li>**-d：** 若来源档为链接档的属性 (link file)，则复制链接档属性而非文件本身；</li>\n<li>**-f：** 为强制 (force) 的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li>\n<li>**-i：** 若目标档 (destination) 已经存在时，在覆盖时会先询问动作的进行 (常用)</li>\n<li>**-l：** 进行硬式链接 (hard link) 的链接档创建，而非复制文件本身；</li>\n<li>**-p：** 连同文件的属性一起复制过去，而非使用默认属性 (备份常用)；</li>\n<li>**-r：** 递归持续复制，用於目录的复制行为；(常用)</li>\n<li>**-s：** 复制成为符号链接档 (symbolic link)，亦即『捷径』文件；</li>\n<li>**-u：** 若 destination 比 source 旧才升级 destination ！</li>\n</ul>\n<p>用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cp ~/.bashrc /tmp/bashrc</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cp -i ~/.bashrc /tmp/bashrc</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>cp: overwrite `/tmp/bashrc'? n  <span class=\"token operator\">&lt;=</span><span class=\"token operator\">=</span>n不覆盖，y为覆盖</pre></td></tr></table></figure><h3 id=\"rm-移除文件或目录\"><a class=\"markdownIt-Anchor\" href=\"#rm-移除文件或目录\">#</a> rm (移除文件或目录)</h3>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">rm</span> <span class=\"token punctuation\">[</span>-fir<span class=\"token punctuation\">]</span> 文件或目录</pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li>\n<li>-i ：互动模式，在删除前会询问使用者是否动作</li>\n<li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>\n</ul>\n<p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># rm -i bashrc</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>rm: remove regular <span class=\"token function\">file</span> `bashrc'? y</pre></td></tr></table></figure><p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p>\n<h3 id=\"mv-移动文件与目录或修改名称\"><a class=\"markdownIt-Anchor\" href=\"#mv-移动文件与目录或修改名称\">#</a> mv (移动文件与目录，或修改名称)</h3>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># mv [-fiu] source destination</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># mv [options] source1 source2 source3 .... directory</span></pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>\n<li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li>\n<li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li>\n</ul>\n<p>复制一文件，创建一目录，将文件移动到目录中</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cd /tmp</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># cp ~/.bashrc bashrc</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># mkdir mvtest</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># mv bashrc mvtest</span></pre></td></tr></table></figure><p>将某个文件移动到某个目录去，就是这样做！</p>\n<p>将刚刚的目录名称更名为 mvtest2</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># mv mvtest mvtest2</span></pre></td></tr></table></figure><h2 id=\"linux-文件内容查看\"><a class=\"markdownIt-Anchor\" href=\"#linux-文件内容查看\">#</a> Linux 文件内容查看</h2>\n<p>Linux 系统中使用以下命令来查看文件的内容：</p>\n<ul>\n<li><code>cat</code>  由第一行开始显示文件内容</li>\n<li><code>tac</code>  从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>\n<li><code>nl</code>   显示的时候，顺道输出行号！</li>\n<li><code>more</code>  一页一页的显示文件内容</li>\n<li><code>less</code>  与  <code>more</code>  类似，但是比 more 更好的是，他可以往前翻页！</li>\n<li><code>head</code>  只看头几行</li>\n<li><code>tail</code>  只看尾巴几行</li>\n</ul>\n<p>你可以使用 *man [命令]* 来查看各个命令的使用文档，如 ：man cp。</p>\n<h3 id=\"cat\"><a class=\"markdownIt-Anchor\" href=\"#cat\">#</a> cat</h3>\n<p>由第一行开始显示文件内容</p>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">cat</span> <span class=\"token punctuation\">[</span>-AbEnTv<span class=\"token punctuation\">]</span></pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>\n<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>\n<li>-E ：将结尾的断行字节 $ 显示出来；</li>\n<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>\n<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>\n<li>-v ：列出一些看不出来的特殊字符</li>\n</ul>\n<p>检看 /etc/issue 这个文件的内容：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cat /etc/issue</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>CentOS release <span class=\"token number\">6.4</span> <span class=\"token punctuation\">(</span>Final<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Kernel <span class=\"token punctuation\">\\</span>r on an <span class=\"token punctuation\">\\</span>m</pre></td></tr></table></figure><h3 id=\"tac\"><a class=\"markdownIt-Anchor\" href=\"#tac\">#</a> tac</h3>\n<p>tac 与 cat 命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># tac /etc/issue</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Kernel <span class=\"token punctuation\">\\</span>r on an <span class=\"token punctuation\">\\</span>m</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>CentOS release <span class=\"token number\">6.4</span> <span class=\"token punctuation\">(</span>Final<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h3 id=\"nl\"><a class=\"markdownIt-Anchor\" href=\"#nl\">#</a> nl</h3>\n<p>显示行号</p>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">nl</span> <span class=\"token punctuation\">[</span>-bnw<span class=\"token punctuation\">]</span> 文件</pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>-b ：指定行号指定的方式，主要有两种：<br>\n-b a ：表示不论是否为空行，也同样列出行号 (类似 cat -n)；<br>\n-b t ：如果有空行，空的那一行不要列出行号 (默认值)；</li>\n<li>-n ：列出行号表示的方法，主要有三种：<br>\n-n ln ：行号在荧幕的最左方显示；<br>\n-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>\n-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li>\n<li>-w ：行号栏位的占用的位数。</li>\n</ul>\n<p>实例一：用 nl 列出 /etc/issue 的内容</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># nl /etc/issue</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>     <span class=\"token number\">1</span>  CentOS release <span class=\"token number\">6.4</span> <span class=\"token punctuation\">(</span>Final<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     <span class=\"token number\">2</span>  Kernel <span class=\"token punctuation\">\\</span>r on an <span class=\"token punctuation\">\\</span>m</pre></td></tr></table></figure><h3 id=\"more\"><a class=\"markdownIt-Anchor\" href=\"#more\">#</a> more</h3>\n<p>一页一页翻动</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># more /etc/man_db.config </span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">#</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># Generated automatically from man.conf.in by the</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># configure script.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">#</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\"># man.conf from man-1.6d</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">(</span>中间省略<span class=\"token punctuation\">)</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>--More--<span class=\"token punctuation\">(</span><span class=\"token number\">28</span>%<span class=\"token punctuation\">)</span>  <span class=\"token operator\">&lt;=</span><span class=\"token operator\">=</span> 重点在这一行喔！你的光标也会在这里等待你的命令</pre></td></tr></table></figure><p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>\n<ul>\n<li>空白键 (space)：代表向下翻一页；</li>\n<li>Enter     ：代表向下翻『一行』；</li>\n<li>/ 字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>\n<li>:f      ：立刻显示出档名以及目前显示的行数；</li>\n<li>q      ：代表立刻离开 more ，不再显示该文件内容。</li>\n<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>\n</ul>\n<h3 id=\"less\"><a class=\"markdownIt-Anchor\" href=\"#less\">#</a> less</h3>\n<p>一页一页翻动，以下实例输出 /etc/man.config 文件的内容：</p>\n<pre><code>[root@www ~]# less /etc/man.config\n#\n# Generated automatically from man.conf.in by the\n# configure script.\n#\n# man.conf from man-1.6d\n....(中间省略)....\n:   &lt;== 这里可以等待你输入命令！\n</code></pre>\n<p>less 运行时可以输入的命令有：</p>\n<ul>\n<li>空白键  ：向下翻动一页；</li>\n<li>[pagedown]：向下翻动一页；</li>\n<li>[pageup] ：向上翻动一页；</li>\n<li>/ 字串   ：向下搜寻『字串』的功能；</li>\n<li>? 字串   ：向上搜寻『字串』的功能；</li>\n<li>n     ：重复前一个搜寻 (与 / 或？有关！)</li>\n<li>N     ：反向的重复前一个搜寻 (与 / 或？有关！)</li>\n<li>q     ：离开 less 这个程序；</li>\n</ul>\n<h3 id=\"head\"><a class=\"markdownIt-Anchor\" href=\"#head\">#</a> head</h3>\n<p>取出文件前面几行</p>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">head</span> <span class=\"token punctuation\">[</span>-n number<span class=\"token punctuation\">]</span> 文件</pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>-n ：后面接数字，代表显示几行的意思</li>\n</ul>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># head /etc/man.config</span></pre></td></tr></table></figure><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># head -n 20 /etc/man.config</span></pre></td></tr></table></figure><h3 id=\"tail\"><a class=\"markdownIt-Anchor\" href=\"#tail\">#</a> tail</h3>\n<p>取出文件后面几行</p>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">tail</span> <span class=\"token punctuation\">[</span>-n number<span class=\"token punctuation\">]</span> 文件</pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>-n ：后面接数字，代表显示几行的意思</li>\n<li>-f ：表示持续侦测后面所接的档名，要等到按下 [ctrl]-c 才会结束 tail 的侦测</li>\n</ul>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># tail /etc/man.config</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># tail -n 20 /etc/man.config</span></pre></td></tr></table></figure><h1 id=\"linux-链接概念\"><a class=\"markdownIt-Anchor\" href=\"#linux-链接概念\">#</a> Linux 链接概念</h1>\n<p>Linux 链接分两种，一种被称为<strong>硬链接（Hard Link）</strong>，另一种被称为<strong>符号链接（Symbolic Link）</strong>。默认情况下，<strong>ln</strong> 命令产生硬链接。</p>\n<h2 id=\"硬连接\"><a class=\"markdownIt-Anchor\" href=\"#硬连接\">#</a> 硬连接</h2>\n<p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号 (Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p>\n<p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止 “误删” 的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>\n<h2 id=\"软连接\"><a class=\"markdownIt-Anchor\" href=\"#软连接\">#</a> 软连接</h2>\n<p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是 “主从” 关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p>\n<p><strong>通过实验加深理解</strong></p>\n<pre><code>[oracle@Linux]$ touch f1          #创建一个测试文件f1\n[oracle@Linux]$ ln f1 f2          #创建f1的一个硬连接文件f2\n[oracle@Linux]$ ln -s f1 f3       #创建f1的一个符号连接文件f3\n[oracle@Linux]$ ls -li            # -i参数显示文件的inode节点信息\ntotal 0\n9797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f1\n9797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f2\n9797649 lrwxrwxrwx  1 oracle oinstall 2 Apr 21 08:11 f3 -&gt; f1\n</code></pre>\n<p>从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 9797648，然而符号连接文件的 inode 节点不同。</p>\n<pre><code>[oracle@Linux]$ echo &quot;I am f1 file&quot; &gt;&gt;f1\n[oracle@Linux]$ cat f1\nI am f1 file\n[oracle@Linux]$ cat f2\nI am f1 file\n[oracle@Linux]$ cat f3\nI am f1 file\n[oracle@Linux]$ rm -f f1\n[oracle@Linux]$ cat f2\nI am f1 file\n[oracle@Linux]$ cat f3\ncat: f3: No such file or directory\n</code></pre>\n<p>通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f3 文件无效</p>\n<p><strong>总结</strong></p>\n<p>依此您可以做一些相关的测试，可以得到以下全部结论：</p>\n<ul>\n<li>1). 删除符号连接 f3, 对 f1,f2 无影响；</li>\n<li>2). 删除硬连接 f2，对 f1,f3 也无影响；</li>\n<li>3). 删除原文件 f1，对硬连接 f2 没有影响，导致符号连接 f3 失效；</li>\n<li>4). 同时删除原文件 f1, 硬连接 f2，整个文件会真正的被删除。</li>\n</ul>\n<h1 id=\"linux-用户和用户组管理\"><a class=\"markdownIt-Anchor\" href=\"#linux-用户和用户组管理\">#</a> Linux 用户和用户组管理</h1>\n<p>Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>\n<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>\n<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>\n<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p>\n<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>\n<ul>\n<li>用户账号的添加、删除与修改。</li>\n<li>用户口令的管理。</li>\n<li>用户组的管理。</li>\n</ul>\n<h1 id=\"linux-压缩命令\"><a class=\"markdownIt-Anchor\" href=\"#linux-压缩命令\">#</a> Linux 压缩命令</h1>\n<h1 id=\"linux-查找命令\"><a class=\"markdownIt-Anchor\" href=\"#linux-查找命令\">#</a> Linux 查找命令</h1>\n<h1 id=\"linux-磁盘管理\"><a class=\"markdownIt-Anchor\" href=\"#linux-磁盘管理\">#</a> Linux 磁盘管理</h1>\n<p>Linux 磁盘管理好坏直接关系到整个系统的性能问题。</p>\n<p>Linux 磁盘管理常用三个命令为  <code>df</code> 、 <code>du</code>  和  <code>fdisk</code> 。</p>\n<ul>\n<li><code>df</code> （英文全称：disk free）：列出文件系统的整体磁盘使用量</li>\n<li><code>du</code> （英文全称：disk used）：检查磁盘空间使用量</li>\n<li><code>fdisk</code> ：用于磁盘分区</li>\n</ul>\n<h2 id=\"df\"><a class=\"markdownIt-Anchor\" href=\"#df\">#</a> df</h2>\n<p>df 命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">df</span> <span class=\"token punctuation\">[</span>-ahikHTm<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>目录或文件名<span class=\"token punctuation\">]</span></pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li><code>-a</code>  ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；</li>\n<li><code>-k</code>  ：以 KBytes 的容量显示各文件系统；</li>\n<li><code>-m</code>  ：以 MBytes 的容量显示各文件系统；</li>\n<li><code>-h</code>  ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li>\n<li><code>-H</code>  ：以 M=1000K 取代 M=1024K 的进位方式；</li>\n<li><code>-T</code>  ：显示文件系统类型，连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li>\n<li><code>-i</code>  ：不用硬盘容量，而以 inode 的数量来显示</li>\n</ul>\n<h2 id=\"du\"><a class=\"markdownIt-Anchor\" href=\"#du\">#</a> du</h2>\n<p>Linux du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看，还是和 df 命令有一些区别的，这里介绍 Linux du 命令。</p>\n<p>语法：</p>\n<pre><code>du [-ahskm] 文件或目录名称\n</code></pre>\n<p>选项与参数：</p>\n<ul>\n<li><code>-a</code>  ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li>\n<li><code>-h</code>  ：以人们较易读的容量格式 (G/M) 显示；</li>\n<li><code>-s</code>  ：列出总量而已，而不列出每个各别的目录占用容量；</li>\n<li><code>-S</code>  ：不包括子目录下的总计，与 -s 有点差别。</li>\n<li><code>-k</code>  ：以 KBytes 列出容量显示；</li>\n<li><code>-m</code>  ：以 MBytes 列出容量显示；</li>\n</ul>\n<h2 id=\"fdisk\"><a class=\"markdownIt-Anchor\" href=\"#fdisk\">#</a> fdisk</h2>\n<p>fdisk 是 Linux 的磁盘分区表操作工具。</p>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">fdisk</span> <span class=\"token punctuation\">[</span>-l<span class=\"token punctuation\">]</span> 装置名称</pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li><code>-l</code>  ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。</li>\n</ul>\n<h1 id=\"linux-vivim\"><a class=\"markdownIt-Anchor\" href=\"#linux-vivim\">#</a> Linux vi/vim</h1>\n<p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p>\n<p>但是目前我们使用比较多的是 vim 编辑器。</p>\n<p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p>\n<h2 id=\"什么是-vim\"><a class=\"markdownIt-Anchor\" href=\"#什么是-vim\">#</a> 什么是 vim？</h2>\n<p>Vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>\n<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p>\n<p>连 vim 的官方网站 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmltLm9yZy8=\">https://www.vim.org/</span>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p>\n<p><img data-src=\"vi-vim-cheat-sheet-sch.gif\" alt=\"img\"></p>\n<h2 id=\"vivim-的使用\"><a class=\"markdownIt-Anchor\" href=\"#vivim-的使用\">#</a> vi/vim 的使用</h2>\n<p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）<strong>和</strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是：</p>\n<h3 id=\"命令模式\"><a class=\"markdownIt-Anchor\" href=\"#命令模式\">#</a> 命令模式：</h3>\n<p>用户刚刚启动 vi/vim，便进入了命令模式。</p>\n<p>此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符。比如我们此时按下 i，并不会输入一个字符，i 被当作了一个命令。</p>\n<p>以下是常用的几个命令：</p>\n<ul>\n<li><code>i</code>  切换到输入模式，以输入字符。</li>\n<li><code>x</code>  删除当前光标所在处的字符。</li>\n<li><code>:</code>  切换到底线命令模式，以在最底一行输入命令。</li>\n</ul>\n<p>若想要编辑文本：启动 Vim，进入了命令模式，按下 i，切换到输入模式。</p>\n<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>\n<h3 id=\"输入模式\"><a class=\"markdownIt-Anchor\" href=\"#输入模式\">#</a> 输入模式</h3>\n<p>在命令模式下按下 i 就进入了输入模式。</p>\n<p>在输入模式中，可以使用以下按键：</p>\n<ul>\n<li><strong>字符按键以及 Shift 组合</strong>，输入字符</li>\n<li><strong>ENTER</strong>，回车键，换行</li>\n<li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li>\n<li><strong>DEL</strong>，删除键，删除光标后一个字符</li>\n<li><strong>方向键</strong>，在文本中移动光标</li>\n<li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首 / 行尾</li>\n<li><strong>Page Up</strong>/<strong>Page Down</strong>，上 / 下翻页</li>\n<li><strong>Insert</strong>，切换光标为输入 / 替换模式，光标将变成竖线 / 下划线</li>\n<li><strong>ESC</strong>，退出输入模式，切换到命令模式</li>\n</ul>\n<h3 id=\"底线命令模式\"><a class=\"markdownIt-Anchor\" href=\"#底线命令模式\">#</a> 底线命令模式</h3>\n<p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>\n<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>\n<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>\n<ul>\n<li><code>q</code>  退出程序</li>\n<li><code>w</code>  保存文件</li>\n</ul>\n<p>按 ESC 键可随时退出底线命令模式。</p>\n<p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>\n<p><img data-src=\"vim-vi-workmodel.png\" alt=\"img\"></p>\n<h2 id=\"vivim-使用实例\"><a class=\"markdownIt-Anchor\" href=\"#vivim-使用实例\">#</a> vi/vim 使用实例</h2>\n<p><strong>使用 vi/vim 进入一般模式</strong></p>\n<p>如果你想要使用 vi 来建立一个名为 runoob.txt 的文件时，你可以这样做：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ <span class=\"token function\">vim</span> runoob.txt</pre></td></tr></table></figure><p>直接输入 <strong>vi 文件名</strong> 就能够进入 vi 的一般模式了。请注意，记得 <strong>vi 后面一定要加文件名，不管该文件存在与否！</strong></p>\n<p><img data-src=\"078207F0-B204-4464-AAEF-982F45EDDAE9.jpg\" alt=\"img\"></p>\n<p><strong>按下 i 进入输入模式 (也称为编辑模式)，开始编辑文字</strong></p>\n<p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p>\n<p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p>\n<p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p>\n<p><img data-src=\"1C928383-471E-4AF1-A61E-9E2CCBD5A913.jpg\" alt=\"img\"></p>\n<p><strong>按下 ESC 按钮回到一般模式</strong></p>\n<p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p>\n<p><strong>在一般模式中按下 :wq 储存后离开 vi</strong></p>\n<p>OK，我们要存档了，存盘并离开的指令很简单，输入  <code>:wq</code>  即可保存离开！</p>\n<p><img data-src=\"B2FB5146-327C-4019-AC96-DD7A8EE7460C.jpg\" alt=\"img\"></p>\n<p>OK! 这样我们就成功创建了一个 runoob.txt 的文件。</p>\n<h1 id=\"gcc\"><a class=\"markdownIt-Anchor\" href=\"#gcc\">#</a> GCC</h1>\n<p><code>GCC</code>  是 Linux 下的编译工具集，是 GNU Compiler Collection 的缩写，包含 gcc、g++ 等编译器。这个工具集不仅包含编译器，还包含其他工具集，例如 ar、nm 等。</p>\n<p>GCC 工具集不仅能编译 C/C++ 语言，其他例如 Objective-C、Pascal、Fortran、Java、Ada 等语言均能进行编译。<strong>GCC 在可以根据不同的硬件平台进行编译，即能进行交叉编译</strong>，在 A 平台上编译 B 平台的程序，支持常见的 X86、ARM、PowerPC、mips 等，以及 Linux、Windows 等软件平台。</p>\n<h2 id=\"安装gcc\"><a class=\"markdownIt-Anchor\" href=\"#安装gcc\">#</a> 安装 GCC</h2>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 安装软件必须要有管理员权限</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># ubuntu</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>$ <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update   \t\t<span class=\"token comment\"># 更新本地的软件下载列表，得到最新的下载地址</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>$ <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> gcc g++\t<span class=\"token comment\"># 通过下载列表中提供的地址下载安装包，并安装</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\"># centos</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>$ <span class=\"token function\">sudo</span> yum update   \t\t<span class=\"token comment\"># 更新本地的软件下载列表，得到最新的下载地址</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>$ <span class=\"token function\">sudo</span> yum <span class=\"token function\">install</span> gcc g++\t<span class=\"token comment\"># 通过下载列表中提供的地址下载安装包，并安装</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\"># 查看 gcc 版本</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>$ gcc <span class=\"token parameter variable\">-v</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>$ gcc <span class=\"token parameter variable\">--version</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\"># 查看 g++ 版本</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>$ g++ <span class=\"token parameter variable\">-v</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>$ g++ <span class=\"token parameter variable\">--version</span></pre></td></tr></table></figure><h2 id=\"gcc工作流程\"><a class=\"markdownIt-Anchor\" href=\"#gcc工作流程\">#</a> gcc 工作流程</h2>\n<p>GCC 编译器对程序的编译下图所示，分为 4 个阶段：预处理（预编译）、编译和优化、汇编和链接。GCC 的编译器可以将这 4 个步骤合并成一个。 先介绍一个每个步骤都分别做了写什么事儿:</p>\n<ul>\n<li>\n<p>预处理：在这个阶段主要做了三件事：展开头文件 、宏替换 、去掉注释行</p>\n<p>这个阶段需要 GCC 调用预处理器来完成，最终得到的还是源文件，文本格式</p>\n</li>\n<li>\n<p>编译：这个阶段需要 GCC 调用编译器对文件进行编译，最终得到一个汇编文件</p>\n</li>\n<li>\n<p>汇编：这个阶段需要 GCC 调用汇编器对文件进行汇编，最终得到一个二进制文件</p>\n</li>\n<li>\n<p>链接：这个阶段需要 GCC 调用链接器对程序需要调用的库进行链接，最终得到一个可执行的二进制文件</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>文件名后缀</th>\n<th>说明</th>\n<th>gcc 参数<br/></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.c</td>\n<td>源文件</td>\n<td>无<br/></td>\n</tr>\n<tr>\n<td>.i</td>\n<td>预处理后的 C 文件</td>\n<td>-E<br/></td>\n</tr>\n<tr>\n<td>.s</td>\n<td>编译之后得到的汇编语言的源文件</td>\n<td>-S<br/></td>\n</tr>\n<tr>\n<td>.o</td>\n<td>汇编后得到的二进制文件</td>\n<td>-c</td>\n</tr>\n</tbody>\n</table>\n<p>在 Linux 下使用 GCC 编译器编译单个文件十分简单，直接使用 gcc 命令后面加上要编译的 C 语言的源文件，GCC 会自动生成文件名为 a.out 的可执行文件（也可以通过参数 -o 指定生成的文件名），也就是通过一个简单的命令上边提到的 4 个步骤就全部执行完毕了。但是如果想要单步执行也是没问题的， 示例如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>p</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 源文件名 test.c</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">int</span> array<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"array[%d] = %d\\n\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ol>\n<li>\n<p>对源文件进行预处理，需要使用的 gcc 参数为 -E</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 1. 预处理，-o 指定生成的文件名</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ gcc <span class=\"token parameter variable\">-E</span> test.c <span class=\"token parameter variable\">-o</span> test.i</pre></td></tr></table></figure></li>\n<li>\n<p>编译预处理之后的文件，需要使用的 gcc 参数为 -S</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 2. 编译，得到汇编文件</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ gcc <span class=\"token parameter variable\">-S</span> test.i <span class=\"token parameter variable\">-o</span> test.s</pre></td></tr></table></figure></li>\n<li>\n<p>对得到的汇编文件进行汇编，需要使用的 gcc 参数为 -c</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 3. 汇编</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ gcc <span class=\"token parameter variable\">-c</span> test.s <span class=\"token parameter variable\">-o</span> test.o</pre></td></tr></table></figure></li>\n<li>\n<p>将得到的二进制文件和标准库进制链接，得到可执行的二进制文件，不需要任何参数</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 4. 链接</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ gcc test.o <span class=\"token parameter variable\">-o</span> <span class=\"token builtin class-name\">test</span></pre></td></tr></table></figure></li>\n</ol>\n<p>在使用 gcc 编译程序的时候可以通过参数控制内部自动执行几个步骤:</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l </span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 参数 -c 是进行文件的汇编，汇编之前的两步会自动执行</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ gcc test.c <span class=\"token parameter variable\">-c</span> <span class=\"token parameter variable\">-o</span> app.o</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 该命令是直接进行链接生成可执行程序，链接之前的三步会自动执行</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>$ gcc test.c <span class=\"token parameter variable\">-o</span> app</pre></td></tr></table></figure><h2 id=\"gcc常用参数\"><a class=\"markdownIt-Anchor\" href=\"#gcc常用参数\">#</a> gcc 常用参数</h2>\n<p>下面的表格中列出了常用的一些  <code>gcc</code>  参数，这些<strong>参数在 gcc 命令中没有位置要求</strong>，只需要编译程序的时候将需要的参数指定出来即可。</p>\n<table>\n<thead>\n<tr>\n<th>gcc 编译选项</th>\n<th>选项的意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-E</td>\n<td>预处理指定的源文件，不进行编译</td>\n</tr>\n<tr>\n<td>-S</td>\n<td>编译指定的源文件，但是不进行汇编</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>编译、汇编指定的源文件，但是不进行链接</td>\n</tr>\n<tr>\n<td>-o [file1] [file2] / [file2] -o [file1]</td>\n<td>将文件 file2 编译成文件 file1</td>\n</tr>\n<tr>\n<td>-I directory</td>\n<td>指定 include 包含文件的搜索目录</td>\n</tr>\n<tr>\n<td>-g</td>\n<td>在编译的时候，生成调试信息，该程序可以被调试器调试</td>\n</tr>\n<tr>\n<td>-D</td>\n<td>在程序编译的时候，指定一个宏</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>不生成任何警告信息，不建议使用，有些时候警告就是错误</td>\n</tr>\n<tr>\n<td>-Wall</td>\n<td>生成所有警告信息</td>\n</tr>\n<tr>\n<td>-On</td>\n<td>n 的取值范围：0~3。编译器的优化选项的 4 个级别，-O0 表示没有优化，-O1 为缺省值，-O3 优化级别最高</td>\n</tr>\n<tr>\n<td>-l</td>\n<td>在程序编译的时候，指定使用的库</td>\n</tr>\n<tr>\n<td>-L</td>\n<td>指定编译的时候，搜索的库的路径。</td>\n</tr>\n<tr>\n<td>-fPIC/fpic</td>\n<td>生成与位置无关的代码</td>\n</tr>\n<tr>\n<td>-shared</td>\n<td>生成共享目标文件。通常用在建立共享库时</td>\n</tr>\n<tr>\n<td>-std</td>\n<td>指定 C 方言，如:-std=c99，gcc 默认的方言是 GNU C</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>指定生成的文件名 (-o)</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 参数 -o 的用法，原材料 test.c 最终生成的文件名为 app</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># test.c 写在 -o 之前</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>$ gcc test.c <span class=\"token parameter variable\">-o</span> app</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># test.c 写在 -o 之后</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>$ gcc <span class=\"token parameter variable\">-o</span> app test.c</pre></td></tr></table></figure></li>\n<li>\n<p>搜索头文件 (-I)</p>\n<p>如果在程序中包含了一些头文件，但是包含的一些头文件在程序预处理的时候因为找不到无法被展开，导致程序编译失败，这时候我们可以在 gcc 命令中添加 -I 参数重新指定要引用的头文件路径，保证编译顺利完成。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># -I, 指定头文件目录</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ tree</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token builtin class-name\">.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>├── add.c</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>├── div.c</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>├── include</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>│   └── head.h</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>├── main.c</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>├── mult.c</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>└── sub.c</pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\"># 编译当前目录中的所有源文件，得到可执行程序</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>$ gcc *.c <span class=\"token parameter variable\">-o</span> calc</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>main.c:2:18: fatal error: head.h: No such <span class=\"token function\">file</span> or directory</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>compilation terminated.</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>sub.c:2:18: fatal error: head.h: No such <span class=\"token function\">file</span> or directory</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>compilation terminated.</pre></td></tr></table></figure><p>通过编译得到的错误信息可以知道，源文件中包含的头文件无法被找到。通过提供的目录结构可以得知头文件 head.h 在 include 目录中，因此可以在编译的时候重新指定头文件位置，具体操作如下：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 可以在编译的时候重新指定头文件位置 -I 头文件目录</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ gcc *.c <span class=\"token parameter variable\">-o</span> calc <span class=\"token parameter variable\">-I</span> ./include</pre></td></tr></table></figure></li>\n<li>\n<p>指定一个宏 (-D)</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 在编译命令中定义这个 DEBUG 宏，</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ gcc test.c <span class=\"token parameter variable\">-o</span> app <span class=\"token parameter variable\">-D</span> DEBUG</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 执行生成的程序， 可以看到程序第 9 行的输出</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>$ ./app </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>我是一个程序猿, 我不会爬树<span class=\"token punctuation\">..</span>.</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>hello, GCC<span class=\"token operator\">!</span><span class=\"token operator\">!</span><span class=\"token operator\">!</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>hello, GCC<span class=\"token operator\">!</span><span class=\"token operator\">!</span><span class=\"token operator\">!</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>hello, GCC<span class=\"token operator\">!</span><span class=\"token operator\">!</span><span class=\"token operator\">!</span></pre></td></tr></table></figure><blockquote>\n<p>-D 参数的应用场景:<br>\n 在发布程序的时候，一般都会要求将程序中所有的 log 输出去掉，如果不去掉会影响程序的执行效率，很显然删除这些打印 log 的源代码是一件很麻烦的事情，解决方案是这样的：</p>\n<p>将所有的打印 log 的代码都写到一个宏判定中，可以模仿上边的例子<br>\n在编译程序的时候指定 -D 就会有 log 输出<br>\n在编译程序的时候不指定 -D, log 就不会输出</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"多文件编译\"><a class=\"markdownIt-Anchor\" href=\"#多文件编译\">#</a> 多文件编译</h2>\n<p>GCC 可以自动编译链接多个文件，不管是目标文件还是源文件，都可以使用同一个命令编译到一个可执行文件中。</p>\n<ul>\n<li>\n<p>头文件</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifndef</span> <span class=\"token expression\">_STRING_H_</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">_STRING_H_</span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">strLength</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>string<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span> <span class=\"token comment\">// _STRING_H_</span></span></pre></td></tr></table></figure></li>\n<li>\n<p>源文件 string.c</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"string.h\"</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">strLength</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>string<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>string<span class=\"token operator\">++</span> <span class=\"token operator\">!=</span> <span class=\"token char\">'\\0'</span><span class=\"token punctuation\">)</span> \t<span class=\"token comment\">// 当 * string 的值为 '\\0' 时，停止计算</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        len<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token keyword\">return</span> len<span class=\"token punctuation\">;</span> \t<span class=\"token comment\">// 返回字符串长度</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n<li>\n<p>源文件 main.c</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"string.h\"</span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>src <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello, I'am Monkey·D·Luffy!!!\"</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"string length is: %d\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">strLength</span><span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n</ul>\n<blockquote>\n<p>因为头文件是包含在源文件中的，因此在使用 gcc 编译程序的时候不需要指定头文件的名字（在头文件无法被找到的时候需要使用参数 -I 指定其具体路径而不是名字）。我们可以通过一个 gcc 命令将多个源文件编译并生成可执行程序，也可以分多步完成这个操作。</p>\n</blockquote>\n<p>直接链接生成可执行程序</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 直接生成可执行程序 test</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ gcc <span class=\"token parameter variable\">-o</span> <span class=\"token builtin class-name\">test</span> string.c main.c</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 运行可执行程序</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>$ ./test</pre></td></tr></table></figure><p>先将源文件编成目标文件，然后进行链接得到可执行程序</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 汇编生成二进制目标文件，指定了 -c 参数之后，源文件会自动生成 string.o 和 main.o</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ gcc –c string.c main.c</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 链接目标文件，生成可执行程序 test</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>$ gcc –o <span class=\"token builtin class-name\">test</span> string.o main.o</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 运行可执行程序</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>$ ./test</pre></td></tr></table></figure><h2 id=\"gcc和g\"><a class=\"markdownIt-Anchor\" href=\"#gcc和g\">#</a> gcc 和 g++</h2>\n<ol>\n<li>在代码编译阶段（第二个阶段）:\n<ul>\n<li>后缀为  <code>.c</code>  的，gcc 把它当作是 C 程序，而 g++ 当作是 C++ 程序</li>\n<li>后缀为 <code>.cpp</code>  的，两者都会认为是 C++ 程序，C++ 的语法规则更加严谨一些</li>\n<li>g++ 会调用 gcc，对于 C++ 代码，两者是等价的，也就是说 gcc 和 g++ 都可以编译 C/C++ 代码</li>\n</ul>\n</li>\n<li>在链接阶段（最后一个阶段）:\n<ul>\n<li>gcc 和 g++ 都可以自动链接到标准 C 库</li>\n<li>g++ 可以自动链接到标准 C++ 库，gcc 如果要链接到标准 C++ 库需要加参数  <code>-lstdc++</code></li>\n</ul>\n</li>\n<li>关于  <code>__cplusplus</code>  宏的定义\n<ul>\n<li>g++ 会自动定义 <code>__cplusplus</code>  宏，但是这个不影响它去编译 C 程序</li>\n<li>gcc 需要根据文件后缀判断是否需要定义  <code>__cplusplus</code>  宏 （规则参考第一条）</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>综上所述：</p>\n<ul>\n<li>不管是 gcc 还是 g++ 都可以编译 C 程序，编译程序的规则和参数都相同</li>\n<li>g++ 可以直接编译 C++ 程序， gcc 编译 C++ 程序需要添加额外参数 -lstdc++</li>\n<li>不管是 gcc 还是 g++ 都可以定义 __cplusplus 宏</li>\n</ul>\n</blockquote>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 编译 c 程序</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ gcc test.c <span class=\"token parameter variable\">-o</span> <span class=\"token builtin class-name\">test</span>\t<span class=\"token comment\"># 使用 gcc</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>$ g++ test.c <span class=\"token parameter variable\">-o</span> <span class=\"token builtin class-name\">test</span>\t<span class=\"token comment\"># 使用 g++</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># 编译 c++ 程序</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>$ g++ test.cpp <span class=\"token parameter variable\">-o</span> <span class=\"token builtin class-name\">test</span>              <span class=\"token comment\"># 使用 g++</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>$ gcc test.cpp -lstdc++ <span class=\"token parameter variable\">-o</span> <span class=\"token builtin class-name\">test</span>     <span class=\"token comment\"># 使用 gcc</span></pre></td></tr></table></figure><h1 id=\"gdb调试\"><a class=\"markdownIt-Anchor\" href=\"#gdb调试\">#</a> GDB 调试</h1>\n<p>gdb 是由 GNU 软件系统社区提供的调试器，同 gcc 配套组成了一套完整的开发环境，可移植性很好，支持非常多的体系结构并被移植到各种系统中（包括各种类 Unix 系统与 Windows 系统里的 MinGW 和 Cygwin ）。此外，除了 C 语言之外，gcc/gdb 还支持包括 C++、Objective-C、Ada 和 Pascal 等各种语言后端的编译和调试。 gcc/gdb 是 Linux 和许多类 Unix 系统中的标准开发环境，Linux 内核也是专门针对 gcc 进行编码的。</p>\n<p><strong>GDB 是一套字符界面的程序集，可以使用命令 gdb 加载要调试的程序。</strong> 一些常用的 GDB 调试命令：</p>\n<h2 id=\"调试准备\"><a class=\"markdownIt-Anchor\" href=\"#调试准备\">#</a> 调试准备</h2>\n<p>项目程序如果是为了进行调试而编译时， 必须要打开调试选项  <code>-g</code>  另外还有一些可选项，比如：在尽量不影响程序行为的情况下关掉编译器的优化选项  <code>-O0</code> ， <code>-Wall</code>  选项打开所有 warning，也可以发现许多问题，避免一些不必要的 bug。</p>\n<p><code>-g</code>  选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 gdb 能找到源文件。</p>\n<p>习惯上如果是 c 程序就使用 gcc 编译，如果是 c++ 程序就使用 g++ 编译，编译命令中添加上边提到的参数即可。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># -g 将调试信息写入到可执行程序中</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ gcc <span class=\"token parameter variable\">-g</span> args.c <span class=\"token parameter variable\">-o</span> app</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 编译不添加 -g 参数</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>$ gcc args.c <span class=\"token parameter variable\">-o</span> app1  </pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 查看生成的两个可执行程序的大小</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>$ ll</pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>-rwxrwxr-x  <span class=\"token number\">1</span> robin robin <span class=\"token number\">9816</span> Apr <span class=\"token number\">19</span> 09:25 app*\t<span class=\"token comment\"># 可以用于 gdb 调试</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>-rwxrwxr-x  <span class=\"token number\">1</span> robin robin <span class=\"token number\">8608</span> Apr <span class=\"token number\">19</span> 09:25 app1*\t<span class=\"token comment\"># 不能用于 gdb 调试</span></pre></td></tr></table></figure><h2 id=\"启动和退出gdb\"><a class=\"markdownIt-Anchor\" href=\"#启动和退出gdb\">#</a> 启动和退出 gdb</h2>\n<h3 id=\"启动gdb\"><a class=\"markdownIt-Anchor\" href=\"#启动gdb\">#</a> 启动 gdb</h3>\n<p>gdb 是一个用于应用程序调试的进程，需要先将其打开，一定要注意 gdb 进程启动之后，需要的被调试的应用程序是没有执行的。打开 Linux 终端，切换到要调试的可执行程序所在路径，执行如下命令就可以启动 gdb 了。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 在终端中执行如下命令</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># gdb 程序启动了，但是可执行程序并没有执行</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>$ gdb 可执行程序的名字</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># 使用举例：</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>$ gdb app</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> \t\t<span class=\"token comment\"># gdb 等待输入调试的相关命令</span></pre></td></tr></table></figure><h3 id=\"命令行传参\"><a class=\"markdownIt-Anchor\" href=\"#命令行传参\">#</a> 命令行传参</h3>\n<p>有些程序在启动的时候需要传递命令行参数，如果要调试这类程序，这些命令行参数必须要在应用程序启动之前通过调试程序的 gdb 进程传递进去。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// args.c</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">NUM</span> <span class=\"token expression\"><span class=\"token number\">10</span></span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">//argc, argv 是命令行参数</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// 启动应用程序的时候</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"参数个数: %d\\n\"</span><span class=\"token punctuation\">,</span> argc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>argc<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> NUM<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"参数 %d: %s\\n\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> argv<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ol>\n<li>\n<p>编译出可执行程序</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ gcc args.c <span class=\"token parameter variable\">-o</span> app <span class=\"token parameter variable\">-g</span></pre></td></tr></table></figure></li>\n<li>\n<p>启动 gdb 进程，指定需要 gdb 调试的应用程序名称</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ gdb app</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span></pre></td></tr></table></figure></li>\n<li>\n<p>在启动应用程序  <code>app</code>  之前设置命令行参数。</p>\n<p>gdb 中设置参数的命令叫做  <code>set args ...</code> ，查看设置的命令行参数命令是  <code>show args</code> 。 语法格式如下：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 设置的时机：启动 gdb 之后，在应用程序启动之前</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">set</span> args 参数1 参数2 <span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span> <span class=\"token punctuation\">..</span>.</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 查看设置的命令行参数</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> show args</pre></td></tr></table></figure></li>\n</ol>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l </span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 非 gdb 调试命令行传参</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># argc 参数总个数，argv [0] == ./app， argv [1] == \"11\"  argv [2] == \"22\"  ...  argv [5] == \"55\"</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>$ ./app <span class=\"token number\">11</span> <span class=\"token number\">22</span> <span class=\"token number\">33</span> <span class=\"token number\">44</span> <span class=\"token number\">55</span>\t\t<span class=\"token comment\"># 这是数据传递给 main 函数</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># 使用 gdb 调试</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>$ gdb app</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>GNU gdb <span class=\"token punctuation\">(</span>Ubuntu <span class=\"token number\">7.11</span>.1-0ubuntu1~16.5<span class=\"token punctuation\">)</span> <span class=\"token number\">7.11</span>.1</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>Copyright <span class=\"token punctuation\">(</span>C<span class=\"token punctuation\">)</span> <span class=\"token number\">2016</span> Free Software Foundation, Inc.</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\"># 通过 gdb 给应用程序设置命令行参数</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">set</span> args <span class=\"token number\">11</span> <span class=\"token number\">22</span> <span class=\"token number\">33</span> <span class=\"token number\">44</span> <span class=\"token number\">55</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\"># 查看设置的命令行参数</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> show args</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>Argument list to give program being debugged when it is started is <span class=\"token string\">\"11 22 33 44 55\"</span><span class=\"token builtin class-name\">.</span></pre></td></tr></table></figure><h3 id=\"gdb中启动程序\"><a class=\"markdownIt-Anchor\" href=\"#gdb中启动程序\">#</a> gdb 中启动程序</h3>\n<p>在 gdb 中启动要调试的应用程序有两种方式，一种是使用 run 命令，另一种是使用 start 命令启动。在整个 gdb 调试过程中，启动应用程序的命令只能使用一次。</p>\n<ul>\n<li><code>run</code> : 可以缩写为  <code>r</code> , 如果程序中设置了断点会停在第一个断点的位置，如果没有设置断点，程序就执行完了</li>\n<li><code>start</code> : 启动程序，最终会阻塞在 main 函数的第一行，等待输入后续其它 gdb 指令</li>\n<li><code>continue</code>  ：如果想让程序 start 之后继续运行，或者在断点处继续运行，可以使用  <code>continue</code>  命令，可以简写为  <code>c</code></li>\n</ul>\n<h3 id=\"退出gdb\"><a class=\"markdownIt-Anchor\" href=\"#退出gdb\">#</a> 退出 gdb</h3>\n<p>退出 gdb 调试，就是终止 gdb 进程，需要使用  <code>quit</code>  命令，可以缩写为  <code>q</code></p>\n<h2 id=\"查看代码\"><a class=\"markdownIt-Anchor\" href=\"#查看代码\">#</a> 查看代码</h2>\n<p>因为 gdb 调试没有 IDE 那样的完善的可视化窗口界面，给调试的程序打断点又是调试之前必须做的一项工作。因此 gdb 提供了查看代码的命令，这样就可以轻松定位要调试的代码行的位置了。</p>\n<p>查看代码的命令叫做  <code>list</code>  可以缩写为  <code>l</code> , 通过这个命令我们可以查看项目中任意一个文件中的内容，并且还可以通过文件行号，函数名等方式查看。</p>\n<h3 id=\"当前文件\"><a class=\"markdownIt-Anchor\" href=\"#当前文件\">#</a> 当前文件</h3>\n<p>一个项目中一般是有很多源文件的，默认情况下通过  <code>list</code>  查看到代码信息位于程序入口函数  <code>main</code>  对应的的那个文件中。因此如果不进行文件切换  <code>main</code>  函数所在的文件就是当前文件，如果进行了文件切换，切换到哪个文件哪个文件就是当前文件。查看文件内容的方式如下：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 使用 list 和使用 l 都可以</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 从第一行开始显示</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> list </pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># 列值这行号对应的上下文代码，默认情况下只显示 10 行内容</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> list 行号</pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\"># 显示这个函数的上下文内容，默认显示 10 行</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> list 函数名</pre></td></tr></table></figure><p>通过 list 去查看文件代码，默认只显示 10 行，如果还想继续查看后边的内容，可以继续执行 list 命令，也可以直接回车（再次执行上一次执行的那个 gdb 命令）</p>\n<h3 id=\"切换文件\"><a class=\"markdownIt-Anchor\" href=\"#切换文件\">#</a> 切换文件</h3>\n<p>在查看文件内容的时候，很多情况下需要进行文件切换，我们只需要在 list 命令后边将要查看的文件名指定出来就可以了，切换命令执行完毕之后，这个文件就变成了当前文件。文件切换方式如下：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 切换到指定的文件，并列出这行号对应的上下文代码，默认情况下只显示 10 行内容</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> l 文件名:行号</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 切换到指定的文件，并显示这个函数的上下文内容，默认显示 10 行</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> l 文件名:函数名</pre></td></tr></table></figure><h3 id=\"设置显示行数\"><a class=\"markdownIt-Anchor\" href=\"#设置显示行数\">#</a> 设置显示行数</h3>\n<p>默认通过 list 只能一次查看 10 行代码，如果想显示更多，可以通过 set listsize 设置，同样如果想查看当前显示的行数可以通过 show listsize 查看，这里的 listsize 可以简写为 list。具体语法格式如下:</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 以下两个命令中的 listsize 都可以写成 list</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">set</span> listsize 行数</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 查看当前 list 一次显示的行数</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> show listsize</pre></td></tr></table></figure><h2 id=\"断点操作\"><a class=\"markdownIt-Anchor\" href=\"#断点操作\">#</a> 断点操作</h2>\n<p>想要通过 gdb 调试某一行或者得到某个变量在运行状态下的实际值，就需要在在这一行设置断点，程序指定到断点的位置就会阻塞，我们就可以通过 gdb 的调试命令得到我们想要的信息了。</p>\n<p>设置断点的命令叫做  <code>break</code>  可以缩写为  <code>b</code> 。</p>\n<h3 id=\"设置断点\"><a class=\"markdownIt-Anchor\" href=\"#设置断点\">#</a> 设置断点</h3>\n<p>断点的设置有两种方式一种是<strong>常规断点</strong>，程序只要运行到这个位置就会被阻塞，还有一种叫<strong>条件断点</strong>，只有指定的条件被满足了程序才会在断点处阻塞。</p>\n<p>调试程序的断点可以设置到某个具体的行，也可以设置到某个函数上，具体的设置方式如下：</p>\n<ul>\n<li>\n<p>设置普通断点到当前文件</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 在当前文件的某一行上设置断点</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># break == b</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> b 行号</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> b 函数名\t\t<span class=\"token comment\"># 停止在函数的第一行</span></pre></td></tr></table></figure></li>\n<li>\n<p>设置普通断点到某个非当前文件上</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 在非当前文件的某一行上设置断点</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> b 文件名:行号</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> b 文件名:函数名\t\t<span class=\"token comment\"># 停止在函数的第一行</span></pre></td></tr></table></figure></li>\n<li>\n<p>设置条件断点</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 必须要满足某个条件，程序才会停在这个断点的位置上</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 通常情况下，在循环中条件断点用的比较多</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> b 行数 <span class=\"token keyword\">if</span> 变量名<span class=\"token operator\">==</span>某个值</pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"查看断点\"><a class=\"markdownIt-Anchor\" href=\"#查看断点\">#</a> 查看断点</h3>\n<p>断点设置完毕之后，可以通过  <code>info break</code>  命令查看设置的断点信息，其中  <code>info</code>  可以缩写为  <code>i</code></p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># info == i</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 查看设置的断点信息</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> i b   <span class=\"token comment\">#info break</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># 举例</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> i b</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>Num     Type           Disp Enb Address            What</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token number\">1</span>       breakpoint     keep y   0x0000000000400cb5 <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:12</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token number\">2</span>       breakpoint     keep y   0x0000000000400cbd <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:13</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token number\">3</span>       breakpoint     keep y   0x0000000000400cec <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:18</pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token number\">4</span>       breakpoint     keep y   0x00000000004009a5 <span class=\"token keyword\">in</span> insertionSort<span class=\"token punctuation\">(</span>int*, int<span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>                                                   at insert.cpp:8</pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token number\">5</span>       breakpoint     keep y   0x0000000000400cdd <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:16</pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token number\">6</span>       breakpoint     keep y   0x00000000004009e5 <span class=\"token keyword\">in</span> insertionSort<span class=\"token punctuation\">(</span>int*, int<span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"15\"></td><td><pre>                                                   at insert.cpp:16</pre></td></tr></table></figure><p>在显示的断点信息中有一些属性需要在其他操作中被使用，下面介绍一下:</p>\n<ul>\n<li><code>Num</code> : 断点的编号，删除断点或者设置断点状态的时候都需要使用</li>\n<li><code>Enb</code> : 当前断点的状态，y 表示断点可用，n 表示断点不可用</li>\n<li><code>What</code> : 描述断点被设置在了哪个文件的哪一行或者哪个函数上</li>\n</ul>\n<h3 id=\"删除断点\"><a class=\"markdownIt-Anchor\" href=\"#删除断点\">#</a> 删除断点</h3>\n<p>如果确定设置的某个断点不再被使用了，可用将其删除，删除命令是  <code>delete</code>  断点编号，这个  <code>delete</code>  可以简写为  <code>del</code>  也可以再简写为 <code>d</code> 。</p>\n<p>删除断点的方式有两种: <strong>删除 (一个或者多个) 指定断点</strong>或者<strong>删除一个连续的断点区间</strong>，具体操作如下：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># delete == del == d</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 需要 info b 查看断点的信息，第一列就是编号</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> d 断点的编号1 <span class=\"token punctuation\">[</span>断点编号2 <span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 举例: </span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> d <span class=\"token number\">1</span>          <span class=\"token comment\"># 删除第 1 个断点</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> d <span class=\"token number\">2</span> <span class=\"token number\">4</span> <span class=\"token number\">6</span>      <span class=\"token comment\"># 删除第 2,4,6 个断点</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\"># 删除一个范围，断点编号 num1 - numN 是一个连续区间</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> d num1-numN</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\"># 举例，删除第 1 到第 5 个断点</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> d <span class=\"token number\">1</span>-5</pre></td></tr></table></figure><h3 id=\"设置断点状态\"><a class=\"markdownIt-Anchor\" href=\"#设置断点状态\">#</a> 设置断点状态</h3>\n<p>如果某个断点只是临时不需要了，我们可以将其设置为不可用状态，设置命令为  <code>disable</code>  断点编号，当需要的时候再将其设置回可用状态，设置命令为  <code>enable</code>  断点编号。</p>\n<ul>\n<li>\n<p>设置断点无效</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 让断点失效之后，gdb 调试过程中程序是不会停在这个位置的</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># disable == dis</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 设置某一个或者某几个断点无效</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> dis 断点1的编号 <span class=\"token punctuation\">[</span>断点2的编号 <span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\"># 设置某个区间断点无效</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> dis 断点1编号-断点n编号</pre></td></tr></table></figure><p>演示设置断点为无效状态:</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 查看断点信息</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> i b</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Num     Type           Disp Enb Address            What</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">2</span>       breakpoint     keep y   0x0000000000400cce <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:14</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">4</span>       breakpoint     keep y   0x0000000000400cdd <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:16</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token number\">5</span>       breakpoint     keep y   0x0000000000400d46 <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:23</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">6</span>       breakpoint     keep y   0x0000000000400d4e <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:25</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token number\">7</span>       breakpoint     keep y   0x0000000000400d6e <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:28</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token number\">8</span>       breakpoint     keep y   0x0000000000400d7d <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:30</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\"># 设置第 2, 第 4 个断点无效</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> dis <span class=\"token number\">2</span> <span class=\"token number\">4</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\"># 查看断点信息</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> i b</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>Num     Type           Disp Enb Address            What</pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token number\">2</span>       breakpoint     keep n   0x0000000000400cce <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:14</pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token number\">4</span>       breakpoint     keep n   0x0000000000400cdd <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:16</pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token number\">5</span>       breakpoint     keep y   0x0000000000400d46 <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:23</pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token number\">6</span>       breakpoint     keep y   0x0000000000400d4e <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:25</pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token number\">7</span>       breakpoint     keep y   0x0000000000400d6e <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:28</pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token number\">8</span>       breakpoint     keep y   0x0000000000400d7d <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:30</pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token comment\"># 设置 第 5,6,7,8 个 断点无效</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> dis <span class=\"token number\">5</span>-8</pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token comment\"># 查看断点信息</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> i b</pre></td></tr><tr><td data-num=\"29\"></td><td><pre>Num     Type           Disp Enb Address            What</pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token number\">2</span>       breakpoint     keep n   0x0000000000400cce <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:14</pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token number\">4</span>       breakpoint     keep n   0x0000000000400cdd <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:16</pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token number\">5</span>       breakpoint     keep n   0x0000000000400d46 <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:23</pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token number\">6</span>       breakpoint     keep n   0x0000000000400d4e <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:25</pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token number\">7</span>       breakpoint     keep n   0x0000000000400d6e <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:28</pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token number\">8</span>       breakpoint     keep n   0x0000000000400d7d <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:30</pre></td></tr></table></figure></li>\n<li>\n<p>让无效的断点生效</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># enable == ena</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 设置某一个或者某几个断点有效</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> ena 断点1的编号 <span class=\"token punctuation\">[</span>断点2的编号 <span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># 设置某个区间断点有效</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> ena 断点1编号-断点n编号</pre></td></tr></table></figure><p>演示设置断点为有效状态:</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 查看断点信息</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> i b</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Num     Type           Disp Enb Address            What</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">2</span>       breakpoint     keep n   0x0000000000400cce <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:14</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">4</span>       breakpoint     keep n   0x0000000000400cdd <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:16</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token number\">5</span>       breakpoint     keep n   0x0000000000400d46 <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:23</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">6</span>       breakpoint     keep n   0x0000000000400d4e <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:25</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token number\">7</span>       breakpoint     keep n   0x0000000000400d6e <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:28</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token number\">8</span>       breakpoint     keep n   0x0000000000400d7d <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:30</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\"># 设置第 2, 第 4 个断点有效</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> ena <span class=\"token number\">2</span> <span class=\"token number\">4</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\"># 查看断点信息</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> i b</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>Num     Type           Disp Enb Address            What</pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token number\">2</span>       breakpoint     keep y   0x0000000000400cce <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:14</pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token number\">4</span>       breakpoint     keep y   0x0000000000400cdd <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:16</pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token number\">5</span>       breakpoint     keep n   0x0000000000400d46 <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:23</pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token number\">6</span>       breakpoint     keep n   0x0000000000400d4e <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:25</pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token number\">7</span>       breakpoint     keep n   0x0000000000400d6e <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:28</pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token number\">8</span>       breakpoint     keep n   0x0000000000400d7d <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:30</pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token comment\"># 设置第 5,6,7 个断点有效</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> ena <span class=\"token number\">5</span>-7</pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token comment\"># 查看断点信息</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> i b</pre></td></tr><tr><td data-num=\"29\"></td><td><pre>Num     Type           Disp Enb Address            What</pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token number\">2</span>       breakpoint     keep y   0x0000000000400cce <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:14</pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token number\">4</span>       breakpoint     keep y   0x0000000000400cdd <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:16</pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token number\">5</span>       breakpoint     keep y   0x0000000000400d46 <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:23</pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token number\">6</span>       breakpoint     keep y   0x0000000000400d4e <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:25</pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token number\">7</span>       breakpoint     keep y   0x0000000000400d6e <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:28</pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token number\">8</span>       breakpoint     keep n   0x0000000000400d7d <span class=\"token keyword\">in</span> main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> at test.cpp:30</pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"调试命令\"><a class=\"markdownIt-Anchor\" href=\"#调试命令\">#</a> 调试命令</h2>\n<h3 id=\"继续运行-gdb\"><a class=\"markdownIt-Anchor\" href=\"#继续运行-gdb\">#</a> 继续运行 gdb</h3>\n<p>如果调试的程序被断点阻塞了又想让程序继续执行，这时候就可以使用  <code>continue</code>  命令。程序会继续运行，直到遇到下一个有效的断点。 <code>continue</code>  可以缩写为  <code>c</code> 。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># continue == c</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">continue</span></pre></td></tr></table></figure><h3 id=\"手动打印信息\"><a class=\"markdownIt-Anchor\" href=\"#手动打印信息\">#</a> 手动打印信息</h3>\n<p>当程序被某个断点阻塞之后，可以通过一些命令打印变量的名字或者变量的类型，并且还可以跟踪打印某个变量的值。</p>\n<ol>\n<li>\n<p>打印变量值</p>\n<p>在 gdb 调试的时候如果需要打印变量的值， 使用的命令是  <code>print</code> , 可缩写为  <code>p</code> 。如果打印的变量是整数还可以指定输出的整数的格式，格式化输出的整数对应的字符表如下：</p>\n<table>\n<thead>\n<tr>\n<th>格式化字符 (/fmt)</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/x</td>\n<td>以十六进制的形式打印出整数。</td>\n</tr>\n<tr>\n<td>/d</td>\n<td>以有符号、十进制的形式打印出整数。</td>\n</tr>\n<tr>\n<td>/u</td>\n<td>以无符号、十进制的形式打印出整数。</td>\n</tr>\n<tr>\n<td>/o</td>\n<td>以八进制的形式打印出整数。</td>\n</tr>\n<tr>\n<td>/t</td>\n<td>以二进制的形式打印出整数。</td>\n</tr>\n<tr>\n<td>/f</td>\n<td>以浮点数的形式打印变量或表达式的值。</td>\n</tr>\n<tr>\n<td>/c</td>\n<td>以字符形式打印变量或表达式的值。</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 举例</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> p i       <span class=\"token comment\"># 10 进制</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token variable\">$5</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> p/x i     <span class=\"token comment\"># 16 进制</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token variable\">$6</span> <span class=\"token operator\">=</span> 0x3</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> p/o i     <span class=\"token comment\"># 8 进制</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token variable\">$7</span> <span class=\"token operator\">=</span> 03</pre></td></tr></table></figure></li>\n<li>\n<p>打印变量类型</p>\n<p>如果在调试过程中需要查看某个变量的类型，可以使用命令  <code>ptype</code></p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 打印变量类型</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> ptype i</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token builtin class-name\">type</span> <span class=\"token operator\">=</span> int</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> ptype array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token builtin class-name\">type</span> <span class=\"token operator\">=</span> int</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> ptype array</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token builtin class-name\">type</span> <span class=\"token operator\">=</span> int <span class=\"token punctuation\">[</span><span class=\"token number\">12</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"自动打印信息\"><a class=\"markdownIt-Anchor\" href=\"#自动打印信息\">#</a> 自动打印信息</h3>\n<ol>\n<li>\n<p>设置变量名自动显示</p>\n<p>和 print 命令一样，display 命令也用于调试阶段查看某个变量或表达式的值，它们的区别是，使用 display 命令查看变量或表达式的值，每当程序暂停执行（例如单步执行）时，GDB 调试器都会自动帮我们打印出来，而 print 命令则不会。因此，当我们想频繁查看某个变量或表达式的值从而观察它的变化情况时，使用 display 命令可以一劳永逸。display 命令没有缩写形式，常用的语法格式如下 2 种：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 在变量的有效取值范围内，自动打印变量的值 (设置一次，以后就会自动显示)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> display 变量名</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 以指定的整形格式打印变量的值，关于 fmt 的取值，请参考 print 命令</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> display/fmt 变量名</pre></td></tr></table></figure></li>\n<li>\n<p>查看自动显示列表</p>\n<p>对于使用 display 命令查看的目标变量或表达式，都会被记录在一张列表（称为自动显示列表）中。通过执行 info dispaly 命令，可以打印出这张表：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># info == i</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> info display</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Auto-display expressions now <span class=\"token keyword\">in</span> effect:</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>Num Enb Expression</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">1</span>:   y  i</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token number\">2</span>:   y  array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">3</span>:   y  /x array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span></pre></td></tr></table></figure><p>在展示出的信息中，每个列的含义如下:</p>\n<ul>\n<li>Num : 变量或表达式的编号，GDB 调试器为每个变量或表达式都分配有唯一的编号</li>\n<li>Enb : 表示当前变量（表达式）是处于激活状态还是禁用状态，如果处于激活状态（用 y 表示），则每次程序停止执行，该变量的值都会被打印出来；反之，如果处于禁用状态（用 n 表示），则该变量（表达式）的值不会被打印。</li>\n<li>Expression ：被自动打印值的变量或表达式的名字。</li>\n</ul>\n</li>\n<li>\n<p>取消自动显示</p>\n<p>对于不需要再打印值的变量或表达式，可以将其删除或者禁用。</p>\n<ul>\n<li>\n<p>删除自动显示列表中的变量或表达式</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 命令中的 num 是通过 info display 得到的编号，编号可以是一个或者多个</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> undisplay num <span class=\"token punctuation\">[</span>num1 <span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># num1 - numN 表示一个范围</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> undisplay num1-numN</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> delete display num <span class=\"token punctuation\">[</span>num1 <span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> delete display num1-numN</pre></td></tr></table></figure><p>举例说明:</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 查看显示列表</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> info display</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Auto-display expressions now <span class=\"token keyword\">in</span> effect:</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>Num Enb Expression</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">1</span>:   y  i</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token number\">2</span>:   y  array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">3</span>:   y  /x array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\"># 删除变量显示，需要使用 info display 得到的变量 / 表达式编号</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> undisplay <span class=\"token number\">1</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\"># 查看显示列表，只剩下一个了</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> i display</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>Auto-display expressions now <span class=\"token keyword\">in</span> effect:</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>Num Enb Expression</pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token number\">3</span>:   y  /x array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span></pre></td></tr></table></figure></li>\n<li>\n<p>如果不想删除自动显示的变量，也可以禁用自动显示列表中处于激活状态下的变量或表达式</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 命令中的 num 是通过 info display 得到的编号，编号可以是一个或者多个</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> disable display num <span class=\"token punctuation\">[</span>num1 <span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># num1 - numN 表示一个范围</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> disable display num1-numN</pre></td></tr></table></figure></li>\n<li>\n<p>当需要启用自动显示列表中被禁用的变量或表达式时，可以使用下边的命令</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 命令中的 num 是通过 info display 得到的编号，编号可以是一个或者多个</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">enable</span>  display num <span class=\"token punctuation\">[</span>num1 <span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># num1 - numN 表示一个范围</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> disable display num1-numN</pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"单步调试\"><a class=\"markdownIt-Anchor\" href=\"#单步调试\">#</a> 单步调试</h3>\n<p>当程序阻塞到某个断点上之后，可以通过以下命令对程序进行单步调试:</p>\n<ul>\n<li>\n<p><code>step</code></p>\n<p><code>step</code>  命令可以缩写为  <code>s</code> , 命令被执行一次代码被向下执行一行，如果这一行是一个函数调用，那么程序会进入到函数体内部。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 从当前代码行位置，一次调试当前行下的每一行代码</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># step == s</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 如果这一行是函数调用，执行这个命令，就可以进入到函数体的内部</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> step</pre></td></tr></table></figure></li>\n<li>\n<p>finish</p>\n<p>如果通过  <code>s</code>  单步调试进入到函数内部，想要跳出这个函数体， 可以执行  <code>finish</code>  命令。如果想要跳出函数体必须要保证函数体内不能有有效断点，否则无法跳出。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 如果通过 s 单步调试进入到函数内部，想要跳出这个函数体</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> finish</pre></td></tr></table></figure></li>\n<li>\n<p>next</p>\n<p><code>next</code>  命令和  <code>step</code>  命令功能是相似的，只是在使用  <code>next</code>  调试程序的时候不会进入到函数体内部， <code>next</code>  可以缩写为  <code>n</code></p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># next == n</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 如果这一行是函数调用，执行这个命令，不会进入到函数体的内部</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> next</pre></td></tr></table></figure></li>\n<li>\n<p>until</p>\n<p>通过 until 命令可以直接跳出某个循环体，这样就能提高调试效率了。如果想直接从循环体中跳出，必须要满足以下的条件，否则命令不会生效：</p>\n<ol>\n<li>要跳出的循环体内部不能有有效的断点</li>\n<li>必须要在循环体的开始 / 结束行执行该命令</li>\n</ol>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> <span class=\"token keyword\">until</span></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"设置变量值\"><a class=\"markdownIt-Anchor\" href=\"#设置变量值\">#</a> 设置变量值</h3>\n<p>在调试程序的时候，我们需要在某个变量等于某个特殊值的时候查看程序的运行状态，但是通过程序运行让变量等于这个值又非常困难，这种情况下就可以在 gdb 中直接对这个变量进行值的设置，或者是在单步调试的时候通过设置循环因子的值直接跳出某个循环，值设置的命令格式为:  <code>set var 变量名=值</code></p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"><span>l</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 可以在循环中使用，直接设置循环因子的值</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 假设某个变量的值在程序中 ==90 的概率是 5%, 这时候可以直接通过命令将这个变量值设置为 90</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">set</span> var 变量名<span class=\"token operator\">=</span>值</pre></td></tr></table></figure>",
            "tags": [
                "Linux"
            ]
        }
    ]
}