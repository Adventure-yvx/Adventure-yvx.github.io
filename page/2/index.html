
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>Adventure</title>
        <meta name="author" content="AdventureYX" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>ADVENTURE</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" @click="shouMenuItems = !shouMenuItems" v-show="shouMenuItems"></div>
        <div class="title" @click="shouMenuItems = !shouMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ADVENTURE</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="shouMenuItems">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

            <transition name="into">
            <div id="main" v-show="!loading">
                <div id="home-head">
    <div
        id="home-background"
        ref="homeBackground"
        data-images="/images/background.jpg"
    ></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Adventure</h1>
                <h3>心有所向。日复一日，必有精进</h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div id="home-posts-wrap"  ref="homePostsWrap">
    <div id="home-posts">
        

<div class="post">
    <a href="/2023/02/24/C++Study/">
        <h2 class="post-title">C++ Study</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/C/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                C++
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/2/24
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="Welcome-to-C"><a href="#Welcome-to-C" class="headerlink" title="Welcome to C++"></a>Welcome to C++</h1><p>C++融合了3种不同的编程方式：</p>
<ul>
<li>C语言代表的过程性语言（procedural）</li>
<li>C++在C语言基础上添加的类代表的面向对象语言（OOP，Object Oriented Programming）</li>
<li>C++模板支持的泛型编程（generic programming）</li>
</ul>
<p><strong>IDE</strong> : Visual Studio</p>
<p><strong>解决方案&#x2F;solution</strong> : 一个包含多个相关project的集合，这些projects可以是不同类型的（dll,exe,lib等）。solution就是一个工作台，而每个项目就是文件的集合，然后被编译成某种目标二进制文件，无论是库(library)还是可执行文件(excutable)</p>
<p>使用<code>C++</code>的最大原因在于直接控制硬件。用<code>C++</code>写的代码，这些代码被送去编译器去编译，这些编译器将代码输出为目标平台的机器码。机器码是你的设备在CPU上实际执行的指令。使用C++我们完全可以控制CPU执行的每一条指令。</p>
<p><code>C#</code>和<code>JAVA</code>与<code>C++</code>不同，是因为它们运行在虚拟机上，这意味着代码首先被编译成一种中间语言，当在目标平台运行应用程序时，虚拟机在程序运行时再转换成机器码。</p>
<p><code>C++</code>是本地语言（native language）。比如x64编译器将输出x64机器代码，从而（也只能）在64位的CPU上运行。<code>C++</code>编译器为目标平台和架构生成机器码，编译后已经变成了平台上的机器语言，你只需要把机器代码指令放入CPU，CPU就会执行这些指令。</p>
<p>仅仅因为代码是本地的，并不意味着它会很快，垃圾代码甚至可能比虚拟机语言更慢比如C#或JAVA，因为它们倾向于运行时做系统优化。</p>
<h2 id="How-C-Works"><a href="#How-C-Works" class="headerlink" title="How C++ Works"></a>How C++ Works</h2><ol>
<li><p>预处理：展开头文件、宏替换、去掉注释。</p>
<p>需要文件：.cpp文件</p>
<p>生成产物：预处理文件(以.i结尾)</p>
</li>
<li><p>编译：检查语法，生成汇编代码。</p>
<p>需要文件：.i文件</p>
<p>生成产物：汇编文件(以.s结尾)</p>
</li>
<li><p>汇编：把汇编代码转换为二进制的机器码。</p>
<p>需要文件：.s文件</p>
<p>生成产物：机器码(或称为“目标代码”，以.obj结尾)</p>
</li>
<li><p>链接：合成可执行的程序，并对声明，在其他目标文件找到对应的定义(把编译过程中生成的所有对象文件链接起来，还会导入可能使用的其他库。)</p>
<p>需要文件：.obj文件及各种动态库(.so .dll)或静态库(.a .lib)</p>
<p>生成产物：可执行程序(.exe)</p>
</li>
</ol>
<ul>
<li>Compile（编译）：通常意味着对当前打开的文件中的代码进行编译。</li>
<li>Build&#x2F;Make（建立&#x2F;生成）：通常意味着编译项目中所有源代码文件的代码。一个项目中只有一个文件被修改则只重新编译该文件。</li>
<li>Build All：通常意味着重新编译所有的源代码文件。</li>
<li>Link（链接）：将编译后的源代码和所需的库代码组合起来。</li>
<li>Execute&#x2F;Run：运行程序，如果没有执行前面的步骤，则会先执行前面的步骤。</li>
<li>Debug：以步进方式执行程序。</li>
<li>编译器可能让选择调试版或者发布版，调试版包含额外的代码，提供详细的调试信息。</li>
</ul>
<p>声明：这个符号、这个函数是存在的。</p>
<p>定义：这个函数到底是什么。</p>
<h2 id="How-to-DEBUG-C-in-Visual-Studio"><a href="#How-to-DEBUG-C-in-Visual-Studio" class="headerlink" title="How to DEBUG C++ in Visual Studio"></a>How to DEBUG C++ in Visual Studio</h2><p><strong>berakpoints</strong> and <strong>reading memory</strong></p>
<p>We can pause our program and just take a look at what is going on in its memory.Remember,the memory of a running program is pretty much all it’s got. It’s what every variable is set to. It’s what function will be called next.</p>
<p><img src="/image-20220123003457216.png" alt="image-20220123003457216"></p>
<ul>
<li>step into (逐语句)  会跳转进相应函数内</li>
<li>step over (逐过程)  不会跳转</li>
<li>step out (跳出)</li>
</ul>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul>
<li><p><code>C</code>标准库和<code>C++</code>标准库的区别：有.h后缀的是<code>C</code>标准库，<code>C++</code>标准库没有</p>
</li>
<li><p>头文件（Header Files）通常只包含声明，他们不定义如何实现的东西</p>
</li>
<li><p>header guard 文件保护符（防止头文件被包含多次）</p>
<ul>
<li><p><code>#pragma once</code>  （常用）</p>
</li>
<li><pre><code class="cpp">#ifndef
#define
//头文件语句
#endif
</code></pre>
</li>
</ul>
</li>
<li><p><code>#include&quot; &quot;</code> 和 <code>#include&lt; &gt;</code></p>
<ul>
<li><p>一般来说，<code>#include &lt;&gt;</code> 的查找位置是标准库头文件所在目录，先去系统目录中找头文件，如果没有在到当前目录下找。</p>
<p><code>#include&lt;iostream&gt;</code></p>
</li>
<li><p>一般来说，<code>#include &quot; &quot;</code> 的查找位置是当前源文件所在目录，用于include自定义的头文件，让系统优先使用当前目录中定义的。</p>
<p><code>#include&quot;log.h&quot;</code></p>
<p>可以用 ..&#x2F; 返回上一级目录（相对地址）</p>
<p><code>#include&quot;../log.h&quot;</code></p>
</li>
</ul>
</li>
</ul>
<h1 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h1><p>存储数据时的3种基本属性：</p>
<ul>
<li>信息存储在何处</li>
<li>存储的值是多少</li>
<li>存储的信息是什么类型的</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量允许我们命名我们存储在内存中的数据（data），继续使用它。当创建一个变量时它将被存储在内存中——两个地方：堆和栈。</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-keyword-intro.html">C++ 的关键字（保留字）完整介绍 | 菜鸟教程 (runoob.com)</a></p>
<p>在<code>C++</code>中不同变量类型之间的唯一区别就是大小size（这个变量会占用多少内存）。这实际上是这些原始数据类型之间的唯一区别。</p>
<p>数据类型的实际大小取决于编译器——不同的编译器会有不同。由编译器确定类型的大小。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>位</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1 byte</td>
<td>-128 到 127 或者 0 到 255</td>
</tr>
<tr>
<td>short (int)</td>
<td>2 byte</td>
<td>-32768 到 32767</td>
</tr>
<tr>
<td>int</td>
<td>4 byte</td>
<td>-2147483648 到 2147483647</td>
</tr>
<tr>
<td>long (int)</td>
<td>4 byte</td>
<td>-2147483648 到 2147483647</td>
</tr>
<tr>
<td>long long (int)</td>
<td>8 byte</td>
<td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>float</td>
<td>4 byte</td>
<td>精度型占4个字节（32位）内存空间，+&#x2F;- 3.4e +&#x2F;- 38 (~7 个数字)</td>
</tr>
<tr>
<td>double</td>
<td>8 byte</td>
<td>双精度型占8 个字节（64位）内存空间，+&#x2F;- 1.7e +&#x2F;- 308 (~15 个数字)</td>
</tr>
<tr>
<td>long double</td>
<td>16 byte</td>
<td>长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td>
</tr>
<tr>
<td>bool</td>
<td>1 byte</td>
<td>实际只占用1bit（可以将8个bools存在一个byte里面，比如bitset）</td>
</tr>
</tbody></table>
<ul>
<li><p>一些基本类型可以使用一个或多个类型修饰符进行修饰：</p>
<ul>
<li>signed</li>
<li>unsigned（可以将unsigned添加到上述常用5个类型的任何一个，它会移除符号位，可以设置一个更大的数字。）</li>
<li>short</li>
<li>long</li>
</ul>
</li>
<li><p>float和double定义：</p>
<p>有一个f在后面才声明这是一个浮点数：</p>
</li>
</ul>
<p><img src="/image-20220120000333571.png" alt="image-20220120000333571"></p>
<p><img src="/image-20220120000357730.png" alt="image-20220120000357730"></p>
<ul>
<li>操作符sizeof，输出类型占用字节数，sizeof(bool)就会打印出1，表示bool占用一个字节。</li>
<li>C++ 也允许定义各种其他类型的变量，比如<strong>枚举、指针、数组、引用、数据结构、类</strong>等等</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做<strong>字面量</strong>。</p>
<p>常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。</p>
<p>常量就像是常规的变量，只不过常量的值在定义后不能进行修改。</p>
<ul>
<li><p>整数常量</p>
<p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</p>
<p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p>
</li>
<li><p>浮点常量</p>
</li>
<li><p>布尔常量</p>
<p>布尔常量共有两个，它们都是标准的 C++ 关键字：</p>
<ul>
<li><strong>true</strong> 值代表真。</li>
<li><strong>false</strong> 值代表假。</li>
</ul>
</li>
<li><p>字符常量</p>
<p>字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 <strong>wchar_t</strong> 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 <strong>char</strong> 类型的简单变量中。</p>
<p>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\t’），或一个通用的字符（例如 ‘\u02C0’）。</p>
<p>在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：</p>
<p>| 转义序列   | 含义                       |</p>
</li>
</ul>
<p>| :——— | :————————- |<br>| \\        | \ 字符                     |<br>| \‘        | ‘ 字符                     |<br>| \“        | “ 字符                     |<br>| ?         | ? 字符                     |<br>| \a         | 警报铃声                   |<br>| \b         | 退格键                     |<br>| \f         | 换页符                     |<br>| \n         | 换行符                     |<br>| \r         | 回车                       |<br>| \t         | 水平制表符                 |<br>| \v         | 垂直制表符                 |<br>| \ooo       | 一到三位的八进制数         |<br>| \xhh . . . | 一个或多个数字的十六进制数 |</p>
<ul>
<li><p>字符串常量</p>
<p>字符串字面值或常量是括在双引号 <strong>“”</strong> 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。</p>
<p>您可以使用 *<em>*</em> 做分隔符，把一个很长的字符串常量进行分行。</p>
</li>
</ul>
<p><strong>定义常量</strong></p>
<p>在 C++ 中，有两种简单的定义常量的方式：</p>
<ul>
<li>使用 <strong>#define</strong> 预处理器。</li>
<li>使用 <strong>const</strong> 关键字。</li>
</ul>
<h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p>C++ 中有两种类型的表达式：</p>
<ul>
<li><strong>左值（lvalue）：</strong>指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li>
<li><strong>右值（rvalue）：</strong>术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>
</ul>
<p>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：</p>
<pre><code class="cpp">int g = 20;
</code></pre>
<p>但是下面这个就不是一个有效的语句，会生成编译时错误：</p>
<pre><code class="cpp">10 = 20;
</code></pre>
<h2 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h2><p>类型限定符提供了变量的额外信息，用于在定义变量或函数时改变它们的默认行为的关键字。</p>
<table>
<thead>
<tr>
<th align="left">限定符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">const</td>
<td align="left"><strong>const</strong> 定义常量，表示该变量的值不能被修改。。</td>
</tr>
<tr>
<td align="left">volatile</td>
<td align="left">修饰符 <strong>volatile</strong> 告诉该变量的值可能会被程序以外的因素改变，如硬件或其他线程。。</td>
</tr>
<tr>
<td align="left">restrict</td>
<td align="left">由 <strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td>
</tr>
<tr>
<td align="left">mutable</td>
<td align="left">表示类中的成员变量可以在 const 成员函数中被修改。</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">用于定义静态变量，表示该变量的作用域仅限于当前文件或当前函数内，不会被其他文件或函数访问。</td>
</tr>
<tr>
<td align="left">register</td>
<td align="left">用于定义寄存器变量，表示该变量被频繁使用，可以存储在CPU的寄存器中，以提高程序的运行效率。</td>
</tr>
</tbody></table>
<h2 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h2><p>存储类定义 C++ 程序中变量&#x2F;函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>mutable</li>
<li>thread_local (C++11)</li>
</ul>
<p>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p>
<p><strong>auto 存储类</strong></p>
<p>自 <code>C++ 11</code> 以来，<strong>auto</strong> 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p>
<p><code>C++ 98</code>标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在 <code>C++ 17</code>中已删除这一用法。</p>
<p>根据初始化表达式自动推断被声明的变量的类型，如：</p>
<pre><code class="cpp">auto f=3.14;      //double 
auto s(&quot;hello&quot;);  //const char* 
auto z = new auto(9); // int* 
auto x1 = 5, x2 = 5.0, x3=&#39;r&#39;;//错误，必须是初始化为同一类型
</code></pre>
<p><strong>register 存储类</strong></p>
<p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>
<pre><code class="cpp">&#123;   
    register int  miles; 
&#125;
</code></pre>
<p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p>
<p><strong>static 存储类</strong></p>
<p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p>
<p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p>
<pre><code class="cpp">#include &lt;iostream&gt;
 
// 函数声明 
void func(void);
 
static int count = 10; /* 全局变量 */
 
int main()
&#123;
    while(count--)
    &#123;
       func();
    &#125;
    return 0;
&#125;
// 函数定义
void func( void )
&#123;
    static int i = 5; // 局部静态变量
    i++;
    std::cout &lt;&lt; &quot;变量 i 为 &quot; &lt;&lt; i ;
    std::cout &lt;&lt; &quot; , 变量 count 为 &quot; &lt;&lt; count &lt;&lt; std::endl;
&#125;
</code></pre>
<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre><code class="cpp">变量 i 为 6 , 变量 count 为 9
变量 i 为 7 , 变量 count 为 8
变量 i 为 8 , 变量 count 为 7
变量 i 为 9 , 变量 count 为 6
变量 i 为 10 , 变量 count 为 5
变量 i 为 11 , 变量 count 为 4
变量 i 为 12 , 变量 count 为 3
变量 i 为 13 , 变量 count 为 2
变量 i 为 14 , 变量 count 为 1
变量 i 为 15 , 变量 count 为 0
</code></pre>
<p><strong>extern 存储类</strong></p>
<p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p>
<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p>
<p>第一个文件：main.cpp</p>
<pre><code class="cpp">#include &lt;iostream&gt;
 
int count ;
extern void write_extern();
 
int main()
&#123;
   count = 5;
   write_extern();
&#125;
</code></pre>
<p>第二个文件：support.cpp</p>
<pre><code class="cpp">#include &lt;iostream&gt;
 
extern int count;
 
void write_extern(void)
&#123;
   std::cout &lt;&lt; &quot;Count is &quot; &lt;&lt; count &lt;&lt; std::endl;
&#125;
</code></pre>
<p>在这里，第二个文件中的 <em>extern</em> 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示：</p>
<pre><code class="shell">$ g++ main.cpp support.cpp -o write
</code></pre>
<p>这会产生 <strong>write</strong> 可执行程序，尝试执行 <strong>write</strong>，它会产生下列结果：</p>
<pre><code class="shell">$ ./write
Count is 5
</code></pre>
<p><strong>mutable 存储类</strong></p>
<p><strong>mutable</strong> 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p>
<p><strong>thread_local 存储类</strong></p>
<p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p>
<p>thread_local 说明符可以与 static 或 extern 合并。</p>
<p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p>
<p>以下演示了可以被声明为 thread_local 的变量：</p>
<pre><code class="cpp">thread_local int x;  // 命名空间下的全局变量
class X
&#123;
    static thread_local std::string s; // 类的static成员变量
&#125;;
static thread_local std::string X::s;  // X::s 是需要定义的
 
void foo()
&#123;
    thread_local std::vector&lt;int&gt; v;  // 本地变量
&#125;
</code></pre>
<h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><h2 id="数组（array）"><a href="#数组（array）" class="headerlink" title="数组（array）"></a>数组（array）</h2><p>存储一个固定大小的相同类型元素的顺序集合。</p>
<h2 id="字符串（string）"><a href="#字符串（string）" class="headerlink" title="字符串（string）"></a>字符串（string）</h2><p>字符串实际上是使用 <code>null</code> 字符 <code>\0</code> 终止的一维字符数组。</p>
<p>C++ 提供了以下两种类型的字符串表示形式：</p>
<ul>
<li>C-style 字符串 <code> #include &lt;cstring&gt;</code></li>
<li>C++ 引入的 string 类类型 <code> #include &lt;string&gt;</code></li>
</ul>
<h2 id="结构体（struct）"><a href="#结构体（struct）" class="headerlink" title="结构体（struct）"></a>结构体（struct）</h2><p>存储不同的数据类型。（int, float 和 double）</p>
<pre><code class="cpp">struct inflatable
&#123;
    char name[20];
    float volume;
    double price;
&#125;;
</code></pre>
<h2 id="共用体（union）"><a href="#共用体（union）" class="headerlink" title="共用体（union）"></a>共用体（union）</h2><p>存储不同的数据类型，但只能同时存储一种。（int 或 float 或 double）</p>
<pre><code class="cpp">union one4all
&#123;
    int int_val;
    long long_val;
    double double_val;
&#125;;
</code></pre>
<h2 id="枚举（enum）"><a href="#枚举（enum）" class="headerlink" title="枚举（enum）"></a>枚举（enum）</h2><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>
<p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p>
<p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：</p>
<pre><code class="cpp">enum 枚举名&#123; 
     标识符[=整型常数], 
     标识符[=整型常数], 
... 
     标识符[=整型常数]
&#125; 枚举变量;
    
</code></pre>
<p>如果枚举没有初始化, 即省掉”&#x3D;整型常数”时, 则从第一个标识符开始。</p>
<p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。</p>
<pre><code class="cpp">enum color &#123; red, green, blue &#125; c;
c = blue;
</code></pre>
<p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，<strong>green</strong> 的值为 5。</p>
<pre><code>enum color &#123; red, green=5, blue &#125;;
</code></pre>
<p>在这里，<strong>blue</strong> 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针（Pointers）对管理和操作内存至关重要，因为我们在代码中做的每件事，都是从内存中读取或者写入内存。</p>
<ul>
<li><code>&amp;</code>地址运算符：作用于变量，获得变量地址。</li>
<li><code> *</code>解除引用运算符&#x2F;间接值运算符：作用于指针，获取该地址处存储的值。</li>
</ul>
<p>指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。</p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;
 
int main ()
&#123;
   int  var = 20;   // 实际变量的声明
   int  *ip;        // 指针变量的声明
 
   ip = &amp;var;       // 在指针变量中存储 var 的地址
 
   cout &lt;&lt; &quot;Value of var variable: &quot;;
   cout &lt;&lt; var &lt;&lt; endl;
 
   // 输出在指针变量中存储的地址
   cout &lt;&lt; &quot;Address stored in ip variable: &quot;;
   cout &lt;&lt; ip &lt;&lt; endl;
 
   // 访问指针中地址的值,通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。
   cout &lt;&lt; &quot;Value of *ip variable: &quot;;
   cout &lt;&lt; *ip &lt;&lt; endl;
 
   return 0;
&#125;
//输出:
Value of var variable: 20
Address stored in ip variable: 0xbfc601ac
Value of *ip variable: 20
</code></pre>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p><code>int *pn = new int;</code> 运算符<code>new</code>根据类型来确定需要多少字节的内存，然后找到这样的内存并返回其地址。然后将地址赋给<code>pn</code>，<code>pn</code>是被声明为指向<code>int</code>的指针。</p>
<p>常规变量声明分配在栈（stack）的内存区域中；而new分配在堆（heap）或自由存储区（free store）</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>一定要配对的使用<code>new</code>和<code>delete</code>，否则将发生内存泄漏（memory leak）</p>
<pre><code class="cpp">int *p = new int; //allocate memory with new
...				 //use the memory
delete p;		  //free memory with delete when done

//使用new创建动态数组
int *ps = new int [10];  //get a block of 10 ints
delete [] ps;			//free a ddynamic array
</code></pre>
<h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>C++将数组名解释为数组第一个元素的地址</p>
<pre><code class="cpp">double wages[3] = &#123;1000.0, 2000.0, 3000.0&#125;;
double *p = wages; 
//wages = &amp;wages[0] = address of first element of array
</code></pre>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用（References）和指针的不同：</p>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
</ul>
<p>引用只是其他变量的一个别名（alias）</p>
<p>引用只在定义时绑定，如果在定义后将变量赋值给引用，则不会重新绑定，而只是赋值。</p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;
int main ()
&#123;
   // 声明简单的变量
   int    i;
   double d;
   // 声明引用变量
   int&amp;    r = i;
   double&amp; s = d;
   
   i = 5;
   cout &lt;&lt; &quot;Value of i : &quot; &lt;&lt; i &lt;&lt; endl;
   cout &lt;&lt; &quot;Value of i reference : &quot; &lt;&lt; r  &lt;&lt; endl;
 
   d = 11.7;
   cout &lt;&lt; &quot;Value of d : &quot; &lt;&lt; d &lt;&lt; endl;
   cout &lt;&lt; &quot;Value of d reference : &quot; &lt;&lt; s  &lt;&lt; endl;
   
   return 0;
&#125;
//输出
Value of i : 5
Value of i reference : 5
Value of d : 11.7
Value of d reference : 11.7
</code></pre>
<p>用指针来实现引用调用函数</p>
<pre><code class="cpp">void Increment(int* value)
&#123;
    (*value)++;
&#125;
int main()
&#123;
    int a = 5;
    Increment(&amp;a);
    cout&lt;&lt;a&lt;&lt;endl;
    cin.get();
    return 0;
&#125;
</code></pre>
<p>用引用来实现引用调用函数。通过使用引用来替代指针，会使 <code>C++</code> 程序更容易阅读和维护。</p>
<pre><code class="cpp">void Increment(int&amp; value)
&#123;
    value++;
&#125;
int main()
&#123;
    int a = 5;
    Increment(a);
    cout&lt;&lt;a&lt;&lt;endl;
    cin.get();
    return 0;
&#125;
</code></pre>
<p>把引用作为返回值</p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;
 
double vals[] = &#123;10.1, 12.6, 33.1, 24.1, 50.0&#125;;
 
double&amp; setValues(int i) &#123;  
   double&amp; ref = vals[i];    
   return ref;   // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]
&#125;
 
// 要调用上面定义函数的主函数
int main ()
&#123;
   cout &lt;&lt; &quot;改变前的值&quot; &lt;&lt; endl;
   for ( int i = 0; i &lt; 5; i++ )
   &#123;
       cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
       cout &lt;&lt; vals[i] &lt;&lt; endl;
   &#125;
 
   setValues(1) = 20.23; // 改变第 2 个元素
   setValues(3) = 70.8;  // 改变第 4 个元素
 
   cout &lt;&lt; &quot;改变后的值&quot; &lt;&lt; endl;
   for ( int i = 0; i &lt; 5; i++ )
   &#123;
       cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;
       cout &lt;&lt; vals[i] &lt;&lt; endl;
   &#125;
   return 0;
&#125;
</code></pre>
<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><p>Loops in C++</p>
<ul>
<li><p>whlie循环</p>
<p>当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</p>
<pre><code class="cpp">while(condition)
&#123;
   statement(s);
&#125;
</code></pre>
</li>
<li><p>for循环</p>
<p>for循环允许编写一个执行特定次数的循环的重复控制结构。</p>
<pre><code class="cpp">for ( init; condition; increment )
&#123;
   statement(s);
&#125;
</code></pre>
</li>
<li><p>do…while…循环</p>
<p>除了它是在循环主体结尾测试条件外，其他与 while 语句类似，但是 do…while 循环会确保至少执行一次循环。</p>
<pre><code class="cpp">do
&#123;
   statement(s);

&#125;while( condition );
</code></pre>
</li>
</ul>
<h1 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h1><p>Conditions and Branches in C++</p>
<ul>
<li><p>if…else…</p>
<pre><code class="cpp">if(boolean_expression)
&#123;
   // 如果布尔表达式为真将执行的语句
&#125;
else
&#123;
   // 如果布尔表达式为假将执行的语句
&#125;
</code></pre>
</li>
<li><p>switch</p>
<pre><code class="cpp">switch(expression)&#123;
    case constant-expression  :
       statement(s);
       break; // 可选的
    case constant-expression  :
       statement(s);
       break; // 可选的
    // 可以有任意数量的 case 语句
    default : // 可选的
       statement(s);
&#125;
</code></pre>
</li>
<li><p>条件运算符 ? :</p>
<p>可以用来替代 <strong>if…else</strong> 语句</p>
<pre><code class="cpp">if(y &lt; 10)&#123; 
   var = 30;
&#125;else&#123;
   var = 40;
&#125;
//条件运算符形式
var = (y &lt; 10) ? 30 : 40;
</code></pre>
</li>
</ul>
<p>控制流(Control Flow in C++)</p>
<ul>
<li><p>break</p>
<p>当 break 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行<strong>紧接着循环的下一条语句</strong>。如果您使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。它也可用于终止 switch 语句中的一个 case。</p>
</li>
<li><p>continue</p>
<p>continue 会跳过当前循环中的代码，强迫开始下一次循环。</p>
<p>对于 for 循环，continue语句会导致执行条件测试和循环增量部分。对于 while 和 do…while 循环，continue 语句会导致程序控制回到条件测试上。</p>
</li>
<li><p>return</p>
<p>没必要在循环内使用，可在代码内任何位置使用，return之后的语句都不会执行。</p>
</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数（Functions）是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 <strong>main()</strong> </p>
<p>应当需要一点经验来意识到<strong>什么时候需要一个函数</strong>，如果正在多次做一个常见的任务，那么为他创建一个函数。</p>
<p>函数的主要目的是<strong>防止代码重复</strong>，我们不希望只是到处复制和粘贴代码。</p>
<p>函数就是我们写的代码块，被设计为用来执行特定的任务。在class中这些代码块则被称为方法method。这里所说函数单独指类外的。</p>
<p>每次调用函数，编译器生成一个call指令（类外的，因此没有什么动态绑定，也暂时不考虑内联）。这基本上意义着，在一个运行的程序中，为了调用一个函数，我们需要创建一个堆栈结构，这意味着我们必须把像参数这样的东西推进堆栈。我们还需要一个叫做返回地址的东西压入堆栈。然后我们要做的是跳到二进制执行文件的不同部分，以便开始执行我们的函数指令。</p>
<p>为了将push进去的结果返回，然后我们得回去到最初调用函数之前。跳跃和执行这些都需要时间，所以它会减慢我们的程序。</p>
<p>而对于main函数，返回值是int，并且只有main函数可以不return——它会自动假设返回0.（这是现代C和C++的一个特性）</p>
<p><strong>定义函数</strong></p>
<p>C++ 中的函数定义的一般形式如下：</p>
<p>return_type function_name( parameter list ) {   body of the function }</p>
<p>在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：</p>
<ul>
<li>返回类型：一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li>
<li>函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>
<li>参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>
<li>函数主体：函数主体包含一组定义函数执行任务的语句。</li>
</ul>
<p><strong>函数参数</strong></p>
<p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p>
<p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>
<p>当调用函数时，有三种向函数传递参数的方式：</p>
<table>
<thead>
<tr>
<th align="left">调用类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">传值调用</td>
<td align="left">该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td>
</tr>
<tr>
<td align="left">指针调用</td>
<td align="left">该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>
</tr>
<tr>
<td align="left">引用调用</td>
<td align="left">该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>
</tr>
</tbody></table>
<p>默认情况下，C++ 使用<strong>传值调用</strong>来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。</p>
<p><strong>Lambda 函数与表达式</strong></p>
<hr>
<h1 id="类-amp-对象"><a href="#类-amp-对象" class="headerlink" title="类&amp;对象"></a>类&amp;对象</h1><p>类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。</p>
<p>C++ 类定义</p>
<p><img src="/cpp-classes-objects-2020-12-10-11.png" alt="img"></p>
<pre><code class="cpp">#include &lt;iostream&gt;
 
using namespace std;
 
class Box
&#123;
   public:
      double length;   // 长度
      double breadth;  // 宽度
      double height;   // 高度
      // 成员函数声明
      double get(void);
      void set( double len, double bre, double hei );
&#125;;
// 成员函数定义
double Box::get(void)
&#123;
    return length * breadth * height;
&#125;
 
void Box::set( double len, double bre, double hei)
&#123;
    length = len;
    breadth = bre;
    height = hei;
&#125;
int main( )
&#123;
   Box Box1;        // 声明 Box1，类型为 Box
   Box Box2;        // 声明 Box2，类型为 Box
   Box Box3;        // 声明 Box3，类型为 Box
   double volume = 0.0;     // 用于存储体积
 
   // box 1 详述
   Box1.height = 5.0; 
   Box1.length = 6.0; 
   Box1.breadth = 7.0;
 
   // box 2 详述
   Box2.height = 10.0;
   Box2.length = 12.0;
   Box2.breadth = 13.0;
 
   // box 1 的体积
   volume = Box1.height * Box1.length * Box1.breadth;
   cout &lt;&lt; &quot;Box1 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;
 
   // box 2 的体积
   volume = Box2.height * Box2.length * Box2.breadth;
   cout &lt;&lt; &quot;Box2 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;
 
 
   // box 3 详述
   Box3.set(16.0, 8.0, 12.0); 
   volume = Box3.get(); 
   cout &lt;&lt; &quot;Box3 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;
   return 0;
&#125;
</code></pre>
<table>
<thead>
<tr>
<th>类成员函数</th>
<th>类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。</th>
</tr>
</thead>
<tbody><tr>
<td>类访问修饰符</td>
<td>类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。</td>
</tr>
<tr>
<td>构造函数 &amp; 析构函数</td>
<td>类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。</td>
</tr>
<tr>
<td>C++ 拷贝构造函数</td>
<td>拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。</td>
</tr>
<tr>
<td>C++ 友元函数</td>
<td><strong>友元函数</strong>可以访问类的 private 和 protected 成员。</td>
</tr>
<tr>
<td>C++ 内联函数</td>
<td>通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。</td>
</tr>
<tr>
<td>C++ 中的 this 指针</td>
<td>每个对象都有一个特殊的指针 <strong>this</strong>，它指向对象本身。</td>
</tr>
<tr>
<td>C++ 中指向类的指针</td>
<td>指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。</td>
</tr>
<tr>
<td>C++ 类的静态成员</td>
<td>类的数据成员和函数成员都可以被声明为静态的。</td>
</tr>
</tbody></table>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。</p>
<p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p>
<p><img src="/cpp-inheritance-2020-12-15-1.png" alt="img"></p>
<pre><code class="cpp">// 基类
class Animal &#123;
    // eat() 函数
    // sleep() 函数
&#125;;


//派生类
class Dog : public Animal &#123;
    // bark() 函数
&#125;;
</code></pre>
<p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p>
<pre><code class="cpp">class derived-class: access-specifier base-class
</code></pre>
<p>其中，访问修饰符 access-specifier 是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p>
<p>举例</p>
<pre><code class="cpp">#include &lt;iostream&gt;

using namespace std;
 
// 基类
class Shape 
&#123;
   public:
      void setWidth(int w)
      &#123;
         width = w;
      &#125;
      void setHeight(int h)
      &#123;
         height = h;
      &#125;
   protected:
      int width;
      int height;
&#125;;
 
// 派生类
class Rectangle: public Shape
&#123;
   public:
      int getArea()
      &#123; 
         return (width * height); 
      &#125;
&#125;;
 
int main(void)
&#123;
   Rectangle Rect;
 
   Rect.setWidth(5);
   Rect.setHeight(7);
 
   // 输出对象的面积
   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;
 
   return 0;
&#125;
//Total area: 35
</code></pre>
<h2 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h2><p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p>
<p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p>
<table>
<thead>
<tr>
<th align="left">访问</th>
<th align="left">public</th>
<th align="left">protected</th>
<th align="left">private</th>
</tr>
</thead>
<tbody><tr>
<td align="left">同一个类</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">派生类</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">外部的类</td>
<td align="left">yes</td>
<td align="left">no</td>
<td align="left">no</td>
</tr>
</tbody></table>
<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>
<ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
</ul>
<p><strong>继承类型</strong></p>
<p>当一个类派生自基类，该基类可以被继承为 <strong>public、protected</strong> 或 <strong>private</strong> 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>
<p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p>
<ul>
<li><strong>公有继承（public）：</strong>当一个类派生自<strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，<strong>基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问</strong>。</li>
<li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li>
<li><strong>私有继承（private）：</strong>当一个类派生自<strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li>
</ul>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p>
<p>C++ 类可以从多个类继承成员，语法如下：</p>
<pre><code class="cpp">class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…
&#123;
&lt;派生类类体&gt;
&#125;;
</code></pre>
<p>实例</p>
<pre><code class="cpp">#include &lt;iostream&gt;
 
using namespace std;
 
// 基类 Shape
class Shape 
&#123;
   public:
      void setWidth(int w)
      &#123;
         width = w;
      &#125;
      void setHeight(int h)
      &#123;
         height = h;
      &#125;
   protected:
      int width;
      int height;
&#125;;
 
// 基类 PaintCost
class PaintCost 
&#123;
   public:
      int getCost(int area)
      &#123;
         return area * 70;
      &#125;
&#125;;
 
// 派生类
class Rectangle: public Shape, public PaintCost
&#123;
   public:
      int getArea()
      &#123; 
         return (width * height); 
      &#125;
&#125;;
 
int main(void)
&#123;
   Rectangle Rect;
   int area;
 
   Rect.setWidth(5);
   Rect.setHeight(7);
 
   area = Rect.getArea();
   
   // 输出对象的面积
   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;
 
   // 输出总花费
   cout &lt;&lt; &quot;Total paint cost: $&quot; &lt;&lt; Rect.getCost(area) &lt;&lt; endl;
 
   return 0;
&#125;
//Total area: 35
//Total paint cost: $2450
</code></pre>
<h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><p>C++ 允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p>
<p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有<strong>相同名称的声明</strong>，但是它们的<strong>参数列表和定义（实现）不相同</strong>。</p>
<p>当您调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。</p>
<h2 id="C-中的函数重载"><a href="#C-中的函数重载" class="headerlink" title="C++ 中的函数重载"></a>C++ 中的函数重载</h2><p>在同一个作用域内，可以声明几个功能类似的<strong>同名函数</strong>，但是这些<strong>同名函数的形式参数</strong>（指参数的个数、类型或者顺序）<strong>必须不同</strong>。您不能仅通过返回类型的不同来重载函数。</p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;
 
class printData
&#123;
   public:
      void print(int i) &#123;
        cout &lt;&lt; &quot;整数为: &quot; &lt;&lt; i &lt;&lt; endl;
      &#125;
 
      void print(double  f) &#123;
        cout &lt;&lt; &quot;浮点数为: &quot; &lt;&lt; f &lt;&lt; endl;
      &#125;
 
      void print(char c[]) &#123;
        cout &lt;&lt; &quot;字符串为: &quot; &lt;&lt; c &lt;&lt; endl;
      &#125;
&#125;;
 
int main(void)
&#123;
   printData pd;
 
   // 输出整数
   pd.print(5);
   // 输出浮点数
   pd.print(500.263);
   // 输出字符串
   char c[] = &quot;Hello C++&quot;;
   pd.print(c);
 
   return 0;
&#125;
//整数为: 5
//浮点数为: 500.263
//字符串为: Hello C++
</code></pre>
<h2 id="C-中的运算符重载"><a href="#C-中的运算符重载" class="headerlink" title="C++ 中的运算符重载"></a>C++ 中的运算符重载</h2><p>重载的运算符是<strong>带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的</strong>。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。</p>
<pre><code class="cpp">Box operator+(const Box&amp;);//类的成员函数
Box operator+(const Box&amp;, const Box&amp;);//普通非成员函数
</code></pre>
<p>实例</p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;
 
class Box
&#123;
   public:
 
      double getVolume(void)
      &#123;
         return length * breadth * height;
      &#125;
      void setLength( double len )
      &#123;
          length = len;
      &#125;
 
      void setBreadth( double bre )
      &#123;
          breadth = bre;
      &#125;
 
      void setHeight( double hei )
      &#123;
          height = hei;
      &#125;
      // 重载 + 运算符，用于把两个 Box 对象相加
      Box operator+(const Box&amp; b)
      &#123;
         Box box;
         box.length = this-&gt;length + b.length;
         box.breadth = this-&gt;breadth + b.breadth;
         box.height = this-&gt;height + b.height;
         return box;
      &#125;
   private:
      double length;      // 长度
      double breadth;     // 宽度
      double height;      // 高度
&#125;;
// 程序的主函数
int main( )
&#123;
   Box Box1;                // 声明 Box1，类型为 Box
   Box Box2;                // 声明 Box2，类型为 Box
   Box Box3;                // 声明 Box3，类型为 Box
   double volume = 0.0;     // 把体积存储在该变量中
 
   // Box1 详述
   Box1.setLength(6.0); 
   Box1.setBreadth(7.0); 
   Box1.setHeight(5.0);
 
   // Box2 详述
   Box2.setLength(12.0); 
   Box2.setBreadth(13.0); 
   Box2.setHeight(10.0);
 
   // Box1 的体积
   volume = Box1.getVolume();
   cout &lt;&lt; &quot;Volume of Box1 : &quot; &lt;&lt; volume &lt;&lt;endl;
 
   // Box2 的体积
   volume = Box2.getVolume();
   cout &lt;&lt; &quot;Volume of Box2 : &quot; &lt;&lt; volume &lt;&lt;endl;
 
   // 把两个对象相加，得到 Box3
   Box3 = Box1 + Box2;
 
   // Box3 的体积
   volume = Box3.getVolume();
   cout &lt;&lt; &quot;Volume of Box3 : &quot; &lt;&lt; volume &lt;&lt;endl;
 
   return 0;
&#125;
//Volume of Box1 : 210
//Volume of Box2 : 1560
//Volume of Box3 : 5400
</code></pre>
<h2 id="可重载运算符-x2F-不可重载运算符"><a href="#可重载运算符-x2F-不可重载运算符" class="headerlink" title="可重载运算符&#x2F;不可重载运算符"></a>可重载运算符&#x2F;不可重载运算符</h2><p>下面是可重载的运算符列表：</p>
<table>
<thead>
<tr>
<th>双目算术运算符</th>
<th>+ (加)，-(减)，*(乘)，&#x2F;(除)，% (取模)</th>
</tr>
</thead>
<tbody><tr>
<td>关系运算符</td>
<td>&#x3D;&#x3D;(等于)，!&#x3D; (不等于)，&lt; (小于)，&gt; (大于)，&lt;&#x3D;(小于等于)，&gt;&#x3D;(大于等于)</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td>
</tr>
<tr>
<td>单目运算符</td>
<td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td>
</tr>
<tr>
<td>自增自减运算符</td>
<td>++(自增)，–(自减)</td>
</tr>
<tr>
<td>位运算符</td>
<td>| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>&#x3D;, +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D; , % &#x3D; , &amp;&#x3D;, |&#x3D;, ^&#x3D;, &lt;&lt;&#x3D;, &gt;&gt;&#x3D;</td>
</tr>
<tr>
<td>空间申请与释放</td>
<td>new, delete, new[ ] , delete[]</td>
</tr>
<tr>
<td>其他运算符</td>
<td><strong>()</strong>(函数调用)，**-&gt;<strong>(成员访问)，</strong>,<strong>(逗号)，</strong>[]**(下标)</td>
</tr>
</tbody></table>
<p>下面是不可重载的运算符列表：</p>
<ul>
<li>**.**：成员访问运算符</li>
<li><strong>.*</strong>, **-&gt;***：成员指针访问运算符</li>
<li>**::**：域运算符</li>
<li><strong>sizeof</strong>：长度运算符</li>
<li>**?:**：条件运算符</li>
<li>**#**： 预处理符号</li>
</ul>
<h1 id="C-多态"><a href="#C-多态" class="headerlink" title="C++ 多态"></a>C++ 多态</h1><p><strong>多态</strong>按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p>
<p>C++ 多态意味着<strong>调用成员函数时，会根据调用函数的对象的类型来执行不同的函数</strong>。</p>
<p>实例</p>
<pre><code class="cpp">#include &lt;iostream&gt;

using namespace std;

class Shape 
&#123;
    protected:
        int width, height;
    public:
        Shape( int a=0 ,int b=0 )
        &#123;
            width = a;
            height = b;
        &#125;
        int area()
        &#123;
            cout &lt;&lt; &quot;Parent class area :&quot;&lt;&lt;endl;
            return 0;
        &#125;
&#125;;

class Rectangle: public Shape
&#123;
    public:
        Rectangle( int a=0, int b=0):Shape(a, b)&#123; &#125;
        int area ()
        &#123;
            cout&lt;&lt; &quot;Retangle class area:&quot;&lt;&lt;endl;
            return (width * height);
        &#125;
&#125;;

class Triangle: public Shape
&#123;
    public:
        Triangle(int a=0, int b=0):Shape(a, b)&#123;&#125;
        int area()
        &#123;
            cout &lt;&lt; &quot;Triangle class area: &quot;&lt;&lt;endl;
            return (width * height / 2);
        &#125;
&#125;;

int main()
&#123;
    Shape *shape;
    Rectangle rec(10, 7);
    Triangle tri(10, 5);

    //存储矩形的地址
    shape = &amp;rec;
    //调用矩形的求面积函数 area
    shape -&gt;area();

    shape = &amp;tri;
    shape-&gt;area();

    return 0;
&#125;
</code></pre>
<pre><code class="cpp">Parent class area :
Parent class area :
</code></pre>
<p>导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的<strong>静态多态</strong>，或<strong>静态链接</strong>。函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area() 函数在程序编译期间就已经设置好了。</p>
<p>但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 <strong>virtual</strong></p>
<pre><code class="cpp">class Shape &#123;
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      &#123;
         width = a;
         height = b;
      &#125;
      virtual int area()
      &#123;
         cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl;
         return 0;
      &#125;
&#125;;
</code></pre>
<pre><code class="cpp">Rectangle class area :
Triangle class area :
</code></pre>
<p>此时，<strong>编译器看的是指针的内容，而不是它的类型</strong>。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。</p>
<p>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是<strong>多态</strong>的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>
<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p>
<p>我们可以把基类中的虚函数 area() 改写如下：</p>
<pre><code class="cpp">class Shape &#123;
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      &#123;
         width = a;
         height = b;
      &#125;
      // pure virtual function
      virtual int area() = 0;
&#125;;
</code></pre>
<p>&#x3D; 0 告诉编译器，函数没有主体，上面的虚函数是<strong>纯虚函数</strong>。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #03a9f4">
                C++
            </a>
        </span>
        
    </div>
    <a href="/2023/02/24/C++Study/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    <div class="prev">
        
        <a class="page-num" href="/">
            <i class="fa-solid fa-caret-left fa-fw"></i>
        </a>
        
    </div>
    <div class="page-index">
        
        <span>
            
            
            <a class="page-num" href="/">1</a>
        </span>
        
        <span class="current">2</span>
        
    </div>
    <div class="next">
        
    </div>
</div>

    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">AdventureYX</div>
        <div class="description">
            <p>Description<br>…</p>

        </div>
        
        <div class="icon-links">
            
            <span class="icon-link">
                <a href="/function%20link()%20%7B%20%5Bnative%20code%5D%20%7D">
                    <i
                        class="fa- fa- fa-fw"
                    ></i>
                </a>
            </span>
            
        </div>
        
        
    </div>
</div>

    </div>
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 Adventure
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;AdventureYX
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
    </body>
</html>
