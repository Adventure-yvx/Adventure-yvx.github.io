



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="" href="https://adventure-yx.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://adventure-yx.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://adventure-yx.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="C++" />


<link rel="canonical" href="https://adventure-yx.github.io/2023/04/02/C++11/">



  <title>
C++11/14/17 - C++ |
Adventure =  = 心有所向。日复一日，必有精进</title>
<meta name="generator" content="Hexo 6.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">C++11/14/17
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2023-04-02 20:10:08">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2023-04-02T20:10:08+08:00">2023-04-02</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Adventure</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="/2023/04/02/C++11/sky-15.jpg">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/C/" itemprop="item" rel="index" title="分类于 C++"><span itemprop="name">C++</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://adventure-yx.github.io/2023/04/02/C++11/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="AdventureYX">
    <meta itemprop="description" content="心有所向。日复一日，必有精进, ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="安全性智能指针"><a class="markdownIt-Anchor" href="#安全性智能指针">#</a> 安全性 —— 智能指针</h1>
<p><strong>内存泄漏</strong>：由于疏忽或错误导致的程序未能释放已经不再使用的内存。</p>
<p>进一步解释：</p>
<ul>
<li>
<p>并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。</p>
</li>
<li>
<p>常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。</p>
</li>
<li>
<p>使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。</p>
</li>
<li>
<p>指针重新赋值</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>p <span class="token operator">=</span> np<span class="token punctuation">;</span></pre></td></tr></table></figure><p>开始时，指针 p 和 p1 分别指向一块内存空间，但指针 p 被重新赋值，导致 p 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。</p>
</li>
</ul>
<p>解决内存泄漏最有效的方法是使用<strong>智能指针（smart pointer）</strong>。</p>
<p>智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在<strong>离开指针所在作用域时，自动地销毁动态分配的对象</strong>，防止内存泄露。</p>
<p>智能指针的核心实现技术是<strong>引用计数</strong>，每使用它一次，内部引用计数加 1，每析构一次内部的引用计数减 1，减为 0 时，删除所指向的堆内存。</p>
<p>C++11 中提供了三种智能指针，使用这些智能指针时需要引用头文件 <code> &lt;memory&gt;</code> :</p>
<ul>
<li><code> std::shared_ptr</code> ：共享的智能指针</li>
<li><code> std::unique_ptr</code> ：独占的智能指针</li>
<li><code> std::weak_ptr</code> ：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视 <code>shared_ptr</code>  的。</li>
</ul>
<h2 id="共享智能指针shared_ptr"><a class="markdownIt-Anchor" href="#共享智能指针shared_ptr">#</a> 共享智能指针（shared_ptr）</h2>
<h3 id="shared_ptr的初始化"><a class="markdownIt-Anchor" href="#shared_ptr的初始化">#</a> shared_ptr 的初始化</h3>
<p>共享智能指针是指<strong>多个智能指针可以同时管理同一块有效的内存</strong>，共享智能指针  <code>shared_ptr</code>  是一个<strong>模板类</strong>，如果要进行初始化有三种方式：</p>
<ul>
<li>构造函数</li>
<li><code>std::make_shared</code>  辅助函数</li>
<li>reset 方法</li>
</ul>
<p>共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数 use_count，函数原型如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">long</span> <span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="通过构造函数初始化"><a class="markdownIt-Anchor" href="#通过构造函数初始化">#</a> 通过构造函数初始化</h3>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//shared_ptr&lt;T> 类模板中，提供了多种实用的构造函数，语法格式如下:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> 智能指针名字<span class="token punctuation">(</span>创建堆内存<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 使用智能指针管理一块 int 型的堆内存</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr1管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 使用智能指针管理一块字符数组对应的堆内存</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> <span class="token function">ptr2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr2管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 创建智能指针对象，不管理任何内存</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr3<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr3管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">// 创建智能指针对象，初始化为空</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr4</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr4管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>测试结果：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre>ptr1管理的内存引用计数<span class="token operator">:</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="2"></td><td><pre>ptr2管理的内存引用计数<span class="token operator">:</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="3"></td><td><pre>ptr3管理的内存引用计数<span class="token operator">:</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="4"></td><td><pre>ptr4管理的内存引用计数<span class="token operator">:</span> <span class="token number">0</span></pre></td></tr></table></figure><blockquote>
<p>如果智能指针被初始化了一块有效内存，那么这块内存的引用计数 + 1，如果智能指针没有被初始化或者被初始化为 nullptr 空指针，引用计数不会 + 1。另外，不要使用一个原始指针初始化多个 shared_ptr。</p>
</blockquote>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//error, 编译不会报错，运行会出错</span></pre></td></tr></table></figure><h3 id="通过拷贝和移动构造函数初始化"><a class="markdownIt-Anchor" href="#通过拷贝和移动构造函数初始化">#</a> 通过拷贝和移动构造函数初始化</h3>
<p>当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 使用智能指针管理一块 int 型的堆内存，内部引用计数为 1</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr1管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 调用拷贝构造函数</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr2</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr2管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr3 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr3管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// 调用移动构造函数</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr4</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr4管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr5 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr5管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr5<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>测试结果：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre>ptr1管理的内存引用计数<span class="token operator">:</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="2"></td><td><pre>ptr2管理的内存引用计数<span class="token operator">:</span> <span class="token number">2</span></pre></td></tr><tr><td data-num="3"></td><td><pre>ptr3管理的内存引用计数<span class="token operator">:</span> <span class="token number">3</span></pre></td></tr><tr><td data-num="4"></td><td><pre>ptr4管理的内存引用计数<span class="token operator">:</span> <span class="token number">3</span></pre></td></tr><tr><td data-num="5"></td><td><pre>ptr5管理的内存引用计数<span class="token operator">:</span> <span class="token number">3</span></pre></td></tr></table></figure><blockquote>
<p>如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加；如果使用移动的方式初始智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存的引用计数不会变化。</p>
</blockquote>
<h3 id="通过-stdmake_shared-初始化"><a class="markdownIt-Anchor" href="#通过-stdmake_shared-初始化">#</a> 通过 std::make_shared 初始化</h3>
<p>通过 C++ 提供的 std::make_shared () 就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args <span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">make_shared</span><span class="token punctuation">(</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li><code>T</code> ：模板参数的数据类型</li>
<li><code>Args&amp;&amp;... args</code>  ：要初始化的数据，如果是通过 make_shared 创建对象，需按照构造函数的参数列表指定</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Test</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"construct Test..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"construct Test, x = "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">Test</span><span class="token punctuation">(</span>string str<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"construct Test, str = "</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token operator">~</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"destruct Test ..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token comment">// 使用智能指针管理一块 int 型的堆内存，内部引用计数为 1</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr1管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> ptr2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Test<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr2管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> ptr3 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Test<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr3管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">></span> ptr4 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Test<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"ptr_test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr4管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote>
<p>使用 std::make_shared () 模板函数可以完成内存地址的创建，并将最终得到的内存地址传递给共享智能指针对象管理。如果申请的内存是普通类型，通过函数的（）可完成地址的初始化，如果要创建一个类对象，函数的（）内部需要指定构造对象需要的参数，也就是类构造函数的参数。</p>
</blockquote>
<h3 id="通过-reset-方法初始化"><a class="markdownIt-Anchor" href="#通过-reset-方法初始化">#</a> 通过 reset 方法初始化</h3>
<p>共享智能指针类提供的 std::shared_ptr::reset 方法函数原型如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Y</span> <span class="token operator">></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span> Y<span class="token operator">*</span> ptr <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Deleter</span> <span class="token operator">></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span> Y<span class="token operator">*</span> ptr<span class="token punctuation">,</span> Deleter d <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Y</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Deleter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">></span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span> Y<span class="token operator">*</span> ptr<span class="token punctuation">,</span> Deleter d<span class="token punctuation">,</span> Alloc alloc <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li>ptr：指向要取得所有权的对象的指针</li>
<li>d：指向要取得所有权的对象的指针</li>
<li>aloc：内部存储所用的分配器</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 使用智能指针管理一块 int 型的堆内存，内部引用计数为 1</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr2 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr3 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr4 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr1管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr2管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr3管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr4管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    ptr4<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr1管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr2管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr3管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr4管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr5<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    ptr5<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr5管理的内存引用计数: "</span> <span class="token operator">&lt;&lt;</span> ptr5<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>测试结果：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre>ptr1管理的内存引用计数<span class="token operator">:</span> <span class="token number">4</span></pre></td></tr><tr><td data-num="2"></td><td><pre>ptr2管理的内存引用计数<span class="token operator">:</span> <span class="token number">4</span></pre></td></tr><tr><td data-num="3"></td><td><pre>ptr3管理的内存引用计数<span class="token operator">:</span> <span class="token number">4</span></pre></td></tr><tr><td data-num="4"></td><td><pre>ptr4管理的内存引用计数<span class="token operator">:</span> <span class="token number">4</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    </pre></td></tr><tr><td data-num="6"></td><td><pre>ptr1管理的内存引用计数<span class="token operator">:</span> <span class="token number">3</span></pre></td></tr><tr><td data-num="7"></td><td><pre>ptr2管理的内存引用计数<span class="token operator">:</span> <span class="token number">3</span></pre></td></tr><tr><td data-num="8"></td><td><pre>ptr3管理的内存引用计数<span class="token operator">:</span> <span class="token number">3</span></pre></td></tr><tr><td data-num="9"></td><td><pre>ptr4管理的内存引用计数<span class="token operator">:</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    </pre></td></tr><tr><td data-num="11"></td><td><pre>ptr5管理的内存引用计数<span class="token operator">:</span> <span class="token number">1</span></pre></td></tr></table></figure><blockquote>
<p>对于一个未初始化的共享智能指针，可以通过 reset 方法来初始化，当智能指针中有值的时候，调用 reset 会使引用计数减 1。</p>
</blockquote>
<h3 id="获取原始指针"><a class="markdownIt-Anchor" href="#获取原始指针">#</a> 获取原始指针</h3>
<hr>
<h2 id="独占智能指针unique_ptr"><a class="markdownIt-Anchor" href="#独占智能指针unique_ptr">#</a> 独占智能指针（unique_ptr）</h2>
<h3 id="unique_ptr的初始化"><a class="markdownIt-Anchor" href="#unique_ptr的初始化">#</a> unique_ptr 的初始化</h3>
<p>std::unique_ptr 是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个 unique_ptr 赋值给另一个 unique_ptr。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 通过构造函数初始化对象</span></pre></td></tr><tr><td data-num="2"></td><td><pre>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">//error, 不允许将一个 unique_ptr 赋值给另一个 unique_ptr</span></pre></td></tr><tr><td data-num="4"></td><td><pre>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr2 <span class="token operator">=</span> ptr1<span class="token punctuation">;</span></pre></td></tr></table></figure><p>std::unique_ptr 不允许复制，但是可以通过函数返回给其他的 std::unique_ptr，还可以通过  <code>std::move</code>  来转移给其他的 std::unique_ptr，这样原始指针的所有权就被转移了，这个原始指针还是被独占的。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 通过构造函数初始化</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">// 通过转移所有权的方式初始化</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr3 <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>unique_ptr 独占智能指针类也有一个 reset 方法，函数原型如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span> pointer ptr <span class="token operator">=</span> <span class="token function">pointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>使用 reset 方法可以让 unique_ptr 解除对原始内存的管理，也可以用来初始化一个独占的智能指针。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    ptr1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 解除对原始内存的管理</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    ptr2<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	 <span class="token comment">// 重新指定智能指针管理的原始内存</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果想要获取独占智能指针管理的原始地址，可以调用 get () 方法，函数原型如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre>pointer <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ptr2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    ptr2<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ptr2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>	<span class="token comment">// 得到内存地址中存储的实际数值 250</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="删除器"><a class="markdownIt-Anchor" href="#删除器">#</a> 删除器</h3>
<p>unique_ptr 指定删除器和 shared_ptr 指定删除器是有区别的，unique_ptr 指定删除器的时候需要确定删除器的类型，所以不能像 shared_ptr 那样直接指定删除器，举例说明：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// ok</span></pre></td></tr><tr><td data-num="2"></td><td><pre>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// error</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> func_ptr<span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的代码中第 7 行，func_ptr 的类型和 lambda 表达式的类型是一致的。在 lambda 表达式没有捕获任何变量的情况下是正确的，如果捕获了变量，编译时则会报错：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> func_ptr<span class="token operator">></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// error</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>上面的代码中错误原因是这样的，在 lambda 表达式没有捕获任何外部变量时，可以直接转换为函数指针，一旦捕获了就无法转换了，如果想要让编译器成功通过编译，那么需要使用可调用对象包装器来处理声明的函数指针：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">>></span> <span class="token function">ptr1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><hr>
<h2 id="弱引用智能指针weak_ptr"><a class="markdownIt-Anchor" href="#弱引用智能指针weak_ptr">#</a> 弱引用智能指针（weak_ptr）</h2>
<p>弱引用智能指针 std::weak_ptr 可以看做是 shared_ptr 的助手，它不管理 shared_ptr 内部的指针。std::weak_ptr 没有重载操作符 * 和 -&gt;，因为它不共享指针，不能操作资源，所以它的构造不会增加引用计数，析构也不会减少引用计数，它的主要作用就是作为一个旁观者监视 shared_ptr 中管理的资源是否存在。</p>
<h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化">#</a> 初始化</h3>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 默认构造函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">constexpr</span> <span class="token function">weak_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 拷贝构造</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">weak_ptr</span> <span class="token punctuation">(</span><span class="token keyword">const</span> weak_ptr<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">></span> <span class="token function">weak_ptr</span> <span class="token punctuation">(</span><span class="token keyword">const</span> weak_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 通过 shared_ptr 对象构造</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">></span> <span class="token function">weak_ptr</span> <span class="token punctuation">(</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在 C++11 中，weak_ptr 的初始化可以通过以上提供的构造函数来完成初始化，具体使用方法如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp1<span class="token punctuation">;</span>    	<span class="token comment">// 构造了一个空 weak_ptr 对象</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp2</span><span class="token punctuation">(</span>wp1<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 通过一个空 weak_ptr 对象构造了另一个空 weak_ptr 对象</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp3</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 通过一个 shared_ptr 对象构造了一个可用的 weak_ptr 实例对象</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp4<span class="token punctuation">;</span>		</pre></td></tr><tr><td data-num="13"></td><td><pre>    wp4 <span class="token operator">=</span> sp<span class="token punctuation">;</span>				<span class="token comment">// 隐式类型转换，通过一个 shared_ptr 对象构造了一个可用的 weak_ptr 实例对象</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp5<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    wp5 <span class="token operator">=</span> wp3<span class="token punctuation">;</span>				<span class="token comment">// 通过一个 weak_ptr 对象构造了一个可用的 weak_ptr 实例对象</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    </pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="其他常用方法"><a class="markdownIt-Anchor" href="#其他常用方法">#</a> 其他常用方法</h3>
<h4 id="use_count"><a class="markdownIt-Anchor" href="#use_count">#</a> use_count()</h4>
<p>通过调用 std::weak_ptr 类提供的 use_count () 方法可以获得当前所观测资源的引用计数，函数原型如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 函数返回所监测的资源的引用计数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>修改一下上面的测试程序，添加打印资源引用计数的代码：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp2</span><span class="token punctuation">(</span>wp1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp3</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp4<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    wp4 <span class="token operator">=</span> sp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp5<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    wp5 <span class="token operator">=</span> wp3<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"wp1: "</span> <span class="token operator">&lt;&lt;</span> wp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"wp2: "</span> <span class="token operator">&lt;&lt;</span> wp2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"wp3: "</span> <span class="token operator">&lt;&lt;</span> wp3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"wp4: "</span> <span class="token operator">&lt;&lt;</span> wp4<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"wp5: "</span> <span class="token operator">&lt;&lt;</span> wp5<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment">// 输出：</span></pre></td></tr><tr><td data-num="27"></td><td><pre>use_count<span class="token operator">:</span></pre></td></tr><tr><td data-num="28"></td><td><pre>wp1<span class="token operator">:</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="29"></td><td><pre>wp2<span class="token operator">:</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="30"></td><td><pre>wp3<span class="token operator">:</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="31"></td><td><pre>wp4<span class="token operator">:</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="32"></td><td><pre>wp5<span class="token operator">:</span> <span class="token number">1</span></pre></td></tr></table></figure><p>通过打印的结果可以知道，虽然弱引用智能指针 wp3、wp4、wp5 监测的资源是同一个，但是它的引用计数并没有发生任何的变化，也进一步证明了 weak_ptr 只是监测资源，并不管理资源。</p>
<h4 id="expired"><a class="markdownIt-Anchor" href="#expired">#</a> expired()</h4>
<p>通过调用 std::weak_ptr 类提供的 expired () 方法来判断观测的资源是否已经被释放，函数原型如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 返回 true 表示资源已经被释放，返回 false 表示资源没有被释放</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">bool</span> <span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>函数使用方法如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">shared</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">weak</span><span class="token punctuation">(</span>shared<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"1. weak "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>weak<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"is"</span> <span class="token operator">:</span> <span class="token string">"is not"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" expired"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    shared<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"2. weak "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>weak<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"is"</span> <span class="token operator">:</span> <span class="token string">"is not"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" expired"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment">// 输出：</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token number">1.</span> weak is <span class="token operator">not</span> expired</pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token number">2.</span> weak is expired</pre></td></tr></table></figure><p>weak_ptr 监测的就是 shared_ptr 管理的资源，当共享智能指针调用 shared.reset (); 之后管理的资源被释放，因此 weak.expired () 函数的结果返回 true，表示监测的资源已经不存在了。</p>
<h4 id="lock"><a class="markdownIt-Anchor" href="#lock">#</a> lock()</h4>
<p>通过调用 std::weak_ptr 类提供的 lock () 方法来获取管理所监测资源的 shared_ptr 对象，函数原型如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre>shared_ptr<span class="token operator">&lt;</span>element_type<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>函数的使用方法如下:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sp1<span class="token punctuation">,</span> sp2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> wp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    sp1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    wp <span class="token operator">=</span> sp1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    sp2 <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    sp1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    sp1 <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count: "</span> <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"*sp1: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"*sp2: "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>sp2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token comment">// 输出：</span></pre></td></tr><tr><td data-num="28"></td><td><pre>use_count<span class="token operator">:</span> <span class="token number">2</span></pre></td></tr><tr><td data-num="29"></td><td><pre>use_count<span class="token operator">:</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="30"></td><td><pre>use_count<span class="token operator">:</span> <span class="token number">2</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token operator">*</span>sp1<span class="token operator">:</span> <span class="token number">520</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token operator">*</span>sp2<span class="token operator">:</span> <span class="token number">520</span></pre></td></tr></table></figure><ul>
<li>sp2 = wp.lock (); 通过调用 lock () 方法得到一个用于管理 weak_ptr 对象所监测的资源的共享智能指针对象，使用这个对象初始化 sp2，此时所监测资源的引用计数为 2</li>
<li>sp1.reset (); 共享智能指针 sp1 被重置，weak_ptr 对象所监测的资源的引用计数减 1</li>
<li>sp1 = wp.lock ();sp1 重新被初始化，并且管理的还是 weak_ptr 对象所监测的资源，因此引用计数加 1</li>
<li>共享智能指针对象 sp1 和 sp2 管理的是同一块内存，因此最终打印的内存中的结果是相同的，都是 520</li>
</ul>
<h4 id="reset"><a class="markdownIt-Anchor" href="#reset">#</a> reset()</h4>
<p>通过调用 std::weak_ptr 类提供的 reset () 方法来清空对象，使其不监测任何资源，函数原型如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>函数的使用方法如下:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"1. wp "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>wp<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"is"</span> <span class="token operator">:</span> <span class="token string">"is not"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" expired"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    wp<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"2. wp "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>wp<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"is"</span> <span class="token operator">:</span> <span class="token string">"is not"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" expired"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment">// 输出</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token number">1.</span> wp is <span class="token operator">not</span> expired</pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token number">2.</span> wp is expired</pre></td></tr></table></figure><h3 id="返回管理this的shared_ptr"><a class="markdownIt-Anchor" href="#返回管理this的shared_ptr">#</a> 返回管理 this 的 shared_ptr</h3>
<h3 id="解决循环引用问题"><a class="markdownIt-Anchor" href="#解决循环引用问题">#</a> 解决循环引用问题</h3>
<hr>
<h1 id="多线程"><a class="markdownIt-Anchor" href="#多线程">#</a> 多线程</h1>
<p><code>C++11</code>  之前，C++ 语言没有对并发编程提供语言级别的支持，这使得我们在编写可移植的并发程序时，存在诸多的不便。 <code>C++11</code>  中增加了线程以及线程相关的类，很方便地支持了并发编程，使得编写的多线程程序的可移植性得到了很大的提高。</p>
<h2 id="处理日期和时间的-chrono-库"><a class="markdownIt-Anchor" href="#处理日期和时间的-chrono-库">#</a> 处理日期和时间的 chrono 库</h2>
<p>C++11 中提供了日期和时间相关的库 chrono，通过 chrono 库可以很方便地处理日期和时间，为程序的开发提供了便利。chrono 库主要包含三种类型的类： <code>时间间隔duration</code> 、 <code>时钟clocks</code> 、 <code>时间点time point</code> 。</p>
<h3 id="时间间隔-duration"><a class="markdownIt-Anchor" href="#时间间隔-duration">#</a> 时间间隔 duration</h3>
<p>duration 表示一段时间间隔，用来记录时间长度，可以表示几秒、几分钟、几个小时的时间间隔。</p>
<p><strong>duration 类的原型</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 定义于头文件 &lt;chrono></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">class</span> <span class="token class-name">Rep</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">class</span> <span class="token class-name">Period</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>ratio<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">duration</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li>
<p><code>Rep</code> ：这是一个数值类型，表示时钟数（周期）的类型（默认为整型）。</p>
</li>
<li>
<p><code>Period</code> ：表示时钟的周期，它的原型如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 定义于头文件 &lt;ratio></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    std<span class="token double-colon punctuation">::</span>intmax_t Num<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    std<span class="token double-colon punctuation">::</span>intmax_t Denom <span class="token operator">=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">ratio</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><code>ratio</code>  类表示每个时钟周期的秒数，其中第一个模板参数  <code>Num</code>  代表分子， <code>Denom</code>  代表分母，该分母值默认为 1，因此，<strong>ratio 代表的是一个分子除以分母的数值</strong>，比如：ratio&lt;2&gt; 代表一个时钟周期是 2 秒，ratio&lt;60 &gt; 代表一分钟，ratio&lt;60<em>60&gt; 代表一个小时，ratio&lt;60</em>60*24&gt; 代表一天。而 ratio&lt;1,1000&gt; 代表的是 1/1000 秒，也就是 1 毫秒，ratio&lt;1,1000000 &gt; 代表一微秒，ratio&lt;1,1000000000 &gt; 代表一纳秒。</p>
<p>为了方便使用，在标准库中定义了一些常用的时间间隔，比如：时、分、秒、毫秒、微秒、纳秒，它们都位于 chrono 命名空间下，定义如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>纳秒：std::chrono::nanoseconds</td>
<td>duration&lt;Rep*/* 至少 64 位的有符号整数类型 <em>/</em>, std::nano&gt;</td>
</tr>
<tr>
<td>微秒：std::chrono::microseconds</td>
<td>duration&lt;Rep*/* 至少 55 位的有符号整数类型 <em>/</em>, std::micro&gt;</td>
</tr>
<tr>
<td>毫秒：std::chrono::milliseconds</td>
<td>duration&lt;Rep*/* 至少 45 位的有符号整数类型 <em>/</em>, std::milli&gt;</td>
</tr>
<tr>
<td>秒： std::chrono::seconds</td>
<td>duration&lt;Rep*/* 至少 35 位的有符号整数类型 <em>/</em>&gt;</td>
</tr>
<tr>
<td>分钟：std::chrono::minutes</td>
<td>duration&lt;Rep*/* 至少 29 位的有符号整数类型 <em>/</em>, std::ratio&lt;60&gt;&gt;</td>
</tr>
<tr>
<td>小时：std::chrono::hours</td>
<td>duration&lt;Rep*/* 至少 23 位的有符号整数类型 <em>/</em>, std::ratio&lt;3600&gt;&gt;</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p><strong>duration 类的构造函数</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 1. 拷贝构造函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">duration</span><span class="token punctuation">(</span> <span class="token keyword">const</span> duration<span class="token operator">&amp;</span> <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 2. 通过指定时钟周期的类型来构造对象</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Rep2</span> <span class="token operator">></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">constexpr</span> <span class="token keyword">explicit</span> <span class="token function">duration</span><span class="token punctuation">(</span> <span class="token keyword">const</span> Rep2<span class="token operator">&amp;</span> r <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 3. 通过指定时钟周期类型，和时钟周期长度来构造对象</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Rep2</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Period2</span> <span class="token operator">></span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">constexpr</span> <span class="token function">duration</span><span class="token punctuation">(</span> <span class="token keyword">const</span> duration<span class="token operator">&lt;</span>Rep2<span class="token punctuation">,</span>Period2<span class="token operator">></span><span class="token operator">&amp;</span> d <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>为了更加方便的进行 duration 对象之间的操作，类内部进行了操作符重载：</p>
<table>
<thead>
<tr>
<th>操作符重载</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>operator=</td>
<td>赋值内容 (公开成员函数)</td>
</tr>
<tr>
<td>operator+<br/>operator-</td>
<td>实现一元 + 和一元 - (公开成员函数)</td>
</tr>
<tr>
<td>operator++<br/>operator++(int)<br/>operator–<br/>operator–(int)</td>
<td>递增或递减周期计数 (公开成员函数)</td>
</tr>
<tr>
<td>operator+=<br/>operator-=<br/>operator*=<br/>operator/=<br/>operator%=</td>
<td>实现二个时长间的复合赋值 (公开成员函数)</td>
</tr>
</tbody>
</table>
<p>duration 类还提供了获取时间间隔的时钟周期数的方法 count ()，函数原型如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">constexpr</span> rep <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><strong>duration 类的使用</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    chrono<span class="token double-colon punctuation">::</span>hours <span class="token function">h</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">// 一小时</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    chrono<span class="token double-colon punctuation">::</span>milliseconds ms<span class="token punctuation">&#123;</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                <span class="token comment">// 3 毫秒</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> ratio<span class="token operator">&lt;</span><span class="token number">1000</span><span class="token operator">>></span> <span class="token function">ks</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3000 秒</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// chrono::duration&lt;int, ratio&lt;1000>> d3(3.5);  // error</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">dd</span><span class="token punctuation">(</span><span class="token number">6.6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 6.6 秒</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 使用小数表示时钟周期的次数</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>ratio<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token operator">>></span> <span class="token function">hz</span><span class="token punctuation">(</span><span class="token number">3.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="时间点-time-point"><a class="markdownIt-Anchor" href="#时间点-time-point">#</a> 时间点 time point</h3>
<p>chrono 库中提供了一个表示时间点的类  <code>time_point</code> ，该类的定义如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 定义于头文件 &lt;chrono></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">class</span> <span class="token class-name">Clock</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">class</span> <span class="token class-name">Duration</span> <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">Clock</span><span class="token double-colon punctuation">::</span>duration</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">time_point</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>它被实现成如同存储一个 Duration 类型的自 Clock 的纪元起始开始的时间间隔的值，通过这个类最终可以得到时间中的某一个时间点。</p>
<ul>
<li>Clock：此时间点在此时钟上计量</li>
<li>Duration：用于计量从纪元起时间的 std::chrono::duration 类型</li>
</ul>
<p><strong>time_point 类的构造函数</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 1. 构造一个以新纪元 (epoch，即：1970.1.1) 作为值的对象，需要和时钟类一起使用，不能单独使用该无参构造函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">time_point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 2. 构造一个对象，表示一个时间点，其中 d 的持续时间从 epoch 开始，需要和时钟类一起使用，不能单独使用该构造函数</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">explicit</span> <span class="token function">time_point</span><span class="token punctuation">(</span> <span class="token keyword">const</span> duration<span class="token operator">&amp;</span> d <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 3. 拷贝构造函数，构造与 t 相同时间点的对象，使用的时候需要指定模板参数</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Duration2</span> <span class="token operator">></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">time_point</span><span class="token punctuation">(</span> <span class="token keyword">const</span> time_point<span class="token operator">&lt;</span>Clock<span class="token punctuation">,</span>Duration2<span class="token operator">></span><span class="token operator">&amp;</span> t <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="时钟-clocks"><a class="markdownIt-Anchor" href="#时钟-clocks">#</a> 时钟 clocks</h3>
<p>chrono 库中提供了获取当前的系统时间的时钟类，包含的时钟一共有三种：</p>
<ul>
<li><code>system_clock</code> ：系统的时钟，系统的时钟可以修改，甚至可以网络对时，因此使用系统时间计算时间差可能不准。</li>
<li><code>steady_clock</code> ：是固定的时钟，相当于秒表。开始计时后，时间只会增长并且不能修改，适合用于记录程序耗时</li>
<li><code>high_resolution_clock</code> ：和时钟类  <code>steady_clock</code>  是等价的（是它的别名）。</li>
</ul>
<p>在这些时钟类的内部有  <code>time_point</code> 、 <code>duration</code> 、 <code>Rep</code> 、 <code>Period</code>  等信息，基于这些信息来获取当前时间，以及实现  <code>time_t</code>  和  <code>time_point</code>  之间的相互转换。</p>
<h4 id="system_clock"><a class="markdownIt-Anchor" href="#system_clock">#</a> system_clock</h4>
<h4 id="steady_clock"><a class="markdownIt-Anchor" href="#steady_clock">#</a> steady_clock</h4>
<h4 id="high_resolution_clock"><a class="markdownIt-Anchor" href="#high_resolution_clock">#</a> high_resolution_clock</h4>
<h3 id="转换函数"><a class="markdownIt-Anchor" href="#转换函数">#</a> 转换函数</h3>
<h4 id="duration_cast"><a class="markdownIt-Anchor" href="#duration_cast">#</a> duration_cast</h4>
<h4 id="time_point_cast"><a class="markdownIt-Anchor" href="#time_point_cast">#</a> time_point_cast</h4>
<hr>
<h2 id="线程类-thread"><a class="markdownIt-Anchor" href="#线程类-thread">#</a> 线程类 thread</h2>
<p>C++11 中提供的线程类叫做  <code>std::thread</code> ，基于这个类创建一个新的线程非常的简单，只需要提供线程函数或者函数对象即可，并且可以同时指定线程函数的参数。这个类提供的一些常用 API：</p>
<h3 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数">#</a> 构造函数</h3>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 默认构造函，构造一个线程对象，在这个线程中不执行任何处理动作</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 移动构造函数，将 other 的线程所有权转移给新的 thread 对象。之后 other 不再表示执行线程。</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">thread</span><span class="token punctuation">(</span> thread<span class="token operator">&amp;&amp;</span> other <span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 创建线程对象，并在该线程中执行函数 f 中的业务逻辑，args 是要传递给函数 f 的参数。任务函数 f 的可选类型有很多，普通函数，类成员函数，匿名函数，仿函数</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Function</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args <span class="token operator">></span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">explicit</span> <span class="token function">thread</span><span class="token punctuation">(</span> Function<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// 使用 =delete 显示删除拷贝构造，不允许线程对象之间的拷贝</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token function">thread</span><span class="token punctuation">(</span> <span class="token keyword">const</span> thread<span class="token operator">&amp;</span> <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="公共成员函数"><a class="markdownIt-Anchor" href="#公共成员函数">#</a> 公共成员函数</h3>
<h3 id="get_id"><a class="markdownIt-Anchor" href="#get_id">#</a> get_id()</h3>
<p>应用程序启动之后默认只有一个线程，这个线程一般称之为<strong>主线程或父线程</strong>，通过线程类创建出的线程一般称之为<strong>子线程</strong>，每个被创建出的线程实例都对应一个线程 ID，这个 ID 是唯一的，可以通过这个 ID 来区分和识别各个已经存在的线程实例，这个获取线程 ID 的函数叫做  <code>get_id()</code> ，函数原型如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token double-colon punctuation">::</span>thread<span class="token double-colon punctuation">::</span>id <span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>示例程序：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> string str<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"子线程: i = "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"num: "</span> </pre></td></tr><tr><td data-num="11"></td><td><pre>             <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> <span class="token string">", str: "</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"子线程: i = "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"主线程的线程ID: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    thread <span class="token function">t</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> <span class="token number">520</span><span class="token punctuation">,</span> <span class="token string">"i love you"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    thread <span class="token function">t1</span><span class="token punctuation">(</span>func1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程t 的线程ID: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程t1的线程ID: "</span> <span class="token operator">&lt;&lt;</span> t1<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote>
<p>在上面的示例程序中有一个 bug，在主线程中依次创建出两个子线程，打印两个子线程的线程 ID，最后主线程执行完毕就退出了（主线程就是执行 main () 函数的那个线程）。默认情况下，主线程销毁时会将与其关联的两个子线程也一并销毁，但是这时有可能子线程中的任务还没有执行完毕，最后也就得不到我们想要的结果了。</p>
</blockquote>
<p>当启动了一个线程（创建了一个 thread 对象）之后，在这个线程结束的时候 <code>std::terminate ()</code> ，我们如何去回收线程所使用的资源呢？thread 库给我们两种选择：</p>
<ul>
<li>加入式 <code>join()</code></li>
<li>分离式 <code>detach()</code></li>
</ul>
<p>另外，我们必须要在线程对象销毁之前在二者之间作出选择，否则程序运行期间就会有 bug 产生。</p>
<h3 id="join"><a class="markdownIt-Anchor" href="#join">#</a> join()</h3>
<p><code>join()</code>  字面意思是连接一个线程，意味着主动地等待线程的终止（线程阻塞）。在某个线程中通过子线程对象调用  <code>join()</code>  函数，调用这个函数的线程被阻塞，但是子线程对象中的任务函数会继续执行，当任务执行完毕之后  <code>join()</code>  会清理当前子线程中的相关资源然后返回，同时，调用该函数的线程解除阻塞继续向下执行。</p>
<p>再次强调，我们一定要搞清楚这个函数阻塞的是哪一个线程，函数在哪个线程中被执行，那么函数就阻塞哪个线程。该函数的函数原型如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>有了这样一个线程阻塞函数之后，就可以解决在上面测试程序中的 bug 了，** 如果要阻塞主线程的执行，只需要在主线程中通过子线程对象调用这个方法即可，当调用这个方法的子线程对象中的任务函数执行完毕之后，主线程的阻塞也就随之解除了。** 修改之后的示例代码如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"主线程的线程ID: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    thread <span class="token function">t</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> <span class="token number">520</span><span class="token punctuation">,</span> <span class="token string">"i love you"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    thread <span class="token function">t1</span><span class="token punctuation">(</span>func1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程t 的线程ID: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程t1的线程ID: "</span> <span class="token operator">&lt;&lt;</span> t1<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>当主线程运行到第八行 t.join ();，根据子线程对象 t 的任务函数 func () 的执行情况，主线程会做如下处理：</p>
<ul>
<li>如果任务函数 func () 还没执行完毕，主线程阻塞，直到任务执行完毕，主线程解除阻塞，继续向下运行</li>
<li>如果任务函数 func () 已经执行完毕，主线程不会阻塞，继续向下运行</li>
</ul>
<p>同样，第 9 行的代码亦如此。</p>
<h3 id="detach"><a class="markdownIt-Anchor" href="#detach">#</a> detach()</h3>
<p><code>detach()</code>  函数的作用是进行线程分离，分离主线程和创建出的子线程。在线程分离之后，主线程退出也会一并销毁创建出的所有子线程，在主线程退出之前，它可以脱离主线程继续独立的运行，任务执行完毕之后，这个子线程会自动释放自己占用的系统资源。该函数函数原型如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>线程分离函数没有参数也没有返回值，只需要在线程成功之后，通过线程对象调用该函数即可，继续将上面的测试程序修改一下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"主线程的线程ID: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    thread <span class="token function">t</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> <span class="token number">520</span><span class="token punctuation">,</span> <span class="token string">"i love you"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    thread <span class="token function">t1</span><span class="token punctuation">(</span>func1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程t 的线程ID: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程t1的线程ID: "</span> <span class="token operator">&lt;&lt;</span> t1<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    t1<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 让主线程休眠，等待子线程执行完毕</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote>
<p>注意事项：线程分离函数 detach () 不会阻塞线程，子线程和主线程分离之后，在主线程中就不能再对这个子线程做任何控制了，比如：通过 join () 阻塞主线程等待子线程中的任务执行完毕，或者调用 get_id () 获取子线程的线程 ID。有利就有弊，鱼和熊掌不可兼得，建议使用 join ()。</p>
</blockquote>
<h3 id="joinable"><a class="markdownIt-Anchor" href="#joinable">#</a> joinable()</h3>
<p>joinable () 函数用于判断主线程和子线程是否处理关联（连接）状态，一般情况下，二者之间的关系处于关联状态，该函数返回一个布尔类型：</p>
<ul>
<li>返回值为 true：主线程和子线程之间有关联（连接）关系</li>
<li>返回值为 false：主线程和子线程之间没有关联（连接）关系<br>
 C++</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">bool</span> <span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="operator"><a class="markdownIt-Anchor" href="#operator">#</a> operator=</h3>
<p><strong>线程中的资源是不能被复制的</strong>，因此通过 = 操作符进行赋值操作最终并不会得到两个完全相同的对象。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// move (1)	</span></pre></td></tr><tr><td data-num="2"></td><td><pre>thread<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>thread<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// copy [deleted] (2)	</span></pre></td></tr><tr><td data-num="4"></td><td><pre>thread<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> other<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>通过以上 = 操作符的重载声明可以得知：</p>
<ul>
<li>如果 other 是一个右值，会进行资源所有权的转移</li>
<li>如果 other 不是右值，禁止拷贝，该函数被显示删除（=delete），不可用</li>
</ul>
<h3 id="静态函数"><a class="markdownIt-Anchor" href="#静态函数">#</a> 静态函数</h3>
<p>thread 线程类还提供了一个静态方法，用于<strong>获取当前计算机的 CPU 核心数</strong>，根据这个结果在程序中创建出数量相等的线程，<strong>每个线程独自占有一个 CPU 核心，这些线程就不用分时复用 CPU 时间片，此时程序的并发效率是最高的。</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">int</span> num <span class="token operator">=</span> thread<span class="token double-colon punctuation">::</span><span class="token function">hardware_concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CPU number: "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><hr>
<h2 id="线程命名空间-this_thread"><a class="markdownIt-Anchor" href="#线程命名空间-this_thread">#</a> 线程命名空间 this_thread</h2>
<hr>
<h2 id="call_once-函数"><a class="markdownIt-Anchor" href="#call_once-函数">#</a> call_once 函数</h2>
<hr>
<h2 id="线程同步之互斥锁-mutex"><a class="markdownIt-Anchor" href="#线程同步之互斥锁-mutex">#</a> 线程同步之互斥锁 mutex</h2>
<hr>
<h2 id="线程同步之条件变量"><a class="markdownIt-Anchor" href="#线程同步之条件变量">#</a> 线程同步之条件变量</h2>
<hr>
<h2 id="线程同步之原子变量-atomic"><a class="markdownIt-Anchor" href="#线程同步之原子变量-atomic">#</a> 线程同步之原子变量 atomic</h2>
<hr>
<h2 id="线程异步"><a class="markdownIt-Anchor" href="#线程异步">#</a> 线程异步</h2>
<hr>
<h1 id="易学和易用性"><a class="markdownIt-Anchor" href="#易学和易用性">#</a> 易学和易用性</h1>
<h2 id="lambda表达式"><a class="markdownIt-Anchor" href="#lambda表达式">#</a> lambda 表达式</h2>
<h3 id="基本用法"><a class="markdownIt-Anchor" href="#基本用法">#</a> 基本用法</h3>
<p>lambda 表达式是 C++11 最重要也是最常用的特性之一，这是现代编程语言的一个特点，lambda 表达式有以下优点：</p>
<ul>
<li>声明式的编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象。</li>
<li>简洁：避免了代码膨胀和功能分散，让开发更加高效。</li>
<li>在需要的时间和地点实现功能闭包，让程序更加灵活。</li>
</ul>
<p>lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式简单，归纳如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>capture<span class="token punctuation">]</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> opt <span class="token operator">-></span> ret <span class="token punctuation">&#123;</span>body<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>其中 <code>capture</code>  是捕获列表， <code>params</code>  是参数列表， <code>opt</code>  是函数选项， <code>ret</code>  是返回值类型， <code>body</code>  是函数体。</p>
<ol>
<li>
<p>捕获列表 [ ]：捕获一定范围内的变量</p>
</li>
<li>
<p>参数列表 ( )：和普通函数的参数列表一样，如果没有参数，参数列表可以省略不写。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>	<span class="token comment">// 没有参数，参数列表为空</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>		<span class="token comment">// 没有参数，参数列表省略不写</span></pre></td></tr></table></figure></li>
<li>
<p>opt 选项，不需要可以省略</p>
<ul>
<li>mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</li>
<li>exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw ();</li>
</ul>
</li>
<li>
<p>ret 返回值类型：在 C++11 中，lambda 表达式的返回值是通过返回值后置语法来定义的。</p>
</li>
<li>
<p>函数体：函数的实现，这部分不能省略，但函数体可以为空。</p>
</li>
</ol>
<h3 id="捕获列表"><a class="markdownIt-Anchor" href="#捕获列表">#</a> 捕获列表</h3>
<p>lambda 表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：</p>
<ul>
<li><code>[]</code>  - 不捕捉任何变量</li>
<li><code>[&amp;]</code>  - 捕获外部作用域中所有变量，并作为引用在函数体内使用 (<strong>按引用捕获</strong>)</li>
<li><code>[=]</code>  - 捕获外部作用域中所有变量，并作为副本在函数体内使用 (<strong>按值捕获</strong>)
<ul>
<li><strong>拷贝的副本在匿名函数体内部是只读的</strong></li>
</ul>
</li>
<li><code>[=, &amp;foo]</code>  - 按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo</li>
<li><code>[bar]</code>  - 按值捕获 bar 变量，同时不捕获其他变量</li>
<li><code>[&amp;bar]</code>  - 按引用捕获 bar 变量，同时不捕获其他变量</li>
<li><code>[this]</code>  - 捕获当前类中的 this 指针
<ul>
<li>让 lambda 表达式拥有和当前类成员函数同样的访问权限</li>
<li>如果已经使用了 &amp; 或者 =, 默认添加此选项</li>
</ul>
</li>
</ul>
<p>实例：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Test</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">auto</span> x1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                      <span class="token comment">// error</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">auto</span> x2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number <span class="token operator">+</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>             <span class="token comment">// ok</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">auto</span> x3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number <span class="token operator">+</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>             <span class="token comment">// ok</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">auto</span> x4 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                  <span class="token comment">// ok</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">auto</span> x5 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number <span class="token operator">+</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>          <span class="token comment">// error</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">auto</span> x6 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number <span class="token operator">+</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// ok</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">auto</span> x7 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> m_number<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                <span class="token comment">// ok</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">int</span> m_number <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li>x1：错误，没有捕获外部变量，不能使用类成员 m_number</li>
<li>x2：正确，以值拷贝的方式捕获所有外部变量</li>
<li>x3：正确，以引用的方式捕获所有外部变量</li>
<li>x4：正确，捕获 this 指针，可访问对象内部成员</li>
<li>x5：错误，捕获 this 指针，可访问类内部成员，没有捕获到变量 x，y，因此不能访问。</li>
<li>x6：正确，捕获 this 指针，x，y</li>
<li>x7：正确，捕获 this 指针，并且可以修改对象内部变量的值</li>
</ul>
<blockquote>
<p>在匿名函数内部，需要<strong>通过 lambda 表达式的捕获列表控制如何捕获外部变量，以及访问哪些变量</strong>。默认状态下 lambda 表达式无法修改通过复制方式捕获外部变量，如果希望修改这些外部变量，需要通过引用的方式进行捕获。</p>
</blockquote>
<h3 id="返回值"><a class="markdownIt-Anchor" href="#返回值">#</a> 返回值</h3>
<p>一般情况，lambda 表达式的返回值是非常明显的，因此在 C++11 中允许省略 lambda 表达式的返回值。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 完整的 lambda 表达式定义</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">int</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> a<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 忽略返回值的 lambda 表达式定义</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> a<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>一般情况，不指定 lambda 表达式的返回值，编译器会根据 return 语句自动推导返回值的类型，但需要注意的是 <strong>labmda 表达式不能通过列表初始化自动推导出返回值类型</strong>。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//ok，可以自动推导出返回值类型</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">//error，不能推导出返回值类型</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">auto</span> f1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>	<span class="token comment">// 基于列表初始化推导返回值，错误</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="函数本质"><a class="markdownIt-Anchor" href="#函数本质">#</a> 函数本质</h3>
<p>使用  <code>lambda 表达式捕获列表</code> 捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用 mutable 选项，<strong>被 mutable 修改时 lambda 表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性</strong>。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">auto</span> f1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>              <span class="token comment">//error, 按值捕获外部变量，a 是只读的</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">auto</span> f2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     <span class="token comment">// ok</span></pre></td></tr></table></figure><p>为什么通过值拷贝的方式捕获的外部变量是只读的:</p>
<ul>
<li><strong>lambda 表达式的类型在 C++11 中会被看做是一个带 operator () 的类，即仿函数。</strong></li>
<li><strong>按照 C++ 标准，lambda 表达式的 operator () 默认是 const 的，一个 const 成员函数是无法修改成员变量值的。</strong></li>
</ul>
<p><strong>mutable 选项的作用就在于取消 operator () 的 const 属性。</strong></p>
<p>因为 lambda 表达式在 C++ 中会被看做是一个仿函数，因此可以使用 <code>std::function</code>  和 <code>std::bind</code>  来存储和操作 lambda 表达式：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 包装可调用函数</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 绑定可调用函数</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> f2 <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 函数调用</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>对于没有捕获任何变量的 lambda 表达式，还可以转换成一个普通的函数指针：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">using</span> func_ptr <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 没有捕获任何外部变量的匿名函数</span></pre></td></tr><tr><td data-num="3"></td><td><pre>func_ptr f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">return</span> a<span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 函数调用</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1314</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><hr>
<h2 id="指针空值类型-nullptr"><a class="markdownIt-Anchor" href="#指针空值类型-nullptr">#</a> 指针空值类型 - nullptr</h2>
<p>在 C++ 程序开发中，为了提高程序的健壮性，一般会在定义指针的同时完成初始化操作，或者在指针的指向尚未明确的情况下，都会给指针初始化为  <code>NULL</code> ，<strong>避免产生野指针（没有明确指向的指针，操作也这种指针极可能导致程序发生异常）</strong>。 <code>C++98/03</code>  标准中，将一个指针初始化为空指针的方式有 2 种：</p>
<ul>
<li><code>char *ptr = 0;</code></li>
<li><code>char *ptr = NULL;</code></li>
</ul>
<p>在底层源码中 NULL 这个宏是这样定义的:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression"><span class="token constant">NULL</span></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr></table></figure><p>也就是说如果源码是 C++ 程序  <code>NULL</code>  就是  <code>0</code> ，如果是 C 程序  <code>NULL</code>  表示  <code>(void*)0</code> 。</p>
<p>那么为什么要这样做呢？ 是由于 C++ 中， <code>void *</code>  类型无法隐式转换为其他类型的指针，此时使用  <code>0</code>  代替  <code>((void *)0)</code> ，用于解决空指针的问题。这个 0（0x0000 0000）表示的就是虚拟地址空间中的 0 地址，这块地址是只读的。</p>
<p>C++ 中将 NULL 定义为字面常量 0，并不能保证在所有场景下都能很好的工作，比如，函数重载时， <code>NULL</code>  和  <code>0</code>  无法区分：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"void func(char *p)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"void func(int p)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 想要调用重载函数 void func (char *p)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 想要调用重载函数 void func (int p)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">// 测试结果</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span></pre></td></tr></table></figure><p>通过打印的结果可以看到，虽然调用  <code>func(NULL)</code> ; 最终链接到的还是  <code>void func(int p)</code>  和预期是不一样的，其实这个原因前边已经说的很明白了，在 C++ 中  <code>NULL</code>  和  <code>0</code>  是等价的。</p>
<p>出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改，而是另其炉灶，引入了一个新的关键字  <code>nullptr</code> 。<strong>nullptr 专用于初始化空类型指针，不同类型的指针变量都可以使用 nullptr 来初始化</strong>：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span><span class="token operator">*</span>    ptr1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">char</span><span class="token operator">*</span>   ptr2 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">double</span><span class="token operator">*</span> ptr3 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>对应上面的代码编译器会分别将 nullptr 隐式转换成 int*、char* 以及 double* 指针类型。</p>
<p>使用 nullptr 可以很完美的解决上边提到的函数重载问题:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"void func(char *p)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"void func(int p)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">// 测试结果</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span></pre></td></tr></table></figure><p>通过输出的结果可以看出， <code>nullptr</code>  无法隐式转换为整形，但是<strong>可以隐式匹配指针类型</strong>。<strong>在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。</strong></p>
<hr>
<h2 id="自动类型推导"><a class="markdownIt-Anchor" href="#自动类型推导">#</a> 自动类型推导</h2>
<p>在 C++11 中增加了很多新的特性，比如可以使用  <code>auto</code>  自动推导变量的类型，还能够结合  <code>decltype</code>  来表示函数的返回值。使用新的特性可以让我们写出更加简洁，更加现代的代码。</p>
<h3 id="auto"><a class="markdownIt-Anchor" href="#auto">#</a> auto</h3>
<p>在 C++11 之前 auto 和 static 是对应的，表示变量是自动存储的，但是非 static 的局部变量默认都是自动存储的，因此这个关键字变得非常鸡肋。</p>
<p>在 C++11 中他们赋予了新的含义，使用这个关键字能够像别的语言一样自动推导出变量的实际类型。</p>
<ol>
<li>推导规则</li>
</ol>
<h3 id="decltype"><a class="markdownIt-Anchor" href="#decltype">#</a> decltype</h3>
<p>在某些情况下，不需要或者不能定义变量，但是希望得到某种类型，这时候就可以使用 C++11 提供的 decltype 关键字了，它的作用是在编译器编译的时候推导出一个表达式的类型，语法格式如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">decltype</span> <span class="token punctuation">(</span>表达式<span class="token punctuation">)</span></pre></td></tr></table></figure><p>decltype 是 “declare type” 的缩写，意思是 “声明类型”。decltype 的推导是在编译期完成的，它只是用于表达式类型的推导，并不会计算表达式的值。来看一组简单的例子：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> b <span class="token operator">=</span> <span class="token number">99</span><span class="token punctuation">;</span>                 <span class="token comment">// b -> int</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token operator">+</span><span class="token number">3.14</span><span class="token punctuation">)</span> c <span class="token operator">=</span> <span class="token number">52.13</span><span class="token punctuation">;</span>         <span class="token comment">// c -> double</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token operator">*</span>c<span class="token punctuation">)</span> d <span class="token operator">=</span> <span class="token number">520.1314</span><span class="token punctuation">;</span>       <span class="token comment">// d -> double</span></pre></td></tr></table></figure><p>可以看到 decltype 推导的表达式可简单可复杂，在这一点上 auto 是做不到的，auto 只能推导已初始化的变量类型。</p>
<h3 id="c14-函数返回类型推导"><a class="markdownIt-Anchor" href="#c14-函数返回类型推导">#</a> c++14 函数返回类型推导</h3>
<p>C<ins>11 允许 lambda 函数根据 return 语句的表达式类型推断返回类型。C</ins>14 为一般的函数也提供了这个能力。C++14 还拓展了原有的规则，使得函数体并不是 {return expression;} 形式的函数也可以使用返回类型推导。</p>
<p>为了启用返回类型推导，函数声明必须将 auto 作为返回类型，但没有 C++11 的后置返回类型说明符：</p>
<p>auto DeduceReturnType (); // 返回类型由编译器推断<br>
如果函数实现中含有多个 return 语句，这些表达式必须可以推断为相同的类型。[9]</p>
<p>使用返回类型推导的函数可以前向声明，但在定义之前不可以使用。它们的定义在使用它们的翻译单元（translation unit）之中必须是可用的。</p>
<p>这样的函数中可以存在递归，但递归调用必须在函数定义中的至少一个 return 语句之后：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">auto</span> <span class="token function">Correct</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>		<span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token comment">// 返回类型被推断为 int</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">else</span></pre></td></tr><tr><td data-num="6"></td><td><pre>		<span class="token keyword">return</span> <span class="token function">Correct</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token punctuation">;</span> <span class="token comment">// 正确，可以调用</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">auto</span> <span class="token function">Wrong</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>		<span class="token keyword">return</span> <span class="token function">Wrong</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token punctuation">;</span> <span class="token comment">// 不能调用，之前没有 return 语句</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token keyword">else</span></pre></td></tr><tr><td data-num="14"></td><td><pre>		<span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token comment">// 返回类型被推断为 int</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="c17-auto表达式"><a class="markdownIt-Anchor" href="#c17-auto表达式">#</a> c++17 auto 表达式</h3>
<hr>
<h2 id="基于范围的-for-循环"><a class="markdownIt-Anchor" href="#基于范围的-for-循环">#</a> 基于范围的 for 循环</h2>
<p>在  <code>C++98/03</code>  中，不同的容器和数组遍历的方式不尽相同，写法不统一，也不够简洁，而  <code>C++11</code>  基于范围的 for 循环可以以简洁、统一的方式来遍历容器和数组，用起来也更方便。</p>
<h3 id="for循环新语法"><a class="markdownIt-Anchor" href="#for循环新语法">#</a> for 循环新语法</h3>
<p>传统 for 循环使用迭代器遍历容器：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> t<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> t<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    </pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们在遍历的过程中需要给出容器的两端：开头（begin）和结尾（end），因为这种遍历方式不是基于范围来设计的。在<strong>基于范围的 for 循环中</strong>，不需要再传递容器的两端，循环会自动以容器为范围展开，并且循环中也屏蔽掉了迭代器的遍历细节，直接抽取容器中的元素进行运算，使用这种方式进行循环遍历会让编码和维护变得更加简便。</p>
<p>C++98/03 中普通的 for 循环，语法格式：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span>表达式 <span class="token number">1</span><span class="token punctuation">;</span> 表达式 <span class="token number">2</span><span class="token punctuation">;</span> 表达式 <span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 循环体</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>C++11 基于范围的 for 循环，语法格式：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span>declaration <span class="token operator">:</span> expression<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 循环体</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的语法格式中  <code>declaration</code>  表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中。 <code>expression</code>  是要遍历的对象，它可以是<strong>表达式</strong>、<strong>容器</strong>、<strong>数组</strong>、<strong>初始化列表</strong>等。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> t<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> value <span class="token operator">:</span> t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote>
<p>在上面的例子中，是将容器中遍历的当前元素拷贝到了声明的变量 value 中，因此无法对容器中的元素进行写操作，如果需要在遍历过程中修改元素的值，需要使用引用。</p>
</blockquote>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> t<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"遍历修改之前的容器: "</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>value <span class="token operator">:</span> t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> value<span class="token operator">++</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> <span class="token string">"遍历修改之后的容器: "</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>value <span class="token operator">:</span> t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token comment">// 输出：</span></pre></td></tr><tr><td data-num="24"></td><td><pre>遍历修改之前的容器<span class="token operator">:</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span></pre></td></tr><tr><td data-num="25"></td><td><pre>遍历修改之后的容器<span class="token operator">:</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span></pre></td></tr></table></figure><p>对容器的遍历过程中，如果只是读数据，不允许修改元素的值，可以使用  <code>const</code>  定义保存元素数据的变量，在定义的时候建议使用  <code>const auto &amp;</code> ，这样相对于  <code>const auto</code>  效率要更高一些。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> t<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> value <span class="token operator">:</span> t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="使用细节"><a class="markdownIt-Anchor" href="#使用细节">#</a> 使用细节</h3>
<p><strong>关系型容器 map 的遍历：</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> m<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"lucy"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"lily"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"tom"</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 基于范围的 for 循环方式</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> it <span class="token operator">:</span> m<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"id: "</span> <span class="token operator">&lt;&lt;</span> it<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">", name: "</span> <span class="token operator">&lt;&lt;</span> it<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">// 普通的 for 循环方式</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> m<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"id: "</span> <span class="token operator">&lt;&lt;</span> it<span class="token operator">-></span>first <span class="token operator">&lt;&lt;</span> <span class="token string">", name: "</span> <span class="token operator">&lt;&lt;</span> it<span class="token operator">-></span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的例子中使用两种方式对 map 进行了遍历，通过对比有两点需要注意的事项：</p>
<ul>
<li>使用普通的 for 循环方式（基于迭代器）遍历关联性容器， auto 自动推导出的是一个<strong>迭代器类型</strong>，需要使用迭代器的方式取出元素中的键值对（和指针的操作方法相同）：
<ul>
<li>it-&gt;first</li>
<li>it-&gt;second</li>
</ul>
</li>
<li>使用基于范围的 for 循环遍历关联性容器，auto 自动推导出的类型是容器中的 value_type，相当于一个对组（std::pair）对象，提取键值对的方式如下：
<ul>
<li>it.first</li>
<li>it.second</li>
</ul>
</li>
</ul>
<p><strong>元素只读：</strong></p>
<p>通过对基于范围的 for 循环语法的介绍可以得知，在 for 循环内部声明一个变量的引用就可以修改遍历的表达式中的元素的值，但是这并不适用于所有的情况，对应 set 容器来说，内部元素都是只读的，这是由容器的特性决定的，因此在 for 循环中  <code>auto &amp;</code>  会被视为  <code>const auto &amp;</code>  。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;set></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>item <span class="token operator">:</span> st<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> item<span class="token operator">++</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>		<span class="token comment">//error, 不能给常量赋值</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>除此之外，<strong>在遍历关联型容器时也会出现同样的问题，基于范围的 for 循环中，虽然可以得到一个 std::pair 引用，但是我们是不能修改里边的 first 值的，也就是 key 值。</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> m<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"lucy"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"lily"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"tom"</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> item <span class="token operator">:</span> m<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">//item.first 是一个常量</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"id: "</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span>first<span class="token operator">++</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", name: "</span> <span class="token operator">&lt;&lt;</span> item<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// error</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote>
<p>对应基于范围的 for 循环来说，冒号后边的表达式只会被执行一次。在得到遍历对象之后会先确定好迭代的范围，基于这个范围直接进行遍历。如果是普通的 for 循环，在每次迭代的时候都需要判断是否已经到了结束边界。</p>
</blockquote>
<h1 id="通用性能提升"><a class="markdownIt-Anchor" href="#通用性能提升">#</a> 通用性能提升</h1>
<h2 id="右值引用"><a class="markdownIt-Anchor" href="#右值引用">#</a> 右值引用</h2>
<h3 id="左值-右值"><a class="markdownIt-Anchor" href="#左值-右值">#</a> 左值、右值</h3>
<p>C++11 增加了一个新的类型，称为<strong>右值引用（ R-value reference）</strong>，标记为  <code>&amp;&amp;</code> 。在介绍右值引用类型之前先要了解什么是左值和右值：</p>
<ul>
<li>lvalue 是  <code>loactor value</code>  的缩写，rvalue 是  <code>read value</code>  的缩写</li>
<li><strong>左值是指存储在内存中、有明确存储地址（可取地址）的数据；</strong></li>
<li><strong>右值是指可以提供数据值的数据（不可取地址）；</strong></li>
</ul>
<p>通过描述可以看出，区分左值与右值的便捷方法是：<strong>可以对表达式取地址（&amp;）就是左值，否则为右值</strong>。所有有名字的变量或对象都是左值，而右值是匿名的。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1314</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>a <span class="token operator">=</span> b<span class="token punctuation">;</span></pre></td></tr></table></figure><p>一般情况下，位于  <code>=</code>  前的表达式为左值，位于  <code>=</code>  后边的表达式为右值。也就是说例子中的  <code>a, b</code>  为左值， <code>520,1314</code>  为右值。 <code>a=b</code>  是一种特殊情况，在这个表达式中  <code>a, b</code>  都是左值，因为变量  <code>b</code>  是可以被取地址的，不能视为右值</p>
<h3 id="纯右值-将亡值"><a class="markdownIt-Anchor" href="#纯右值-将亡值">#</a> 纯右值、将亡值</h3>
<p>C++11 中右值可以分为两种：一个是将亡值（ xvalue, expiring value），另一个则是纯右值（ prvalue, PureRvalue**）**：</p>
<ul>
<li><strong>纯右值：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等</strong></li>
<li><strong>将亡值：与右值引用相关的表达式，比如，T&amp;&amp; 类型函数的返回值、 std::move 的返回值等。</strong></li>
</ul>
<h3 id="右值引用-2"><a class="markdownIt-Anchor" href="#右值引用-2">#</a> 右值引用</h3>
<p>右值引用就是对一个右值进行引用的类型。因为右值是匿名的，所以我们只能通过引用的方式找到它。** 无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。** 通过右值引用的声明，该右值又 “重获新生”，其生命周期与右值引用类型变量的生命周期一样，只要该变量还活着，该右值临时量将会一直存活下去。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> value <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Test</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"construct: my name is jerry"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test<span class="token operator">&amp;</span> a<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"copy construct: my name is tom"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>Test <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">int</span> a1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> a2 <span class="token operator">=</span> a1<span class="token punctuation">;</span>        <span class="token comment">// error</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    Test<span class="token operator">&amp;</span> t <span class="token operator">=</span> <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// error</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    Test<span class="token operator">&amp;&amp;</span> t <span class="token operator">=</span> <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">const</span> Test<span class="token operator">&amp;</span> t <span class="token operator">=</span> <span class="token function">getObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul>
<li>该例中 <code>int&amp;&amp; value = 520;</code>  里面 <code>520</code>  是纯右值， <code>value</code>  是对 <code>520</code>  这个右值的引用；</li>
<li>在  <code>int &amp;&amp;a2 = a1;</code>  中  <code>a1</code>  虽然写在了  <code>=</code>  右边，但是它仍然是一个左值，<strong>使用左值初始化一个右值引用类型是不合法的。</strong></li>
<li>在  <code>Test&amp; t = getObj()</code>  这句代码中语法是错误的，<strong>右值不能给普通的左值引用赋值。</strong></li>
<li>在  <code>Test&amp;&amp; t = getObj();</code>  中  <code>getObj()</code>  返回的临时对象被称之为将亡值， <code>t</code>  是这个将亡值的右值引用。</li>
<li><code>const Test&amp; t = getObj()</code>  这句代码的语法是正确的，<strong>常量左值引用是一个万能引用类型，它可以接受左值、右值、常量左值和常量右值。</strong></li>
</ul>
<h3 id="性能优化"><a class="markdownIt-Anchor" href="#性能优化">#</a> 性能优化</h3>
<hr>
<h2 id="转移和完美转发"><a class="markdownIt-Anchor" href="#转移和完美转发">#</a> 转移和完美转发</h2>
<h3 id="move"><a class="markdownIt-Anchor" href="#move">#</a> move</h3>
<p>在 C++11 添加了右值引用，并且不能使用左值初始化右值引用，如果想要使用左值初始化一个右值引用需要借助  <code>std::move ()</code>  函数，<strong>使用 std::move 方法可以将左值转换为右值。使用这个函数并不能移动任何东西，而是和移动构造函数一样都具有移动语义，将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝。</strong></p>
<p>从实现上讲，std::move 基本等同于一个类型转换： <code>static_cast&lt;T&amp;&amp;&gt;(lvalue);</code> ，函数原型如下:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Ty</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre>_NODISCARD <span class="token keyword">constexpr</span> remove_reference_t<span class="token operator">&lt;</span>_Ty<span class="token operator">></span><span class="token operator">&amp;&amp;</span> <span class="token function">move</span><span class="token punctuation">(</span>_Ty<span class="token operator">&amp;&amp;</span> _Arg<span class="token punctuation">)</span> _NOEXCEPT</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span>	<span class="token comment">// forward _Arg as movable</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>remove_reference_t<span class="token operator">&lt;</span>_Ty<span class="token operator">></span><span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>_Arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>使用方法：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Test</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span>：</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    Test t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    Test <span class="token operator">&amp;&amp;</span> v1 <span class="token operator">=</span> t<span class="token punctuation">;</span>          <span class="token comment">// error</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    Test <span class="token operator">&amp;&amp;</span> v2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ok</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul>
<li>在第 4 行中，使用左值初始化右值引用，因此语法是错误的</li>
<li>在第 5 行中，使用 move () 函数将左值转换为了右值，这样就可以初始化右值引用了。</li>
</ul>
<p>假设一个临时容器很大，并且需要将这个容器赋值给另一个容器，就可以执行如下操作：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>list<span class="token operator">&lt;</span>string<span class="token operator">></span> ls<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>ls<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>ls<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre>list<span class="token operator">&lt;</span>string<span class="token operator">></span> ls1 <span class="token operator">=</span> ls<span class="token punctuation">;</span>        <span class="token comment">// 需要拷贝，效率低</span></pre></td></tr><tr><td data-num="6"></td><td><pre>list<span class="token operator">&lt;</span>string<span class="token operator">></span> ls2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>ls<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果不使用 std::move，拷贝的代价很大，性能较低。使用 move 几乎没有任何代价，只是转换了资源的所有权。如果一个对象内部有较大的堆内存或者动态数组时，使用  <code>move ()</code>  就可以非常方便的进行数据所有权的转移。另外，我们也可以给类编写相应的移动构造函数 <code>（T::T(T&amp;&amp; another)）</code> 和和具有移动语义的赋值函数 <code>（T&amp;&amp; T::operator=(T&amp;&amp; rhs)）</code> ，在构造对象和赋值的时候尽可能的进行资源的重复利用，因为它们都是接收一个右值引用参数。</p>
<h3 id="forward"><a class="markdownIt-Anchor" href="#forward">#</a> forward</h3>
<p>右值引用类型是独立于值的，一个右值引用作为函数参数的形参时，在函数内部转发该参数给内部其他函数时，它就变成一个左值，并不是原来的类型了。如果需要按照参数原来的类型转发到另一个函数，可以使用 C++11 提供的  <code>std::forward ()</code>  函数，该函数实现的功能称之为完美转发。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 函数原型</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span> <span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span> T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span> <span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 精简之后的样子</span></pre></td></tr><tr><td data-num="6"></td><td><pre>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li><strong>当 T 为左值引用类型时，t 将被转换为 T 类型的左值</strong></li>
<li><strong>当 T 不是左值引用类型时，t 将被转换为 T 类型的右值</strong></li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">printValue</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"l-value: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span> <span class="token function">printValue</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"r-value: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">void</span> <span class="token function">testForward</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token function">printValue</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token function">printValue</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token function">testForward</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1314</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token function">testForward</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token function">testForward</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token function">testForward</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token function">testForward</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token comment">// 测试结果</span></pre></td></tr><tr><td data-num="37"></td><td><pre>l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">520</span></pre></td></tr><tr><td data-num="38"></td><td><pre>r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">520</span></pre></td></tr><tr><td data-num="39"></td><td><pre>r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">520</span></pre></td></tr><tr><td data-num="40"></td><td><pre></pre></td></tr><tr><td data-num="41"></td><td><pre>l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span></pre></td></tr><tr><td data-num="42"></td><td><pre>r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span></pre></td></tr><tr><td data-num="43"></td><td><pre>l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span></pre></td></tr><tr><td data-num="44"></td><td><pre></pre></td></tr><tr><td data-num="45"></td><td><pre>l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span></pre></td></tr><tr><td data-num="46"></td><td><pre>r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span></pre></td></tr><tr><td data-num="47"></td><td><pre>r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span></pre></td></tr><tr><td data-num="48"></td><td><pre></pre></td></tr><tr><td data-num="49"></td><td><pre>l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span></pre></td></tr><tr><td data-num="50"></td><td><pre>r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span></pre></td></tr><tr><td data-num="51"></td><td><pre>l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span></pre></td></tr><tr><td data-num="52"></td><td><pre></pre></td></tr><tr><td data-num="53"></td><td><pre>l<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span></pre></td></tr><tr><td data-num="54"></td><td><pre>r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span></pre></td></tr><tr><td data-num="55"></td><td><pre>r<span class="token operator">-</span>value<span class="token operator">:</span> <span class="token number">1314</span></pre></td></tr></table></figure><ul>
<li><code>testForward(520);</code>  函数的形参为未定引用类型  <code>T&amp;&amp;</code> ，实参为右值，初始化后被推导为一个右值引用
<ul>
<li><code>printValue(v);</code>  已命名的右值 v，编译器会视为左值处理，<strong>实参为左值</strong></li>
<li><code>printValue(move(v));</code>  已命名的右值编译器会视为左值处理，通过 move 又将其转换为右值，<strong>实参为右值</strong></li>
<li><code>printValue(forward&lt;T&gt;(v));</code> forward 的模板参数为右值引用，最终得到一个右值，<strong>实参为右值</strong></li>
</ul>
</li>
<li><code>testForward(num);</code>  函数的形参为未定引用类型  <code>T&amp;&amp;</code> ，实参为左值，初始化后被推导为一个左值引用
<ul>
<li><code>printValue(v);</code>  <strong>实参为左值</strong></li>
<li><code>printValue(move(v));</code>  通过 move 将左值转换为右值，<strong>实参为右值</strong></li>
<li><code>printValue(forward&lt;T&gt;(v));</code> forward 的模板参数为左值引用，最终得到一个左值引用，<strong>实参为左值</strong></li>
</ul>
</li>
<li><code>testForward(forward&lt;int&gt;(num));</code> forward 的模板类型为 int，最终会得到一个右值，函数的形参为未定引用类型  <code>T&amp;&amp;</code>  被右值初始化后得到一个右值引用类型
<ul>
<li><code>printValue(v);</code>  已命名的右值 v，编译器会视为左值处理，<strong>实参为左值</strong></li>
<li><code>printValue(move(v));</code>  已命名的右值编译器会视为左值处理，通过 move 又将其转换为右值，<strong>实参为右值</strong></li>
<li><code>printValue(forward&lt;T&gt;(v));</code> forward 的模板参数为右值引用，最终得到一个右值，<strong>实参为右值</strong></li>
</ul>
</li>
<li><code>testForward(forward&lt;int&amp;&gt;(num));</code> forward 的模板类型为 int&amp;，最终会得到一个左值，函数的形参为未定引用类型  <code>T&amp;&amp;</code>  被左值初始化后得到一个左值引用类型
<ul>
<li><code>printValue(v);</code>  <strong>实参为左值</strong></li>
<li><code>printValue(move(v));</code>  通过 move 将左值转换为右值，<strong>实参为右值</strong></li>
<li><code>printValue(forward&lt;T&gt;(v));</code> forward 的模板参数为左值引用，最终得到一个左值，<strong>实参为左值</strong></li>
</ul>
</li>
<li><code>testForward(forward&lt;int&amp;&amp;&gt;(num));</code> forward 的模板类型为 int&amp;&amp;，最终会得到一个右值，函数的形参为未定引用类型  <code>T&amp;&amp;</code>  被右值初始化后得到一个右值引用类型
<ul>
<li><code>printValue(v);</code>  已命名的右值 v，编译器会视为左值处理，<strong>实参为左值</strong></li>
<li><code>printValue(move(v));</code>  已命名的右值编译器会视为左值处理，通过 move 又将其转换为右值，<strong>实参为右值</strong></li>
<li><code>printValue(forward&lt;T&gt;(v));</code> forward 的模板参数为右值引用，最终得到一个右值，<strong>实参为右值</strong></li>
</ul>
</li>
</ul>
<hr>
<h2 id="列表初始化"><a class="markdownIt-Anchor" href="#列表初始化">#</a> 列表初始化</h2>
<p>关于 C<ins> 中的变量，数组，对象等都有不同的初始化方法，在这些繁琐的初始化方法中没有任何一种方式适用于所有的情况。为了统一初始化方式，并且让初始化行为具有确定的效果，在 C</ins>11 中提出了列表初始化的概念。</p>
<h3 id="统一的初始化"><a class="markdownIt-Anchor" href="#统一的初始化">#</a> 统一的初始化</h3>
<p>在 <code>C++98/03</code>  中，对于普通数组和可以直接进行内存拷贝（memcpy ()）的对象是可以使用列表初始化来初始化数据的：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 数组的初始化</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">double</span> array1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">1.3</span><span class="token punctuation">,</span> <span class="token number">1.4</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 对象的初始化</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Person</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">int</span> id<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">double</span> salary<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span>zhang3<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3000</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在  <code>C++11</code>  中，列表初始化变得更加灵活了：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Test</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">const</span> Test <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    Test <span class="token function">t1</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    Test t2 <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre>    Test t3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">520</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    Test t4<span class="token punctuation">&#123;</span> <span class="token number">520</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1314</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">int</span> a2<span class="token punctuation">&#123;</span> <span class="token number">1314</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">int</span> arr2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul>
<li><code>t1</code> ：最中规中矩的初始化方式，通过提供的带参构造进行对象的初始化</li>
<li><code>t2</code> ：语法错误，因为提供的拷贝构造函数是私有的。如果拷贝构造函数是公共的，520 会通过隐式类型转换被 Test (int) 构造成一个匿名对象，然后再通过对这个匿名对象进行拷贝构造得到 t2</li>
<li>t3 和 t4：使用了 C++11 的初始化方式来初始化对象，效果和 t1 的方式是相同的。
<ul>
<li><strong>在初始时，{} 前面的等号是否书写对初始化行为没有任何影响。</strong></li>
<li><strong>t3 虽然使用了等号，但是它仍然是列表初始化</strong>，因此私有的拷贝构造对它没有任何影响。</li>
</ul>
</li>
<li>t1、arr1 和 t2、arr2：这两个是基础数据类型的列表初始化方式，可以看到，和对象的初始化方式是统一的。</li>
<li>t4、a2、arr2 的写法，是 C++11 中新添加的语法格式，使用这种方式可以<strong>直接在变量名后边跟上初始化列表，来进行变量或者对象的初始化</strong>。</li>
</ul>
<p><strong>使用 new 操作符创建新对象的时候</strong>可以使用列表初始化进行对象的初始化</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">&#123;</span><span class="token number">520</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token keyword">double</span><span class="token punctuation">&#123;</span><span class="token number">52.134</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li>指针 p 指向了一个 new 操作符返回的内存，通过列表初始化将内存数据初始化为了 520</li>
<li>变量 b 是对匿名对象使用列表初始之后，再进行拷贝初始化。</li>
<li>数组 array 在堆上动态分配了一块内存，通过列表初始化的方式直接完成了多个元素的初始化。</li>
</ul>
<p>除此之外，列表初始化还可以直接用在函数返回值上：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Person</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> string name<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"id: "</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">", name: "</span> <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>Person <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> <span class="token number">9527</span><span class="token punctuation">,</span> <span class="token string">"华安"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    Person p <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>代码中的  <code>return &#123; 9527, &quot;华安&quot; &#125;;</code>  就相当于  <code>return (9527, &quot;华安&quot; );</code> ，直接返回了一个匿名对象。通过上面的几个例子可以看出在  <code>C++11</code>  使用列表初始化是非常便利的，它统一了各种对象的初始化方式，而且还让代码的书写更加简单清晰。</p>
<h3 id="初始化列表细节"><a class="markdownIt-Anchor" href="#初始化列表细节">#</a> 初始化列表细节</h3>
<h3 id="stdinitializer_list"><a class="markdownIt-Anchor" href="#stdinitializer_list">#</a> std::initializer_list</h3>
<hr>
<h2 id="常量表达式修饰符-constexpr"><a class="markdownIt-Anchor" href="#常量表达式修饰符-constexpr">#</a> 常量表达式修饰符 - constexpr</h2>
<h3 id="const"><a class="markdownIt-Anchor" href="#const">#</a> const</h3>
<p>在 C++11 之前只有  <code>const</code>  关键字，从功能上来说这个关键字有双重语义：<strong>变量只读</strong>，<strong>修饰常量</strong>，举一个简单的例子：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">const</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> array<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">//error，num 是一个只读变量，不是常量</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">int</span> array1<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">//ok，count 是一个常量</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token number">520</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">int</span> a2 <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    b <span class="token operator">=</span> a2<span class="token punctuation">;</span>                         <span class="token comment">// error</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    a1 <span class="token operator">=</span> <span class="token number">1314</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b: "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>     <span class="token comment">// 输出结果为 1314</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul>
<li>函数  <code>void func(const int num)</code>  的参数  <code>num</code>  表示这个变量是只读的，但不是常量，因此使用  <code>int array[num];</code>  这种方式定义一个数组，编译器是会报错的，提示 <code>num不可用作为常量来使用。</code></li>
<li><code>const int count = 24;</code>  中的  <code>count</code>  却是一个常量，因此可以使用这个常量来定义一个静态数组。</li>
</ul>
<p>另外，<strong>变量只读并不等价于常量</strong>，二者是两个概念不能混为一谈，分析一下这句测试代码  <code>const int&amp; b = a1;</code> ：</p>
<ul>
<li><code>b</code>  是一个常量的引用，所以 b 引用的变量是不能被修改的，也就是说  <code>b = a2;</code>  这句代码语法是错误的。</li>
<li>在  <code>const</code>  对于变量  <code>a1</code>  是没有任何约束的， <code>a1</code>  的值变了  <code>b</code>  的值也就变了</li>
<li>引用  <code>b</code>  是只读的，但是并不能保证它的值是不可改变的，也就是说它不是常量。</li>
</ul>
<h3 id="constexpr"><a class="markdownIt-Anchor" href="#constexpr">#</a> constexpr</h3>
<p>在 C++11 中添加了一个新的关键字  <code>constexpr</code> ，这个关键字是用来修饰常量表达式的。<strong>所谓常量表达式，指的就是由多个（≥1）常量（值不会改变）组成并且在编译过程中就得到计算结果的表达式。</strong></p>
<p>在介绍 gcc/g++ 工作流程的时候，<strong>C++ 程序从编写完毕到执行分为四个阶段：预处理、 编译、汇编和链接 4 个阶段</strong>，得到可执行程序之后就可以运行了。需要额外强调的是，<strong>常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果，但是常量表达式的计算往往发生在程序的编译阶段</strong>，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p>
<p>那么问题来了，编译器如何识别表达式是不是常量表达式呢？</p>
<p>在 C++11 中添加了  <code>constexpr</code>  关键字之后就可以在程序中使用它来修改常量表达式，用来提高程序的执行效率。在使用中建议将  <code>const</code>  和  <code>constexpr</code>  的功能区分开，即<strong>凡是表达 “只读” 语义的场景都使用</strong>  <code>const</code> <strong>，表达 “常量” 语义的场景都使用</strong>  <code>constexpr</code> 。</p>
<p>在定义常量时，const 和 constexpr 是等价的，都可以在程序的编译阶段计算出结果，例如：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 不是常量表达式，m 的值只有在运行时才会获取。</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">520</span><span class="token punctuation">;</span>    <span class="token comment">// 是一个常量表达式</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 是一个常量表达式</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">constexpr</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">520</span><span class="token punctuation">;</span>    <span class="token comment">// 是一个常量表达式</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">constexpr</span> <span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 是一个常量表达式</span></pre></td></tr></table></figure><p>对于 C++ 内置类型的数据，可以直接用  <code>constexpr</code>  修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用  <code>constexpr</code>  修饰是不行的。</p>
<p>如果要定义一个结构体 / 类常量对象，可以这样写：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Test</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> id<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> num<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">constexpr</span> Test t<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> id <span class="token operator">=</span> t<span class="token punctuation">.</span>id<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> num <span class="token operator">=</span> t<span class="token punctuation">.</span>num<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">//error，不能修改常量</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    t<span class="token punctuation">.</span>num <span class="token operator">+=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"id: "</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">", num: "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在第 13 行的代码中  <code>t.num += 100;</code>  的操作是错误的，对象 t 是一个常量，因此它的成员也是常量，常量是不能被修改的。</p>
<h3 id="常量表达式函数"><a class="markdownIt-Anchor" href="#常量表达式函数">#</a> 常量表达式函数</h3>
<p>为了提高 C++ 程序的执行效率，我们可以将程序中值不需要发生变化的变量定义为常量，也可以使用  <code>constexpr</code>  修饰函数的返回值，这种函数被称作<strong>常量表达式函数</strong>，这些函数主要包括以下几种：<strong>普通函数 / 类成员函数、类的构造函数、模板函数。</strong></p>
<h3 id="修饰普通函数"><a class="markdownIt-Anchor" href="#修饰普通函数">#</a> 修饰普通函数</h3>
<p><code>constexpr</code>  并不能修改任意函数的返回值，使这些函数成为常量表达式函数，必须要满足以下几个条件：</p>
<ol>
<li>
<p><strong>函数必须要有返回值，并且 return 返回的表达式必须是常量表达式。</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//error，不是常量表达式函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">constexpr</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">//error，不是常量表达式函数</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">return</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul>
<li>函数  <code>func1()</code>  没有返回值，不满足常量表达式函数要求</li>
<li>函数  <code>func2()</code>  返回值不是常量表达式，不满足常量表达式函数要求</li>
</ul>
</li>
<li>
<p><strong>函数在使用之前，必须有对应的定义语句。</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// error</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在测试程序  <code>constexpr int num = func1();</code>  中，还没有定义  <code>func1()</code>  就直接调用了，应该将  <code>func1()</code>  函数的定义放到  <code>main()</code>  函数的上边。</p>
</li>
<li>
<p><strong>整个函数的函数体中，不能出现非常量表达式之外的语句（using 指令、typedef 语句以及 static_assert 断言、return 语句除外）。</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// error</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">// ok</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">using</span> mytype <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">constexpr</span> mytype a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">constexpr</span> mytype b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">constexpr</span> mytype c <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">return</span> c <span class="token operator">-</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>因为  <code>func1()</code>  是一个常量表达式函数，在函数体内部是不允许出现非常量表达式以外的操作，因此函数体内部的  <code>for</code>  循环是一个非法操作。</p>
</li>
</ol>
<blockquote>
<p>以上三条规则不仅对应普通函数适用，对应类的成员函数也是适用的</p>
</blockquote>
<h3 id="修饰模板函数"><a class="markdownIt-Anchor" href="#修饰模板函数">#</a> 修饰模板函数</h3>
<p>C++11 语法中， <code>constexpr</code>  可以修饰函数模板，但由于模板中类型的不确定性，因此函数模板实例化后的模板函数是否符合常量表达式函数的要求也是不确定的。如果  <code>constexpr</code>  修饰的模板函数实例化结果不满足常量表达式函数的要求，则  <code>constexpr</code>  会被自动忽略，即该函数就等同于一个普通函数。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">int</span> age<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 定义函数模板</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">constexpr</span> T <span class="token function">dispaly</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">return</span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">Person</span> p <span class="token punctuation">&#123;</span> <span class="token string">"luffy"</span><span class="token punctuation">,</span> <span class="token number">19</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">// 普通函数</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">Person</span> ret <span class="token operator">=</span> <span class="token function">dispaly</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"luffy's name: "</span> <span class="token operator">&lt;&lt;</span> ret<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">", age: "</span> <span class="token operator">&lt;&lt;</span> ret<span class="token punctuation">.</span>age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">// 常量表达式函数</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> ret1 <span class="token operator">=</span> <span class="token function">dispaly</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> ret1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">constexpr</span> <span class="token keyword">struct</span> <span class="token class-name">Person</span> p1 <span class="token punctuation">&#123;</span> <span class="token string">"luffy"</span><span class="token punctuation">,</span> <span class="token number">19</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">constexpr</span> <span class="token keyword">struct</span> <span class="token class-name">Person</span> p2 <span class="token operator">=</span> <span class="token function">dispaly</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"luffy's name: "</span> <span class="token operator">&lt;&lt;</span> p2<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">", age: "</span> <span class="token operator">&lt;&lt;</span> p2<span class="token punctuation">.</span>age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面示例程序中定义了一个函数模板  <code>display()</code> ，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p>
<ul>
<li><code>struct Person ret = dispaly(p);</code>  由于参数  <code>p</code>  是变量，所以实例化后的函数不是常量表达式函数，此时  <code>constexpr</code>  是无效的</li>
<li><code>constexpr int ret1 = dispaly(250);</code>  参数是常量，符合常量表达式函数的要求，此时  <code>constexpr</code>  是有效的</li>
<li><code>constexpr struct Person p2 = dispaly(p1);</code>  参数是常量，符合常量表达式函数的要求，此时  <code>constexpr</code>  是有效的</li>
</ul>
<h3 id="修饰构造函数"><a class="markdownIt-Anchor" href="#修饰构造函数">#</a> 修饰构造函数</h3>
<p>如果想用直接得到一个常量对象，也可以使用  <code>constexpr</code>  修饰一个构造函数，这样就可以得到一个常量构造函数了。常量构造函数有一个要求：<strong>构造函数的函数体必须为空，并且必须采用初始化列表的方式为各个成员赋值。</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">constexpr</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">name</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">age</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">int</span> age<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">constexpr</span> <span class="token keyword">struct</span> <span class="token class-name">Person</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token string">"luffy"</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"luffy's name: "</span> <span class="token operator">&lt;&lt;</span> p1<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">", age: "</span> <span class="token operator">&lt;&lt;</span> p1<span class="token punctuation">.</span>age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><hr>
<h2 id="委托构造函数和继承构造函数"><a class="markdownIt-Anchor" href="#委托构造函数和继承构造函数">#</a> 委托构造函数和继承构造函数</h2>
<h3 id="委托构造函数"><a class="markdownIt-Anchor" href="#委托构造函数">#</a> 委托构造函数</h3>
<p>委托构造函数允许使用同一个类中的一个构造函数调用其它的构造函数，从而简化相关变量的初始化。下面举例说明：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Test</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> max<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">this</span><span class="token operator">-></span>m_max <span class="token operator">=</span> max <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> max <span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> max<span class="token punctuation">,</span> <span class="token keyword">int</span> min<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">this</span><span class="token operator">-></span>m_max <span class="token operator">=</span> max <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> max <span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">;</span>              <span class="token comment">// 冗余代码</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">this</span><span class="token operator">-></span>m_min <span class="token operator">=</span> min <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> min <span class="token operator">&lt;</span> max <span class="token operator">?</span> min <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> max<span class="token punctuation">,</span> <span class="token keyword">int</span> min<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">this</span><span class="token operator">-></span>m_max <span class="token operator">=</span> max <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> max <span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">;</span>             <span class="token comment">// 冗余代码</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">this</span><span class="token operator">-></span>m_min <span class="token operator">=</span> min <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> min <span class="token operator">&lt;</span> max <span class="token operator">?</span> min <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 冗余代码</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">this</span><span class="token operator">-></span>m_middle <span class="token operator">=</span> mid <span class="token operator">&lt;</span> max <span class="token operator">&amp;&amp;</span> mid <span class="token operator">></span> min <span class="token operator">?</span> mid <span class="token operator">:</span> <span class="token number">50</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">int</span> m_min<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">int</span> m_max<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">int</span> m_middle<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    Test <span class="token function">t</span><span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"min: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>m_min <span class="token operator">&lt;&lt;</span> <span class="token string">", middle: "</span> </pre></td></tr><tr><td data-num="35"></td><td><pre>         <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>m_middle <span class="token operator">&lt;&lt;</span> <span class="token string">", max: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>m_max <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在上面的程序中有三个构造函数，但是这三个函数中都有重复的代码，在 C++11 之前构造函数是不能调用构造函数的，加入了委托构造之后，我们就可以轻松地完成代码的优化了：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Test</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> max<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">this</span><span class="token operator">-></span>m_max <span class="token operator">=</span> max <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> max <span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> max<span class="token punctuation">,</span> <span class="token keyword">int</span> min<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">Test</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">this</span><span class="token operator">-></span>m_min <span class="token operator">=</span> min <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> min <span class="token operator">&lt;</span> max <span class="token operator">?</span> min <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> max<span class="token punctuation">,</span> <span class="token keyword">int</span> min<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">Test</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> min<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">this</span><span class="token operator">-></span>m_middle <span class="token operator">=</span> mid <span class="token operator">&lt;</span> max <span class="token operator">&amp;&amp;</span> mid <span class="token operator">></span> min <span class="token operator">?</span> mid <span class="token operator">:</span> <span class="token number">50</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">int</span> m_min<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">int</span> m_max<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">int</span> m_middle<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    Test <span class="token function">t</span><span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"min: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>m_min <span class="token operator">&lt;&lt;</span> <span class="token string">", middle: "</span> </pre></td></tr><tr><td data-num="32"></td><td><pre>         <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>m_middle <span class="token operator">&lt;&lt;</span> <span class="token string">", max: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>m_max <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在修改之后的代码中可以看到，重复的代码全部没有了，并且在一个构造函数中调用了其他的构造函数用于相关数据的初始化，相当于是一个链式调用。在使用委托构造函数的时候还需要注意一些几个问题：</p>
<ul>
<li>
<p><strong>这种链式的构造函数调用不能形成一个闭环（死循环），否则会在运行期抛异常。</strong></p>
</li>
<li>
<p><strong>如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在初始列表中而不是函数体内部，否则编译器会提示形参的重复定义。</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> max<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">this</span><span class="token operator">-></span>m_max <span class="token operator">=</span> max <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">?</span> max <span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> max<span class="token punctuation">,</span> <span class="token keyword">int</span> min<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">Test</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//error, 此处编译器会报错，提示形参 max 被重复定义</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">this</span><span class="token operator">-></span>m_min <span class="token operator">=</span> min <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> min <span class="token operator">&lt;</span> max <span class="token operator">?</span> min <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li>
<li>
<p><strong>在初始化列表中调用了代理构造函数初始化某个类成员变量之后，就不能在初始化列表中再次初始化这个变量了。</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 错误，使用了委托构造函数就不能再次 m_max 初始化了</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> max<span class="token punctuation">,</span> <span class="token keyword">int</span> min<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Test</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_max</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">this</span><span class="token operator">-></span>m_min <span class="token operator">=</span> min <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> min <span class="token operator">&lt;</span> max <span class="token operator">?</span> min <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li>
</ul>
<h3 id="继承构造函数"><a class="markdownIt-Anchor" href="#继承构造函数">#</a> 继承构造函数</h3>
<p>C++11 中提供的继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。先来看没有继承构造函数之前的处理方式：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Base</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    string m_k<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token function">Child</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    Child <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span><span class="token punctuation">,</span> <span class="token string">"i love you"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int: "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_i <span class="token operator">&lt;&lt;</span> <span class="token string">", double: "</span> </pre></td></tr><tr><td data-num="29"></td><td><pre>         <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_j <span class="token operator">&lt;&lt;</span> <span class="token string">", string: "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>m_k <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>通过测试代码可以看出，在子类中初始化从基类继承的类成员，需要在子类中重新定义和基类一致的构造函数，这是非常繁琐的，C++11 中通过添加继承构造函数这个新特性完美的解决了这个问题，使得代码更加精简。</p>
<p>继承构造函数的使用方法是这样的：通过使用  <code>using 类名::构造函数名</code> （其实类名和构造函数名是一样的）来声明使用基类的构造函数，这样子类中就可以不定义相同的构造函数了，直接使用基类的构造函数来构造派生类对象。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Base</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    string m_k<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    Child <span class="token function">c1</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int: "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span>m_i <span class="token operator">&lt;&lt;</span> <span class="token string">", double: "</span> <span class="token operator">&lt;&lt;</span> c1<span class="token punctuation">.</span>m_j <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    Child <span class="token function">c2</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">,</span> <span class="token number">13.14</span><span class="token punctuation">,</span> <span class="token string">"i love you"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int: "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span>m_i <span class="token operator">&lt;&lt;</span> <span class="token string">", double: "</span> </pre></td></tr><tr><td data-num="29"></td><td><pre>         <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span>m_j <span class="token operator">&lt;&lt;</span> <span class="token string">", string: "</span> <span class="token operator">&lt;&lt;</span> c2<span class="token punctuation">.</span>m_k <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在修改之后的子类中，没有添加任何构造函数，而是添加了  <code>using Base::Base;</code>  这样就可以在子类中直接继承父类的所有的构造函数，通过他们去构造子类对象了。</p>
<p>另外如果在子类中隐藏了父类中的同名函数，也可以通过  <code>using</code>  的方式在子类中使用基类中的这些父类函数：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Base</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> j<span class="token punctuation">,</span> string k<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_j</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_k</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"base class: i = "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    </pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> string str<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"base class: i = "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">", str = "</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">int</span> m_i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">double</span> m_j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    string m_k<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>func<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"child class: i'am superman!!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>    Child <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    c<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>    c<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>    c<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">"superman"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="46"></td><td><pre></pre></td></tr><tr><td data-num="47"></td><td><pre><span class="token comment">// 测试输出</span></pre></td></tr><tr><td data-num="48"></td><td><pre>child <span class="token keyword">class</span><span class="token operator">:</span> i<span class="token number">'</span>am superman<span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span></pre></td></tr><tr><td data-num="49"></td><td><pre>base <span class="token keyword">class</span><span class="token operator">:</span> i <span class="token operator">=</span> <span class="token number">19</span></pre></td></tr><tr><td data-num="50"></td><td><pre>base <span class="token keyword">class</span><span class="token operator">:</span> i <span class="token operator">=</span> <span class="token number">19</span><span class="token punctuation">,</span> str <span class="token operator">=</span> superman</pre></td></tr></table></figure><p>子类中的 func () 函数隐藏了基类中的两个 func () 因此默认情况下通过子类对象只能调用无参的 func ()，在上面的子类代码中添加了 using Base::func; 之后，就可以通过子类对象直接调用父类中被隐藏的带参 func () 函数了。</p>
<hr>
<h2 id="using-的使用"><a class="markdownIt-Anchor" href="#using-的使用">#</a> using 的使用</h2>
<p>在  <code>C++</code>  中  <code>using</code>  用于声明命名空间，使用命名空间也可以防止命名冲突。在程序中声明了命名空间之后，就可以直接使用命名空间中的定义的类了。在  <code>C++11</code>  中赋予了  <code>using</code>  新的功能，让 C++ 变得更年轻，更灵活。</p>
<h3 id="定义别名"><a class="markdownIt-Anchor" href="#定义别名">#</a> 定义别名</h3>
<h3 id="模板的别名"><a class="markdownIt-Anchor" href="#模板的别名">#</a> 模板的别名</h3>
<hr>
<h2 id="可调用对象包装器-绑定器"><a class="markdownIt-Anchor" href="#可调用对象包装器-绑定器">#</a> 可调用对象包装器、绑定器</h2>
<hr>
<h2 id="pod-类型"><a class="markdownIt-Anchor" href="#pod-类型">#</a> POD 类型</h2>
<hr>
<h2 id="默认函数控制-default-与-delete"><a class="markdownIt-Anchor" href="#默认函数控制-default-与-delete">#</a> 默认函数控制 =default 与 =delete</h2>
<hr>
<h2 id="扩展的-friend-语法"><a class="markdownIt-Anchor" href="#扩展的-friend-语法">#</a> 扩展的 friend 语法</h2>
<hr>
<h2 id="强类型枚举"><a class="markdownIt-Anchor" href="#强类型枚举">#</a> 强类型枚举</h2>
<hr>
<h2 id="非受限联合体"><a class="markdownIt-Anchor" href="#非受限联合体">#</a> 非受限联合体</h2>
<hr>
<h1 id="稳定性和兼容性"><a class="markdownIt-Anchor" href="#稳定性和兼容性">#</a> 稳定性和兼容性</h1>
<h2 id="noexcept"><a class="markdownIt-Anchor" href="#noexcept">#</a> noexcept</h2>
<h3 id="c-异常"><a class="markdownIt-Anchor" href="#c-异常">#</a> C++ 异常</h3>
<p>异常通常用于处理逻辑上可能发生的错误，在  <code>C++98</code>  中为我们提供了一套完善的异常处理机制，我们可以直接在程序中将各种类型的异常抛出，从而强制终止程序的运行。</p>
<p>关于异常的基本语法如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 抛出异常的程序段</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    …………</pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">throw</span> 表达式<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    …………</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 捕获并处理异常的程序段</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">try</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    复合语句</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类型声明<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    复合语句</pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">catch</span><span class="token punctuation">(</span>类型<span class="token punctuation">(</span>形参<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    复合语句</pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">try</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">throw</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">int</span> e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int exception, value: "</span> <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"That's ok!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote>
<p>异常被抛出后，从进入 try 块起，到异常被抛掷前，这期间在栈上构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈的解旋。</p>
</blockquote>
<h3 id="异常接口声明"><a class="markdownIt-Anchor" href="#异常接口声明">#</a> 异常接口声明</h3>
<p>为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类型，常用的有如下三种书写方式：</p>
<ol>
<li>
<p>显示指定可以抛出的异常类型</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">MyException</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">MyException</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">msg</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    string msg<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">double</span> <span class="token function">divisionMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span>MyException<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">throw</span> <span class="token function">MyException</span><span class="token punctuation">(</span><span class="token string">"division by zero!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// throw 100;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">try</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#123;</span>	</pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">double</span> v <span class="token operator">=</span> <span class="token function">divisionMethod</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"value: "</span> <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">int</span> e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"catch except: "</span>  <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">catch</span> <span class="token punctuation">(</span>MyException e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"catch except: "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span>msg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>第 7 行代码在  <code>divisionMethod</code>  函数后添加了  <code>throw</code>  异常接口声明，其参数表示可以抛出的异常类型，分别为  <code>int</code>  和  <code>MyException</code>  类型。</p>
</li>
<li>
<p>抛出任意异常类型</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">MyException</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">MyException</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">msg</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    string msg<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">double</span> <span class="token function">divisionMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">throw</span> <span class="token function">MyException</span><span class="token punctuation">(</span><span class="token string">"division by zero!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// throw 100;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>第 7 行代码在  <code>divisionMethod</code>  没有添加异常接口声明，表示在该函数中<strong>可以抛出任意类型的异常</strong>。</p>
</li>
<li>
<p>不抛出任何异常</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">MyException</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">MyException</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">msg</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    string msg<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">double</span> <span class="token function">divisionMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"division by zero!!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>第 7 行代码在  <code>divisionMethod</code>  函数后添加了  <code>throw</code>  异常接口声明，其<strong>参数列表为空</strong>，表示该函数<strong>不允许抛出异常</strong>。</p>
<blockquote>
<p>以上程序在 VS 上的测试结果和在 Linux 上基于 G++ 的测试结果是不同的，如果违反了规则 VS 只会给出警告，而 G++ 则会直接终止程序的运行。（PS：VS 使用的不是 G++ 编译器）</p>
</blockquote>
</li>
</ol>
<h3 id="noexcept异常声明"><a class="markdownIt-Anchor" href="#noexcept异常声明">#</a> noexcept 异常声明</h3>
<p>上面的例子中，在  <code>divisionMethod</code>  函数声明之后，我们定义了一个动态异常声明  <code>throw(MyException, int)</code> ，该声明指出了  <code>divisionMethod</code>  可能抛出的异常的类型。<strong>事实上，该特性很少被使用，因此在 C++11 中被弃用了</strong> ，而表示函数不会抛出异常的动态异常声明  <code>throw()</code>  也被新的  <code>noexcept</code>  异常声明所取代。</p>
<p><code>noexcept</code>  形如其名， <strong>表示其修饰的函数不会抛出异常</strong> 。不过与  <code>throw ()</code>  动态异常声明不同的是，在 C++11 中如果  <code>noexcept</code>  修饰的函数抛出了异常，编译器可以选择直接调用  <code>std::terminate ()</code>  函数来终止程序的运行，这比基于异常机制的  <code>throw ()</code>  在效率上会高一些。这是因为异常机制会带来一些额外开销，比如函数抛出异常，会导致函数栈被依次地展开（栈解旋），并自动调用析构函数释放栈上的所有对象。<br>
因此对于不会抛出异常的函数我们可以这样写:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">double</span> <span class="token function">divisionMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token keyword">noexcept</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"division by zero!!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>从语法上讲，noexcept 修饰符有两种形式：</p>
<ol>
<li>
<p>简单地在函数声明后加上 noexcept 关键字</p>
</li>
<li>
<p>可以接受一个常量表达式作为参数，如下所示∶</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">double</span> <span class="token function">divisionMethod</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span>常量表达式<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>常量表达式的结果会被转换成一个 bool 类型的值：</p>
<ul>
<li>值为 true，表示函数不会抛出异常</li>
<li>值为 false，表示有可能抛出异常这里</li>
<li>不带常量表达式的 noexcept 相当于声明了 noexcept（true），即不会抛出异常。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="类成员的快速初始化"><a class="markdownIt-Anchor" href="#类成员的快速初始化">#</a> 类成员的快速初始化</h2>
<h3 id="初始化类的非静态成员"><a class="markdownIt-Anchor" href="#初始化类的非静态成员">#</a> 初始化类的非静态成员</h3>
<p>在进行类成员变量初始化的时候，C<ins>11 标准对于 C</ins>98 做了补充，允许在定义类的时候在类内部直接对非静态成员变量进行初始化，在初始化的时候可以使用等号 = 也可以 使用花括号 {} 。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Test</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">int</span> c<span class="token punctuation">&#123;</span><span class="token number">12</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">double</span> array<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token number">3.15</span><span class="token punctuation">,</span> <span class="token number">3.16</span><span class="token punctuation">,</span> <span class="token number">3.17</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">double</span> array1<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> <span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token number">3.15</span><span class="token punctuation">,</span> <span class="token number">3.16</span><span class="token punctuation">,</span> <span class="token number">3.17</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// error</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    string s2<span class="token punctuation">&#123;</span> <span class="token string">"hello, world"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>可以看到如果使用花括号 {} 的方式对类的非静态成员进行初始化，等号是可以省略不写的。</p>
<ul>
<li>第 9 行：错误，不能使用小括号 () 初始化对象，应该使用 花括号 {}</li>
</ul>
<h3 id="类内部赋值和初始化列表"><a class="markdownIt-Anchor" href="#类内部赋值和初始化列表">#</a> 类内部赋值和初始化列表</h3>
<p>在 C++11 之前对于非静态的类成员变量我们除了在构造函数内部进行赋值，也可以在类的初始化列表中进行初始化（这种方式比在构造函数内部赋值效率高）。那么，如果同时在类内部对非静态成员变量就地初始化和在初始化列表中进行初始化会怎么样呢？下面来测试一下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Init</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">Init</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">c</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    Init <span class="token function">tmp</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a: "</span> <span class="token operator">&lt;&lt;</span> tmp<span class="token punctuation">.</span>a <span class="token operator">&lt;&lt;</span> <span class="token string">", b: "</span> <span class="token operator">&lt;&lt;</span> tmp<span class="token punctuation">.</span>b <span class="token operator">&lt;&lt;</span> <span class="token string">", c: "</span> <span class="token operator">&lt;&lt;</span> tmp<span class="token punctuation">.</span>c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul>
<li>第 4 行：使用初始化列表对类的非静态成员进行初始化</li>
<li>第 6、7、8 行：在类内部对非静态成员变量就地初始化（C++11 新特性）</li>
</ul>
<p>执行程序，输出的结果如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre>a<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> c<span class="token operator">:</span> <span class="token number">30</span></pre></td></tr></table></figure><p>我们可以从函数的打印输出中看到，在类内部就地初始化和初始化列表并不冲突（程序可以正常运行）。程序员可以为同一成员变量既在类内部就地初始化，又在初始化列表中进行初始化，只不过初始化列表总是看起来后作用于非静态成员。也就是说，<strong>通过初始化列表指定的值会覆盖就地初始化时指定的值。</strong></p>
<hr>
<h2 id="数值类型和字符串之间的转换"><a class="markdownIt-Anchor" href="#数值类型和字符串之间的转换">#</a> 数值类型和字符串之间的转换</h2>
<h3 id="数值转换为字符串"><a class="markdownIt-Anchor" href="#数值转换为字符串">#</a> 数值转换为字符串</h3>
<p>使用 to_string () 方法可以非常方便地将各种数值类型转换为字符串类型，这是一个重载函，函数声明位于头文件 <string> 中，函数原型如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 头文件 &lt;string></span></pre></td></tr><tr><td data-num="2"></td><td><pre>string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">long</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">float</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">double</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>string <span class="token function">to_string</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">double</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    string pi <span class="token operator">=</span> <span class="token string">"pi is "</span> <span class="token operator">+</span> <span class="token function">to_string</span><span class="token punctuation">(</span><span class="token number">3.1415926</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    string love <span class="token operator">=</span> <span class="token string">"love is "</span> <span class="token operator">+</span> <span class="token function">to_string</span><span class="token punctuation">(</span><span class="token number">5.20</span> <span class="token operator">+</span> <span class="token number">13.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> pi <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> love <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="字符串转换为数值"><a class="markdownIt-Anchor" href="#字符串转换为数值">#</a> 字符串转换为数值</h3>
<p>由于 C++ 中的数值类型包括整形和浮点型，因此针对于不同的类型提供了不同的函数，通过调用这些函数可以将字符串类型转换为对应的数值类型。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 定义于头文件 &lt;string></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span>       <span class="token function">stoi</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">*</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">long</span>      <span class="token function">stol</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">*</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">stoll</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">*</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">long</span>      <span class="token function">stoul</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">*</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">stoull</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">*</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">float</span>       <span class="token function">stof</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">*</span> pos <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">double</span>      <span class="token function">stod</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">*</span> pos <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">long</span> <span class="token keyword">double</span> <span class="token function">stold</span><span class="token punctuation">(</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token operator">*</span> pos <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li><code>str</code> ：要转换的字符串</li>
<li><code>pos</code> ：传出参数，记录从哪个字符开始无法继续进行解析，比如: 123abc, 传出的位置为 3</li>
<li><code>base</code> ：若 base 为 0 ，则自动检测数值进制：若前缀为 0 ，则为八进制，若前缀为 0x 或 0X，则为十六进制，否则为十进制。</li>
</ul>
<p>这些函数虽然都有多个参数，但是除去第一个参数外其他都有默认值，一般情况下使用默认值就能满足需求。关于函数的使用示例代码如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    string str1 <span class="token operator">=</span> <span class="token string">"45"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    string str2 <span class="token operator">=</span> <span class="token string">"3.14159"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    string str3 <span class="token operator">=</span> <span class="token string">"9527 with words"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    string str4 <span class="token operator">=</span> <span class="token string">"words and 2"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">int</span> myint1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stoi</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">float</span> myint2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stof</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">int</span> myint3 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stoi</span><span class="token punctuation">(</span>str3<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">// 错误： 'std::invalid_argument'</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// int myint4 = std::stoi(str4);</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"std::stoi(\""</span> <span class="token operator">&lt;&lt;</span> str1 <span class="token operator">&lt;&lt;</span> <span class="token string">"\") is "</span> <span class="token operator">&lt;&lt;</span> myint1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"std::stof(\""</span> <span class="token operator">&lt;&lt;</span> str2 <span class="token operator">&lt;&lt;</span> <span class="token string">"\") is "</span> <span class="token operator">&lt;&lt;</span> myint2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"std::stoi(\""</span> <span class="token operator">&lt;&lt;</span> str3 <span class="token operator">&lt;&lt;</span> <span class="token string">"\") is "</span> <span class="token operator">&lt;&lt;</span> myint3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">// cout &lt;&lt; "std::stoi(\"" &lt;&lt; str4 &lt;&lt; "\") is " &lt;&lt; myint4 &lt;&lt; endl;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment">// 测试输出</span></pre></td></tr><tr><td data-num="25"></td><td><pre>std<span class="token double-colon punctuation">::</span><span class="token function">stoi</span><span class="token punctuation">(</span><span class="token string">"45"</span><span class="token punctuation">)</span> is <span class="token number">45</span></pre></td></tr><tr><td data-num="26"></td><td><pre>std<span class="token double-colon punctuation">::</span><span class="token function">stof</span><span class="token punctuation">(</span><span class="token string">"3.14159"</span><span class="token punctuation">)</span> is <span class="token number">3.14159</span></pre></td></tr><tr><td data-num="27"></td><td><pre>std<span class="token double-colon punctuation">::</span><span class="token function">stoi</span><span class="token punctuation">(</span><span class="token string">"9527 with words"</span><span class="token punctuation">)</span> is <span class="token number">9527</span></pre></td></tr></table></figure><p>从上述测试程序可以得出这样的结论，在 C++11 提供的这些转换函数将字符串转换为数值的过程中：</p>
<ul>
<li>如果字符串中所有字符都是数值类型，整个字符串会被转换为对应的数值，并通过返回值返回</li>
<li>如果字符串的前半部分字符是数值类型，后半部不是，那么前半部分会被转换为对应的数值，并通过返回值返回</li>
<li>如果字符第一个字符不是数值类型转换失败</li>
</ul>
<hr>
<h2 id="模板的优化"><a class="markdownIt-Anchor" href="#模板的优化">#</a> 模板的优化</h2>
<h3 id="模板的右尖括号"><a class="markdownIt-Anchor" href="#模板的右尖括号">#</a> 模板的右尖括号</h3>
<p>在泛型编程中，模板实例化有一个非常繁琐的地方，那就是连续的两个右尖括号（&gt;&gt;）会被编译器解析成右移操作符，而不是模板参数表的结束。我们先来看一段关于容器遍历的代码，在创建的类模板  <code>Base</code>  中提供了遍历容器的操作函数  <code>traversal()</code> :</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// test.cpp</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Base</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">traversal</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">auto</span> it <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> t<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    Base<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    b<span class="token punctuation">.</span><span class="token function">traversal</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果使用 C++98/03 标准来编译上边的这段代码，就会得到如下的错误提示：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre>test.cpp:25:20: error: <span class="token string">'>>'</span> should be <span class="token string">'> >'</span> within a nested template argument list</pre></td></tr><tr><td data-num="2"></td><td><pre>     Base<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>int<span class="token operator">>></span> b<span class="token punctuation">;</span></pre></td></tr></table></figure><p>根据错误提示中描述模板的两个右尖括之间需要添加空格，这样写起来就非常的麻烦，<strong>C++11 改进了编译器的解析规则，尽可能地将多个右尖括号（&gt;）解析成模板参数结束符</strong>，方便我们编写模板相关的代码。</p>
<p>上面的这段代码，在支持  <code>C++11</code>  的编译器中编译是没有任何问题的，如果使用 g++ 直接编译需要加参数  <code>-std=c++11</code> ：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre>$ g++ test.cpp <span class="token parameter variable">-std</span><span class="token operator">=</span>c++11 <span class="token parameter variable">-o</span> app</pre></td></tr></table></figure><h3 id="默认模板参数"><a class="markdownIt-Anchor" href="#默认模板参数">#</a> 默认模板参数</h3>
<p>在  <code>C++98/03</code>  标准中，类模板可以有默认的模板参数：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">=</span><span class="token keyword">int</span><span class="token punctuation">,</span> T t<span class="token operator">=</span><span class="token number">520</span><span class="token operator">></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Test</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current value: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    Test<span class="token operator">&lt;</span><span class="token operator">></span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    t<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    Test<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token operator">></span> t1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    t1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>但是不支持函数的默认模板参数，<strong>在 C++11 中添加了对函数模板默认参数的支持</strong>:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">=</span><span class="token keyword">int</span><span class="token operator">></span>	<span class="token comment">// C++98/03 不支持这种写法，C++11 中支持这种写法</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"current value: "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>通过上面的例子可以得到如下结论：当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随 &lt;&gt; 来实例化。</p>
<p>另外：函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制。这样当默认模板参数和模板参数自动推导结合起来时，书写就显得非常灵活了。我们可以指定函数模板中的一部分模板参数使用默认参数，另一部分使用自动推导，比如下面的例子：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">R</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">N</span><span class="token operator">></span></pre></td></tr><tr><td data-num="6"></td><td><pre>R <span class="token function">func</span><span class="token punctuation">(</span>N arg<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span> arg<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">auto</span> ret1 <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"return value-1: "</span> <span class="token operator">&lt;&lt;</span> ret1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">auto</span> ret2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">func</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">52.134</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"return value-2: "</span> <span class="token operator">&lt;&lt;</span> ret2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">auto</span> ret3 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">func</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">52.134</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"return value-3: "</span> <span class="token operator">&lt;&lt;</span> ret3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">auto</span> ret4 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">func</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"return value-4: "</span> <span class="token operator">&lt;&lt;</span> ret4 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token comment">// 测试输出</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token keyword">return</span> value<span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span> <span class="token number">520</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token keyword">return</span> value<span class="token operator">-</span><span class="token number">2</span><span class="token operator">:</span> <span class="token number">52.134</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token keyword">return</span> value<span class="token operator">-</span><span class="token number">3</span><span class="token operator">:</span> <span class="token number">52</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token keyword">return</span> value<span class="token operator">-</span><span class="token number">4</span><span class="token operator">:</span> d</pre></td></tr></table></figure><p>根据得到的日志输出，分析一下示例代码中调用的模板函数：</p>
<ul>
<li><code>auto ret = func(520);</code>
<ul>
<li>函数返回值类型使用了默认的模板参数，函数的参数类型是自动推导出来的为 int 类型。</li>
</ul>
</li>
<li><code>auto ret1 = func&lt;double&gt;(52.134);</code>
<ul>
<li>函数的返回值指定为 double 类型，函数参数是通过实参推导出来的，为 double 类型</li>
</ul>
</li>
<li><code>auto ret3 = func&lt;int&gt;(52.134);</code>
<ul>
<li>函数的返回值指定为 int 类型，函数参数是通过实参推导出来的，为 double 类型</li>
</ul>
</li>
<li><code>auto ret4 = func&lt;char, int&gt;(100);</code>
<ul>
<li>函数的参数为指定为 int 类型，函数返回值指定为 char 类型，不需要推导</li>
</ul>
</li>
</ul>
<p>当默认模板参数和模板参数自动推导同时使用时（优先级从高到低）：</p>
<ul>
<li><strong>如果可以推导出参数类型则使用推导出的类型</strong></li>
<li><strong>如果函数模板无法推导出参数类型，那么编译器会使用默认模板参数</strong></li>
<li><strong>如果无法推导出模板参数类型并且没有设置默认模板参数，编译器就会报错。</strong></li>
</ul>
<p>看一下下面的例子：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 函数模板定义</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span> <span class="token operator">=</span> <span class="token keyword">char</span><span class="token operator">></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T arg1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> U arg2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"arg1: "</span> <span class="token operator">&lt;&lt;</span> arg1 <span class="token operator">&lt;&lt;</span> <span class="token string">", arg2: "</span> <span class="token operator">&lt;&lt;</span> arg2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">// 模板函数调用</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token comment">//func ();    // 编译报错</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment">// 测试输出</span></pre></td></tr><tr><td data-num="22"></td><td><pre>arg1<span class="token operator">:</span> a<span class="token punctuation">,</span> arg2<span class="token operator">:</span> d</pre></td></tr><tr><td data-num="23"></td><td><pre>arg1<span class="token operator">:</span> <span class="token number">97</span><span class="token punctuation">,</span> arg2<span class="token operator">:</span> a</pre></td></tr></table></figure><p>分析一下调用的模板函数 func ()：</p>
<ul>
<li><code>func('a');</code> ：参数 T 被自动推导为 char 类型，U 使用的默认模板参数为 char 类型</li>
<li><code>func(97, 'a');</code> ：参数 T 被自动推导为 int 类型，U 使用推导出的类型为 char</li>
<li><code>func();</code> ：参数 T 没有指定默认模板类型，并且无法自动推导，编译器会直接报错
<ul>
<li><strong>模板参数类型的自动推导是根据模板函数调用时指定的实参进行推断的</strong>，没有实参则无法推导</li>
<li>模板参数类型的自动推导不会参考函数模板中指定的默认参数。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="final-和-override"><a class="markdownIt-Anchor" href="#final-和-override">#</a> final 和 override</h2>
<hr>
<h2 id="超长整形-long-long"><a class="markdownIt-Anchor" href="#超长整形-long-long">#</a> 超长整形 long long</h2>
<hr>
<h2 id="静态断言-static_assert"><a class="markdownIt-Anchor" href="#静态断言-static_assert">#</a> 静态断言 static_assert</h2>
<hr>
<h2 id="原始字面量"><a class="markdownIt-Anchor" href="#原始字面量">#</a> 原始字面量</h2>
<hr>
<h1 id="c14"><a class="markdownIt-Anchor" href="#c14">#</a> C++14</h1>
<h1 id="c17"><a class="markdownIt-Anchor" href="#c17">#</a> C++17</h1>
<h2 id="结构化绑定"><a class="markdownIt-Anchor" href="#结构化绑定">#</a> 结构化绑定</h2>
<p>可以绑定 pair，tuple，数组，结构体，结构化绑定以后也可以修改原值，也可以使自定义类型支持结构化绑定，但是要修改 std</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">></span> <span class="token function">func_two</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">tuple</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">auto</span><span class="token punctuation">[</span>i<span class="token punctuation">,</span> d<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">func_two</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> mp <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span> <span class="token operator">:</span> mp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>pair <span class="token function">pa</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"hihi"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">auto</span><span class="token operator">&amp;</span><span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span> <span class="token operator">=</span> pa<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>输出：</pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token number">1</span> <span class="token number">2.2</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token number">0</span> a</pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token number">1</span> b</pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token number">4</span> hihi</pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token comment">/*       vector vec = &#123;1,2,3&#125;;</pre></td></tr><tr><td data-num="28"></td><td><pre>      auto&amp;[xx, yy, zz] = vec;</pre></td></tr><tr><td data-num="29"></td><td><pre>      cout &lt;&lt; xx &lt;&lt; endl; */</span> </pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token comment">//vector 当然不能使用结构化绑定啦</span></pre></td></tr></table></figure>
      <div class="tags">
          <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C++</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2023-05-04 10:20:01" itemprop="dateModified" datetime="2023-05-04T10:20:01+08:00">2023-05-04</time>
  </span>
  <span id="2023/04/02/C++11/" class="item leancloud_visitors" data-flag-title="C++11/14/17" title="阅读次数">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">阅读次数</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">次</span>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>AdventureYX <i class="ic i-at"><em>@</em></i>
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://adventure-yx.github.io/2023/04/02/C++11/" title="C++11&#x2F;14&#x2F;17">https://adventure-yx.github.io/2023/04/02/C++11/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aC1DTg=="><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2023/03/26/QML&QtQuick/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.picgo.net&#x2F;2023&#x2F;04&#x2F;02&#x2F;sky-134a7b41dbac28cfdf.jpeg" title="QML &amp; Qt Quick">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> Qt</span>
  <h3>QML & Qt Quick</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2023/04/20/qtchat/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.picgo.net&#x2F;2023&#x2F;04&#x2F;02&#x2F;sky-1683c8e10dd42012a8.jpeg" title="基于Qt框架实现网络聊天室">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> Qt</span>
  <h3>基于Qt框架实现网络聊天室</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.</span> <span class="toc-text"> 安全性 —— 智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88shared_ptr"><span class="toc-number">1.1.</span> <span class="toc-text"> 共享智能指针（shared_ptr）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shared_ptr%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.1.</span> <span class="toc-text"> shared_ptr 的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 通过构造函数初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%8B%B7%E8%B4%9D%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 通过拷贝和移动构造函数初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-stdmake_shared-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.4.</span> <span class="toc-text"> 通过 std::make_shared 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-reset-%E6%96%B9%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.5.</span> <span class="toc-text"> 通过 reset 方法初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88"><span class="toc-number">1.1.6.</span> <span class="toc-text"> 获取原始指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88unique_ptr"><span class="toc-number">1.2.</span> <span class="toc-text"> 独占智能指针（unique_ptr）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unique_ptr%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.1.</span> <span class="toc-text"> unique_ptr 的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%99%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 删除器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88weak_ptr"><span class="toc-number">1.3.</span> <span class="toc-text"> 弱引用智能指针（weak_ptr）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 其他常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#use_count"><span class="toc-number">1.3.2.1.</span> <span class="toc-text"> use_count()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#expired"><span class="toc-number">1.3.2.2.</span> <span class="toc-text"> expired()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lock"><span class="toc-number">1.3.2.3.</span> <span class="toc-text"> lock()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reset"><span class="toc-number">1.3.2.4.</span> <span class="toc-text"> reset()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%AE%A1%E7%90%86this%E7%9A%84shared_ptr"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 返回管理 this 的 shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.4.</span> <span class="toc-text"> 解决循环引用问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text"> 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84-chrono-%E5%BA%93"><span class="toc-number">2.1.</span> <span class="toc-text"> 处理日期和时间的 chrono 库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94-duration"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 时间间隔 duration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%82%B9-time-point"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 时间点 time point</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F-clocks"><span class="toc-number">2.1.3.</span> <span class="toc-text"> 时钟 clocks</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#system_clock"><span class="toc-number">2.1.3.1.</span> <span class="toc-text"> system_clock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#steady_clock"><span class="toc-number">2.1.3.2.</span> <span class="toc-text"> steady_clock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#high_resolution_clock"><span class="toc-number">2.1.3.3.</span> <span class="toc-text"> high_resolution_clock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.4.</span> <span class="toc-text"> 转换函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#duration_cast"><span class="toc-number">2.1.4.1.</span> <span class="toc-text"> duration_cast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#time_point_cast"><span class="toc-number">2.1.4.2.</span> <span class="toc-text"> time_point_cast</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%B1%BB-thread"><span class="toc-number">2.2.</span> <span class="toc-text"> 线程类 thread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 公共成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get_id"><span class="toc-number">2.2.3.</span> <span class="toc-text"> get_id()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-number">2.2.4.</span> <span class="toc-text"> join()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#detach"><span class="toc-number">2.2.5.</span> <span class="toc-text"> detach()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#joinable"><span class="toc-number">2.2.6.</span> <span class="toc-text"> joinable()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#operator"><span class="toc-number">2.2.7.</span> <span class="toc-text"> operator&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.8.</span> <span class="toc-text"> 静态函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-this_thread"><span class="toc-number">2.3.</span> <span class="toc-text"> 线程命名空间 this_thread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call_once-%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text"> call_once 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BA%92%E6%96%A5%E9%94%81-mutex"><span class="toc-number">2.5.</span> <span class="toc-text"> 线程同步之互斥锁 mutex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">2.6.</span> <span class="toc-text"> 线程同步之条件变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F-atomic"><span class="toc-number">2.7.</span> <span class="toc-text"> 线程同步之原子变量 atomic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5"><span class="toc-number">2.8.</span> <span class="toc-text"> 线程异步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%98%93%E5%AD%A6%E5%92%8C%E6%98%93%E7%94%A8%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text"> 易学和易用性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text"> lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 捕获列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%9C%AC%E8%B4%A8"><span class="toc-number">3.1.4.</span> <span class="toc-text"> 函数本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BC%E7%B1%BB%E5%9E%8B-nullptr"><span class="toc-number">3.2.</span> <span class="toc-text"> 指针空值类型 - nullptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">3.3.</span> <span class="toc-text"> 自动类型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto"><span class="toc-number">3.3.1.</span> <span class="toc-text"> auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype"><span class="toc-number">3.3.2.</span> <span class="toc-text"> decltype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c14-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">3.3.3.</span> <span class="toc-text"> c++14 函数返回类型推导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c17-auto%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.3.4.</span> <span class="toc-text"> c++17 auto 表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84-for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.4.</span> <span class="toc-text"> 基于范围的 for 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF%E6%96%B0%E8%AF%AD%E6%B3%95"><span class="toc-number">3.4.1.</span> <span class="toc-text"> for 循环新语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">3.4.2.</span> <span class="toc-text"> 使用细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87"><span class="toc-number">4.</span> <span class="toc-text"> 通用性能提升</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text"> 右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC-%E5%8F%B3%E5%80%BC"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 左值、右值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E5%8F%B3%E5%80%BC-%E5%B0%86%E4%BA%A1%E5%80%BC"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 纯右值、将亡值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-2"><span class="toc-number">4.1.3.</span> <span class="toc-text"> 右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">4.1.4.</span> <span class="toc-text"> 性能优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">4.2.</span> <span class="toc-text"> 转移和完美转发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#move"><span class="toc-number">4.2.1.</span> <span class="toc-text"> move</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forward"><span class="toc-number">4.2.2.</span> <span class="toc-text"> forward</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.3.</span> <span class="toc-text"> 列表初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.3.1.</span> <span class="toc-text"> 统一的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%BB%86%E8%8A%82"><span class="toc-number">4.3.2.</span> <span class="toc-text"> 初始化列表细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stdinitializer_list"><span class="toc-number">4.3.3.</span> <span class="toc-text"> std::initializer_list</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6-constexpr"><span class="toc-number">4.4.</span> <span class="toc-text"> 常量表达式修饰符 - constexpr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-number">4.4.1.</span> <span class="toc-text"> const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr"><span class="toc-number">4.4.2.</span> <span class="toc-text"> constexpr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.3.</span> <span class="toc-text"> 常量表达式函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.4.</span> <span class="toc-text"> 修饰普通函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.5.</span> <span class="toc-text"> 修饰模板函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.6.</span> <span class="toc-text"> 修饰构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text"> 委托构造函数和继承构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.1.</span> <span class="toc-text"> 委托构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.2.</span> <span class="toc-text"> 继承构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.6.</span> <span class="toc-text"> using 的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D"><span class="toc-number">4.6.1.</span> <span class="toc-text"> 定义别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%88%AB%E5%90%8D"><span class="toc-number">4.6.2.</span> <span class="toc-text"> 模板的别名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8-%E7%BB%91%E5%AE%9A%E5%99%A8"><span class="toc-number">4.7.</span> <span class="toc-text"> 可调用对象包装器、绑定器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pod-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.8.</span> <span class="toc-text"> POD 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6-default-%E4%B8%8E-delete"><span class="toc-number">4.9.</span> <span class="toc-text"> 默认函数控制 &#x3D;default 与 &#x3D;delete</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%9A%84-friend-%E8%AF%AD%E6%B3%95"><span class="toc-number">4.10.</span> <span class="toc-text"> 扩展的 friend 语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E7%B1%BB%E5%9E%8B%E6%9E%9A%E4%B8%BE"><span class="toc-number">4.11.</span> <span class="toc-text"> 强类型枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93"><span class="toc-number">4.12.</span> <span class="toc-text"> 非受限联合体</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%92%8C%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text"> 稳定性和兼容性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#noexcept"><span class="toc-number">5.1.</span> <span class="toc-text"> noexcept</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E5%BC%82%E5%B8%B8"><span class="toc-number">5.1.1.</span> <span class="toc-text"> C++ 异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E"><span class="toc-number">5.1.2.</span> <span class="toc-text"> 异常接口声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#noexcept%E5%BC%82%E5%B8%B8%E5%A3%B0%E6%98%8E"><span class="toc-number">5.1.3.</span> <span class="toc-text"> noexcept 异常声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E5%BF%AB%E9%80%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.2.</span> <span class="toc-text"> 类成员的快速初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B1%BB%E7%9A%84%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">5.2.1.</span> <span class="toc-text"> 初始化类的非静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%86%85%E9%83%A8%E8%B5%8B%E5%80%BC%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">5.2.2.</span> <span class="toc-text"> 类内部赋值和初始化列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.3.</span> <span class="toc-text"> 数值类型和字符串之间的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.3.1.</span> <span class="toc-text"> 数值转换为字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%80%BC"><span class="toc-number">5.3.2.</span> <span class="toc-text"> 字符串转换为数值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">5.4.</span> <span class="toc-text"> 模板的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8F%B3%E5%B0%96%E6%8B%AC%E5%8F%B7"><span class="toc-number">5.4.1.</span> <span class="toc-text"> 模板的右尖括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.2.</span> <span class="toc-text"> 默认模板参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final-%E5%92%8C-override"><span class="toc-number">5.5.</span> <span class="toc-text"> final 和 override</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E9%95%BF%E6%95%B4%E5%BD%A2-long-long"><span class="toc-number">5.6.</span> <span class="toc-text"> 超长整形 long long</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80-static_assert"><span class="toc-number">5.7.</span> <span class="toc-text"> 静态断言 static_assert</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">5.8.</span> <span class="toc-text"> 原始字面量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c14"><span class="toc-number">6.</span> <span class="toc-text"> C++14</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c17"><span class="toc-number">7.</span> <span class="toc-text"> C++17</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A"><span class="toc-number">7.1.</span> <span class="toc-text"> 结构化绑定</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li><a href="/2023/02/24/C++Study/" rel="bookmark" title="C++ Study">C++ Study</a></li><li><a href="/2023/03/05/C++%E9%9D%A2%E7%BB%8F/" rel="bookmark" title="C++面经">C++面经</a></li><li><a href="/2023/03/10/STL/" rel="bookmark" title="STL">STL</a></li><li class="active"><a href="/2023/04/02/C++11/" rel="bookmark" title="C++11/14/17">C++11/14/17</a></li><li><a href="/2023/05/25/MFC%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/" rel="bookmark" title="MFC 应用程序框架">MFC 应用程序框架</a></li><li><a href="/2023/05/26/MFC%E6%B6%88%E6%81%AF%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6/" rel="bookmark" title="MFC 消息映射机制">MFC 消息映射机制</a></li><li><a href="/2023/06/01/MFC%E5%AF%B9%E8%AF%9D%E6%A1%86/" rel="bookmark" title="MFC 对话框">MFC 对话框</a></li><li><a href="/2023/06/05/C++Boost%E5%BA%93%20%E5%87%BD%E6%95%B0%E4%B8%8E%E5%9B%9E%E8%B0%83/" rel="bookmark" title="C++Boost库 函数与回调">C++Boost库 函数与回调</a></li><li><a href="/2023/06/06/C++Boost%E5%BA%93%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="bookmark" title="C++Boost库 内存管理">C++Boost库 内存管理</a></li><li><a href="/2023/06/09/MFC%E5%B8%B8%E7%94%A8%E7%B1%BB/" rel="bookmark" title="MFC 常用类">MFC 常用类</a></li><li><a href="/2023/06/10/MFC%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/" rel="bookmark" title="MFC 常用控件">MFC 常用控件</a></li><li><a href="/2023/06/25/MFC%E6%96%87%E6%A1%A3%E8%A7%86%E5%9B%BE%E6%A1%86%E6%9E%B6/" rel="bookmark" title="MFC 文档/视图框架">MFC 文档/视图框架</a></li><li><a href="/2023/06/28/MFC%E5%9B%BE%E5%BD%A2%E5%9B%BE%E5%83%8F/" rel="bookmark" title="MFC 图形图像">MFC 图形图像</a></li><li><a href="/2023/07/10/MFC%20Debug%E8%AE%B0%E5%BD%95/" rel="bookmark" title="MFC Debug记录">MFC Debug记录</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="AdventureYX"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">AdventureYX</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">23</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">4</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">9</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FkdmVudHVyZS15eA==" title="https:&#x2F;&#x2F;github.com&#x2F;Adventure-yx"><i class="ic i-github"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2023/03/26/QML&QtQuick/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2023/04/20/qtchat/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Qt/" title="分类于 Qt">Qt</a>
</div>

    <span><a href="/2023/04/20/qtchat/" title="基于Qt框架实现网络聊天室">基于Qt框架实现网络聊天室</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/06/25/MFC%E6%96%87%E6%A1%A3%E8%A7%86%E5%9B%BE%E6%A1%86%E6%9E%B6/" title="MFC 文档&#x2F;视图框架">MFC 文档/视图框架</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/07/10/MFC%20Debug%E8%AE%B0%E5%BD%95/" title="MFC Debug记录">MFC Debug记录</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Qt/" title="分类于 Qt">Qt</a>
</div>

    <span><a href="/2023/05/04/showimg/" title="基于Qt的图片浏览器">基于Qt的图片浏览器</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/06/09/MFC%E5%B8%B8%E7%94%A8%E7%B1%BB/" title="MFC 常用类">MFC 常用类</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/03/05/C++%E9%9D%A2%E7%BB%8F/" title="C++面经">C++面经</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/06/28/MFC%E5%9B%BE%E5%BD%A2%E5%9B%BE%E5%83%8F/" title="MFC 图形图像">MFC 图形图像</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/04/02/C++11/" title="C++11&#x2F;14&#x2F;17">C++11/14/17</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Linux/" title="分类于 Linux">Linux</a>
</div>

    <span><a href="/2023/03/01/Linux/" title="Linux">Linux</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/06/10/MFC%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/" title="MFC 常用控件">MFC 常用控件</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2022 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">AdventureYX @ Adventure</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2023/04/02/C++11/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
