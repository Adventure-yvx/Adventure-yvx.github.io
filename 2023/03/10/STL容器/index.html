
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <title>STL容器 | Adventure</title>
        <meta name="author" content="AdventureYX" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>ADVENTURE</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" @click="shouMenuItems = !shouMenuItems" v-show="shouMenuItems"></div>
        <div class="title" @click="shouMenuItems = !shouMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ADVENTURE</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="shouMenuItems">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

            <transition name="into">
            <div id="main" v-show="!loading">
                <div class="article">
    <div>
        <h1>STL容器</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/10
        </span>
        
        <span class="category">
            <a href="/categories/C/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                C++
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            <span class="tag">
                
                <a href="/tags/C/" style="color: #00bcd4">C++</a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/STL/" style="color: #00bcd4">STL</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>vector为可变长数组（动态数组），定义的vector数组可以随时添加数值和删除元素。</p>
<p>在局部函数中开vector数组，是在堆空间里面开的，与开全局变量比较类似，所以经常见到在局部函数中开大容量数组。</p>
<ul>
<li><p>头文件</p>
<pre><code class="cpp">#include &lt;vector&gt;
</code></pre>
</li>
<li><p>初始化</p>
<ul>
<li><p>一维初始化</p>
<pre><code class="cpp">vector&lt;int&gt; a; //定义了一个名为num的存int数据的一维数组
vector&lt;double&gt; b;//定义了一个名为num的存double数据的一维数组
vector&lt;node&gt; c;//node是结构体类型
</code></pre>
<p>指定长度和初始值的初始化</p>
<pre><code class="cpp">vector&lt;int&gt; v(n);//定义一个长度为n的数组，初始值默认为0
vector&lt;int&gt; v(n, 1);//所有的元素初始值均为1
//注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了）
//就不能使用push_back()操作了
</code></pre>
<p>初始化中有多个元素</p>
<pre><code class="cpp">vector&lt;int&gt; a&#123;1, 2, 3, 4, 5&#125;;// 数组a中有五个元素
</code></pre>
<p>拷贝初始化</p>
<pre><code class="cpp">vector&lt;int&gt; a(n + 1, 0);
vector&lt;int&gt; b(a);//两个数组中的类型必须相同,a和b都是长度为n+1，所有值都为0的数组
</code></pre>
</li>
<li><p>二维初始化</p>
<p>定义第一维固定长度为5，第二维可变化的二维数组</p>
<pre><code class="cpp">vector&lt;int&gt; v[5];//定义可变长二维数组
//注意：行不可变（只有5行）, 而列可变,可以在指定行添加元素
//第一维固定长度为5，第二维长度可以改变
</code></pre>
<p>行列均可变</p>
<pre><code class="cpp">//初始化二维均可变长数组
vector&lt;vectot&lt;int&gt; &gt; v;//定义一个行和列均可变的二维数组
</code></pre>
<p>行列长度均固定 n + 1行 m + 1列初始值为0</p>
<pre><code class="cpp">vector&lt;vector&lt;int&gt; &gt; a(n + 1, vector&lt;int&gt;(m + 1, 0));
</code></pre>
<p><code>c++17</code>或者<code>c++20</code>支持的形式（不常用）</p>
<pre><code class="cpp">vector a(n + 1, vector(m + 1, 0));
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="方法函数"><a href="#方法函数" class="headerlink" title="方法函数"></a>方法函数</h2><p>知道了如何定义初始化可变数组，下面就需要知道如何添加，删除，修改数据。</p>
<p><strong>c指定为数组名称</strong>，含义中会注明算法复杂度。</p>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>c.front()</code></td>
<td align="left">返回第一个数据O(1)</td>
</tr>
<tr>
<td align="left"><code>c.pop_back()</code></td>
<td align="left">删除最后一个数据O(1)</td>
</tr>
<tr>
<td align="left"><code>c.push_back(element)</code></td>
<td align="left">在尾部加一个数据O(1)</td>
</tr>
<tr>
<td align="left"><code>c.size()</code></td>
<td align="left">返回实际数据个数（unsigned类型）O(1)</td>
</tr>
<tr>
<td align="left"><code>c.clear()</code></td>
<td align="left">清除元素个数O(N)，N为元素个数</td>
</tr>
<tr>
<td align="left"><code>c.resize(n, v)</code></td>
<td align="left">改变数组大小为<code>n</code>,<code>n</code>个空间数值赋为<code>v</code>，如果没有默认赋值为<code>0</code></td>
</tr>
<tr>
<td align="left"><code>c.insert(it, x)</code></td>
<td align="left">向任意迭代器<code>it</code>插入一个元素<code>x</code> ，O(N)</td>
</tr>
<tr>
<td align="left">例：<code>c.insert(c.begin()+2,-1)</code></td>
<td align="left">将<code>-1</code>插入<code>c[2]</code>的位置</td>
</tr>
<tr>
<td align="left"><code>c.erase(first,last)</code></td>
<td align="left">删除<code>[first,last)</code>的所有元素，O(N)</td>
</tr>
<tr>
<td align="left"><code>c.begin()</code></td>
<td align="left">返回首元素的迭代器（通俗来说就是地址）O(1)</td>
</tr>
<tr>
<td align="left"><code>c.end()</code></td>
<td align="left">返回最后一个元素后一个位置的迭代器（地址）O(1)</td>
</tr>
<tr>
<td align="left"><code>c.empty()</code></td>
<td align="left">判断是否为空，为空返回真，反之返回假 O(1)</td>
</tr>
</tbody></table>
<p>注意： <code>end()</code>返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，<strong>所有STL容器均是如此</strong></p>
<p>排序</p>
<p>使用sort排序要： <code>sort(c.begin(),c.end())</code>;</p>
<p>对所有元素进行排序，如果要对指定区间进行排序，可以对sort()里面的参数进行加减改动。</p>
<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p><strong>下标法</strong>： 和普通数组一样</p>
<p>注意：一维数组的下标是从0到v.size( ) − 1，访问之外的数会出现越界错误</p>
<p>迭代器法： 类似指针一样的访问 ，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码进行理解（附有注释）。</p>
<p>代码如下：</p>
<pre><code class="cpp">vector&lt;int&gt; vi; //定义一个vi数组
vector&lt;int&gt;::iterator it = vi.begin();//声明一个迭代器指向vi的初始位置
</code></pre>
<p><strong>下标访问</strong></p>
<pre><code class="cpp">//添加元素
for(int i = 0; i &lt; 5; i++)
    vi.push_back(i);
    
//下标访问 
for(int i = 0; i &lt; 5; i++)
    cout &lt;&lt; vi[i] &lt;&lt; &quot; &quot;;
cout &lt;&lt; &quot;\n&quot;;
</code></pre>
<p><strong>迭代器访问</strong></p>
<p>类似指针。</p>
<pre><code class="cpp">//迭代器访问
vector&lt;int&gt;::iterator it;   
//相当于声明了一个迭代器类型的变量it
//通俗来说就是声明了一个指针变量

//方式一：
vector&lt;int&gt;::iterator it = vi.begin(); 
for(int i = 0; i &lt; 5; i++)
    cout &lt;&lt; *(it + i) &lt;&lt; &quot; &quot;;
cout &lt;&lt; &quot;\n&quot;;

//方式二：
vector&lt;int&gt;::iterator it;
for(it = vi.begin(); it != vi.end();it ++)
    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
//vi.end()指向尾元素地址的下一个地址
</code></pre>
<p><strong>智能指针</strong></p>
<p><strong>只能遍历完数组</strong>，如果要指定的内容进行遍历，需要另选方法。<br><strong>auto</strong> 能够自动识别并获取类型。</p>
<pre><code class="cpp">vector&lt;int&gt; v;
v.push_back(12);
v.push_back(241);
for(auto val : v) 
    cout &lt;&lt; val &lt;&lt; &quot; &quot;; // 12 241
</code></pre>
<p><code>vector</code>注意：</p>
<ul>
<li><code>vi[i]</code> 和 <code>*(vi.begin() + i)</code> 等价</li>
<li><code>vector</code>和<code>string</code>的<code>STL</code>容器支持<code>*(it + i)</code>的元素访问，其它容器可能也可以支持这种方式访问，但用的不多，可自行尝试。</li>
</ul>
<h2 id="Vector原理"><a href="#Vector原理" class="headerlink" title="Vector原理"></a>Vector原理</h2><ul>
<li>vector是动态数组，所以和数组一样拥有一段连续的内存空间，并且起始地址不变。</li>
<li>因为vector地址空间是连续的，所以能高效的进行随机访问，时间复杂度为o(1)。</li>
<li>在vector中插入和删除元素，需要对现有元素进行复制、移动，时间复杂度为o(n)。</li>
<li>如果vector中存储的对象很大，或者构造函数复杂，那么插入等开销会很大。因为拷贝现有对象时需要调用拷贝构造函数。</li>
<li>vector扩容原理<ul>
<li>新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就会分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。注意不是在原来空间后直接增加空间</li>
<li>对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。</li>
<li>不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。</li>
</ul>
</li>
</ul>
<h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p>栈为数据结构的一种，是STL中实现的一个先进后出，后进先出的容器。</p>
<pre><code class="cpp">//头文件需要添加
#include&lt;stack&gt;

//声明
stack&lt;int&gt; s;
stack&lt;string&gt; s;
stack&lt;node&gt; s;//node是结构体类型
</code></pre>
<h2 id="方法函数-1"><a href="#方法函数-1" class="headerlink" title="方法函数"></a>方法函数</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>s.push(ele)</code></td>
<td align="left">元素<code>ele</code>入栈，增加元素 O(1)</td>
</tr>
<tr>
<td align="left"><code>s.pop()</code></td>
<td align="left">移除栈顶元素 O(1)</td>
</tr>
<tr>
<td align="left"><code>s.top()</code></td>
<td align="left">取得栈顶元素（但不删除）O(1)</td>
</tr>
<tr>
<td align="left"><code>s.empty()</code></td>
<td align="left">检测栈内是否为空，空为真 O(1)</td>
</tr>
<tr>
<td align="left"><code>s.size()</code></td>
<td align="left">返回栈内元素的个数 O(1)</td>
</tr>
</tbody></table>
<h2 id="栈遍历"><a href="#栈遍历" class="headerlink" title="栈遍历"></a>栈遍历</h2><p><strong>栈遍历</strong></p>
<p>栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中</p>
<p><strong>数组模拟栈进行遍历</strong></p>
<p>通过一个<strong>数组</strong>对栈进行模拟，一个存放下标的变量<code>top</code>模拟指向栈顶的指针。</p>
<p><strong>特点：</strong> 比<code>STL</code>的<code>stack</code>速度更快，遍历元素方便</p>
<pre><code class="cpp">int s[100]; // 栈 从左至右为栈底到栈顶
int tt = -1; // tt 代表栈顶指针,初始栈内无元素，tt为-1

for(int i = 0; i &lt;= 5; i++)
&#123;
    //入栈 
    s[++tt] = i;
&#125;
// 出栈
int top_element = s[tt--]; 

//入栈操作示意
//  0  1  2  3  4  5  
//                tt
//出栈后示意
//  0  1  2  3  4 
//              tt
</code></pre>
<h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><p>队列是一种先进先出的数据结构。</p>
<pre><code class="cpp">//头文件
#include&lt;queue&gt;
//定义初始化
queue&lt;int&gt; q;
</code></pre>
<h2 id="方法函数-2"><a href="#方法函数-2" class="headerlink" title="方法函数"></a>方法函数</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>q.front()</code></td>
<td align="left">返回队首元素 O(1)</td>
</tr>
<tr>
<td align="left"><code>q.back()</code></td>
<td align="left">返回队尾元素 O(1)</td>
</tr>
<tr>
<td align="left"><code>q.push(element)</code></td>
<td align="left">尾部添加一个元素<code>element</code> 进队O(1)</td>
</tr>
<tr>
<td align="left"><code>q.pop()</code></td>
<td align="left">删除第一个元素 出队 O(1)</td>
</tr>
<tr>
<td align="left"><code>q.size()</code></td>
<td align="left">返回队列中元素个数，返回值类型<code>unsigned int</code> O(1)</td>
</tr>
<tr>
<td align="left"><code>q.empty()</code></td>
<td align="left">判断是否为空，队列为空，返回<code>true</code> O(1)</td>
</tr>
</tbody></table>
<h2 id="队列模拟"><a href="#队列模拟" class="headerlink" title="队列模拟"></a>队列模拟</h2><p>使用<code>q[]</code>数组模拟队列<br><code>hh</code>表示队首元素的下标，初始值为<code>0</code><br><code>tt</code>表示队尾元素的下标，初始值为<code>-1</code>，表示刚<strong>开始队列为空</strong></p>
<pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5+5;
int q[N];

int main()
&#123;
    int hh = 0,tt = -1;
//    入队 
    q[++tt] = 1;
    q[++tt] = 2; 
//    将所有元素出队 
    while(hh &lt;= tt)
    &#123;
        int t = q[hh++];
        printf(&quot;%d &quot;,t);
    &#125;
    return 0;
 &#125; 
</code></pre>
<h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><p>首尾都可插入和删除的队列为双端队列。</p>
<pre><code class="cpp">//添加头文件
#include &lt;deque&gt;
//初始化定义
deque&lt;int&gt; dq;
</code></pre>
<h2 id="方法函数-3"><a href="#方法函数-3" class="headerlink" title="方法函数"></a>方法函数</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>push_back(x)/push_front(x)</code></td>
<td align="left">把<code>x</code>插入队尾后 &#x2F; 队首 O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>back()/front()</code></td>
<td align="left">返回队尾 &#x2F; 队首元素 O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>pop_back() / pop_front()</code></td>
<td align="left">删除队尾 &#x2F; 队首元素 O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>erase(iterator it)</code></td>
<td align="left">删除双端队列中的某一个元素</td>
</tr>
<tr>
<td align="left"><code>erase(iterator first,iterator last)</code></td>
<td align="left">删除双端队列中<code>[first,last)</code>中的元素</td>
</tr>
<tr>
<td align="left"><code>empty()</code></td>
<td align="left">判断deque是否空 O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>size()</code></td>
<td align="left">返回deque的元素数量 O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>clear()</code></td>
<td align="left">清空deque</td>
</tr>
</tbody></table>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>deque可以进行排序</p>
<pre><code class="cpp">//从小到大
sort(q.begin(), q.end())
//从大到小排序
sort(q.begin(), q.end(), greater&lt;int&gt;());//deque里面的类型需要是int型
sort(q.begin(), q.end(), greater());//高版本C++才可以用
</code></pre>
<h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><p>优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。</p>
<p>可以实现每次从优先队列中取出的元素都是队列中<strong>优先级最大</strong>的一个。</p>
<p>它的底层是通过<strong>堆</strong>来实现的。</p>
<pre><code class="cpp">//头文件
#include&lt;queue&gt;
//初始化定义
priority_queue&lt;int&gt; q;
</code></pre>
<h2 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>q.top()</code></td>
<td align="left">访问队首元素</td>
</tr>
<tr>
<td align="left"><code>q.push()</code></td>
<td align="left">入队</td>
</tr>
<tr>
<td align="left"><code>q.pop()</code></td>
<td align="left">堆顶（队首）元素出队</td>
</tr>
<tr>
<td align="left"><code>q.size()</code></td>
<td align="left">队列元素个数</td>
</tr>
<tr>
<td align="left"><code>q.empty()</code></td>
<td align="left">是否为空</td>
</tr>
<tr>
<td align="left"><strong>注意</strong>没有<code>clear()</code>！</td>
<td align="left">不提供该方法</td>
</tr>
<tr>
<td align="left">优先队列只能通过<code>top()</code>访问队首元素（优先级最高的元素）</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="设置优先级"><a href="#设置优先级" class="headerlink" title="设置优先级"></a>设置优先级</h2><h3 id="基本数据类型的优先级"><a href="#基本数据类型的优先级" class="headerlink" title="基本数据类型的优先级"></a>基本数据类型的优先级</h3><pre><code class="cpp">priority_queue&lt;int&gt; pq; // 默认大根堆, 即每次取出的元素是队列中的最大值
priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; // 小根堆, 每次取出的元素是队列中的最小值
</code></pre>
<p><strong>参数解释：</strong></p>
<ul>
<li><strong>第二个参数：</strong><br><code>vector&lt; int &gt;</code> 是用来承载底层数据结构堆的容器，若优先队列中存放的是<code>double</code>型数据，就要填<code>vector&lt; double &gt;</code><br><strong>总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。</strong></li>
<li><strong>第三个参数：</strong><br><code>less&lt; int &gt;</code> 表示数字大的优先级大，堆顶为最大的数字<br><code>greater&lt; int &gt;</code>表示数字小的优先级大，堆顶为最小的数字<br><strong>int代表的是数据类型，也要填优先队列中存储的数据类型</strong></li>
</ul>
<p>下面介绍基础数据类型优先级设置的写法。</p>
<p><strong>1. 基础写法（非常常用）</strong></p>
<pre><code class="cpp">priority_queue&lt;int&gt; q1; // 默认大根堆, 即每次取出的元素是队列中的最大值
priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q2; // 大根堆, 每次取出的元素是队列中的最大值，同第一行

priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q3; // 小根堆, 每次取出的元素是队列中的最小值
</code></pre>
<p><strong>2. 自定义排序（不常见，主要是写着麻烦）</strong></p>
<p>下面的代码比较长，基础类型优先级写着太麻烦，用第一种即可。</p>
<pre><code class="cpp">struct cmp1
&#123;
    bool operator()(int x,int y)
    &#123;
        return x &gt; y;
    &#125;
&#125;;
struct cmp2
&#123;
    bool operator()(const int x,const int y)
    &#123;
        return x &lt; y;
    &#125;
&#125;;
priority_queue&lt;int, vector&lt;int&gt;, cmp1&gt; q1; // 小根堆
priority_queue&lt;int, vector&lt;int&gt;, cmp2&gt; q2; // 大根堆
</code></pre>
<h3 id="结构体优先级设置"><a href="#结构体优先级设置" class="headerlink" title="结构体优先级设置"></a>结构体优先级设置</h3><blockquote>
<p>即优先队列中存储结构体类型，必须要设置优先级，即结构体的比较运算（因为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶）。</p>
</blockquote>
<p>优先级设置可以定义在<strong>结构体内</strong>进行小于号重载，也可以定义在<strong>结构体外</strong>。</p>
<h3 id="存储特殊类型的优先级"><a href="#存储特殊类型的优先级" class="headerlink" title="存储特殊类型的优先级"></a>存储特殊类型的优先级</h3><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>映射类似于函数的对应关系，每个<code>x</code>对应一个<code>y</code>，而<code>map</code>是每个键对应一个值。会python的朋友学习后就会知道这和python的字典非常类似。</p>
<blockquote>
<p>比如说：学习 对应 看书，学习 是键，看书 是值。<br>学习-&gt;看书<br>玩耍 对应 打游戏，玩耍 是键，打游戏 是值。<br>玩耍-&gt;打游戏</p>
</blockquote>
<pre><code class="cpp">//头文件
#include&lt;map&gt;
//初始化定义
map&lt;string,string&gt; mp;
map&lt;string,int&gt; mp;
map&lt;int,node&gt; mp;//node是结构体类型
</code></pre>
<blockquote>
<p>map特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小</p>
</blockquote>
<h2 id="函数方法-1"><a href="#函数方法-1" class="headerlink" title="函数方法"></a>函数方法</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>mp.find(key)</code></td>
<td align="left">返回键为key的映射的迭代器 O(logN)注意：用find函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end()</td>
</tr>
<tr>
<td align="left"><code>mp.erase(it)</code></td>
<td align="left">删除迭代器对应的键和值O(1)</td>
</tr>
<tr>
<td align="left"><code>mp.erase(key)</code></td>
<td align="left">根据映射的键删除键和值 O(logN)</td>
</tr>
<tr>
<td align="left"><code>mp.erase(first,last)</code></td>
<td align="left">删除左闭右开区间迭代器对应的键和值 O(last−first)</td>
</tr>
<tr>
<td align="left"><code>mp.size()</code></td>
<td align="left">返回映射的对数O(1)</td>
</tr>
<tr>
<td align="left"><code>mp.clear()</code></td>
<td align="left">清空map中的所有元素O(N)</td>
</tr>
<tr>
<td align="left"><code>mp.insert()</code></td>
<td align="left">插入元素，插入时要构造键值对</td>
</tr>
<tr>
<td align="left"><code>mp.empty()</code></td>
<td align="left">如果map为空，返回true，否则返回false</td>
</tr>
<tr>
<td align="left"><code>mp.begin()</code></td>
<td align="left">返回指向map第一个元素的迭代器（地址）</td>
</tr>
<tr>
<td align="left"><code>mp.end()</code></td>
<td align="left">返回指向map尾部的迭代器（最后一个元素的<strong>下一个</strong>地址）</td>
</tr>
<tr>
<td align="left"><code>mp.rbegin()</code></td>
<td align="left">返回指向map最后一个元素的迭代器（地址）</td>
</tr>
<tr>
<td align="left"><code>mp.rend()</code></td>
<td align="left">返回指向map第一个元素前面(上一个）的逆向迭代器（地址）</td>
</tr>
<tr>
<td align="left"><code>mp.count(key)</code></td>
<td align="left">查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0</td>
</tr>
<tr>
<td align="left"><code>mp.lower_bound()</code></td>
<td align="left">返回一个迭代器，指向键值&gt;&#x3D; <strong>key</strong>的第一个元素</td>
</tr>
<tr>
<td align="left"><code>mp.upper_bound()</code></td>
<td align="left">返回一个迭代器，指向键值&gt; key的第一个元素</td>
</tr>
</tbody></table>
<p><strong>下面说明部分函数方法的注意点</strong></p>
<blockquote>
<p>注意：<br>查找元素是否存在时，可以使用<br>①<code>mp.find()</code> ② <code>mp.count()</code> ③ <code>mp[key]</code><br>但是第三种情况，如果不存在对应的<code>key</code>时，会自动创建一个键值对（产生一个额外的键值对空间）<br>所以为了不增加额外的空间负担，最好使用前两种方法</p>
</blockquote>
<hr>
<p><strong>使用迭代器进行正反向遍历：</strong></p>
<p><code>mp.begin()</code>和<code>mp.end()</code>用法：<br><strong>用于正向遍历map</strong></p>
<pre><code class="cpp">map&lt;int,int&gt; mp;
mp[1] = 2;
mp[2] = 3;
mp[3] = 4;
auto it = mp.begin();
while(it != mp.end())
&#123;
    cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\n&quot;;
    it ++;
&#125;

/*输出
1 2
2 3
3 4
*/
</code></pre>
<p><code>mp.rbegin()</code>和<code>mp.rend()</code><br><strong>用于逆向遍历map</strong></p>
<pre><code class="cpp">map&lt;int,int&gt; mp;
mp[1] = 2;
mp[2] = 3;
mp[3] = 4;
auto it = mp.rbegin();
while(it != mp.rend())
&#123;
    cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\n&quot;;
    it ++;
&#125;

/*输出
3 4
2 3
1 2
*/
</code></pre>
<p>二分查找<code>lower_bound() upper_bound()</code></p>
<blockquote>
<p>map的二分查找以第一个元素（即键为准），对<strong>键</strong>进行二分查找<br>返回值为map迭代器类型</p>
</blockquote>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

int main()
&#123;
    map&lt;int, int&gt; m&#123;&#123;1, 2&#125;, &#123;2, 2&#125;, &#123;1, 2&#125;, &#123;8, 2&#125;, &#123;6, 2&#125;&#125;;//有序
    map&lt;int, int&gt;::iterator it1 = m.lower_bound(2);
    cout &lt;&lt; it1-&gt;first &lt;&lt; &quot;\n&quot;;//it1-&gt;first=2
    map&lt;int, int&gt;::iterator it2 = m.upper_bound(2);
    cout &lt;&lt; it2-&gt;first &lt;&lt; &quot;\n&quot;;//it2-&gt;first=6
    return 0;
&#125;
</code></pre>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><pre><code class="cpp">//先声明
map&lt;string,string&gt; mp;

//方式一
mp[&quot;学习&quot;] = &quot;看书&quot;;
mp[&quot;玩耍&quot;] = &quot;打游戏&quot;;

//方式二：插入元素构造键值对
mp.insert(make_pair(&quot;vegetable&quot;,&quot;蔬菜&quot;));

//方式三
mp.insert(pair&lt;string,string&gt;(&quot;fruit&quot;,&quot;水果&quot;));

//方式四
mp.insert(&#123;&quot;hahaha&quot;,&quot;wawawa&quot;&#125;);
</code></pre>
<h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><p><strong>6.4.1 下标访问：</strong>大部分情况用于访问单个元素</p>
<pre><code class="cpp">mp[&quot;菜哇菜&quot;] = &quot;强哇强&quot;;
cout &lt;&lt; mp[&quot;菜哇菜&quot;] &lt;&lt; &quot;\n&quot;;//只是简写的一个例子，程序并不完整
</code></pre>
<p><strong>6.4.2 遍历访问：</strong></p>
<p><strong>方式一：迭代器访问</strong></p>
<pre><code class="cpp">map&lt;string,string&gt;::iterator it;
for(it = mp.begin(); it != mp.end(); it++)
&#123;
    //      键                 值 
    // it是结构体指针访问所以要用 -&gt; 访问
    cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\n&quot;;
    //*it是结构体变量 访问要用 . 访问
    //cout&lt;&lt;(*it).first&lt;&lt;&quot; &quot;&lt;&lt;(*it).second;
&#125;
</code></pre>
<p><strong>方式二：智能指针访问</strong></p>
<pre><code class="cpp">for(auto i : mp)
cout &lt;&lt; i.first &lt;&lt; &quot; &quot; &lt;&lt; i.second &lt;&lt; endl;//键，值
</code></pre>
<p><strong>方式三：对指定单个元素访问</strong></p>
<pre><code class="cpp">map&lt;char,int&gt;::iterator it = mp.find(&#39;a&#39;);
cout &lt;&lt; it -&gt; first &lt;&lt; &quot; &quot; &lt;&lt;  it-&gt;second &lt;&lt; &quot;\n&quot;;
</code></pre>
<p><strong>方式四：c++17特性才具有</strong></p>
<pre><code class="cpp">for(auto [x, y] : mp)
    cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;;
//x,y对应键和值
</code></pre>
<h2 id="与unordered-map的比较"><a href="#与unordered-map的比较" class="headerlink" title="与unordered_map的比较"></a>与unordered_map的比较</h2><p>这里就不单开一个大目录讲unordered_map了，直接在map里面讲了。</p>
<h3 id="内部实现原理"><a href="#内部实现原理" class="headerlink" title="内部实现原理"></a>内部实现原理</h3><p><strong>map</strong>：内部用<strong>红黑树</strong>实现，具有<strong>自动排序</strong>（按键从小到大）功能。</p>
<p><strong>unordered_map</strong>：内部用<strong>哈希表</strong>实现，内部元素无序杂乱。</p>
<h3 id="效率比较"><a href="#效率比较" class="headerlink" title="效率比较"></a>效率比较</h3><p><strong>map</strong>：</p>
<ul>
<li>优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为O(logN)</li>
<li>缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。</li>
</ul>
<p><strong>unordered_map</strong>：</p>
<ul>
<li>优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。</li>
<li>缺点：建立哈希表比较耗时。</li>
</ul>
<blockquote>
<p>两者方法函数基本一样，差别不大。</p>
<p>注意：</p>
<ul>
<li><p>随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。</p>
</li>
<li><p>使用<code>[]</code>查找元素时，如果元素不存在，两种容器<strong>都是</strong>创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会<strong>大大降低</strong>。</p>
</li>
<li><p>查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）</p>
<pre><code class="cpp">// 以 map 为例
map&lt;int, int&gt; mp;
int x = 999999999;
if(mp.count(x)) // 此处判断是否存在x这个键
    cout &lt;&lt; mp[x] &lt;&lt; &quot;\n&quot;;   // 只有存在才会索引对应的值，避免不存在x时多余空元素的创建
</code></pre>
</li>
</ul>
</blockquote>
<p>还有一种映射：</p>
<p><a target="_blank" rel="noopener" href="https://wyqz.top/p/870124582.html">multimap</a><br>键可以重复，即一个键对应多个值，如要了解，可以自行搜索。</p>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。</p>
<p>即：set里面的元素<strong>不重复 且有序</strong></p>
<pre><code class="cpp">//头文件
#include&lt;set&gt;
//初始化定义
set&lt;int&gt; s;
</code></pre>
<h2 id="函数方法-2"><a href="#函数方法-2" class="headerlink" title="函数方法"></a>函数方法</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>s.begin()</code></td>
<td align="left">返回set容器的第一个元素的地址（迭代器）O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>s.end()</code></td>
<td align="left">返回set容器的最后一个元素的下一个地址（迭代器）O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>s.rbegin()</code></td>
<td align="left">返回逆序迭代器，指向容器元素最后一个位置O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>s.rend()</code></td>
<td align="left">返回逆序迭代器，指向容器第一个元素前面的位置O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>s.clear()</code></td>
<td align="left">删除set容器中的所有的元素,返回unsigned int类型O(N)�(�)</td>
</tr>
<tr>
<td align="left"><code>s.empty()</code></td>
<td align="left">判断set容器是否为空O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>s.insert()</code></td>
<td align="left">插入一个元素</td>
</tr>
<tr>
<td align="left"><code>s.size()</code></td>
<td align="left">返回当前set容器中的元素个数O(1)�(1)</td>
</tr>
<tr>
<td align="left"><code>erase(iterator)</code></td>
<td align="left">删除定位器iterator指向的值</td>
</tr>
<tr>
<td align="left"><code>erase(first,second）</code></td>
<td align="left">删除定位器first和second之间的值</td>
</tr>
<tr>
<td align="left"><code>erase(key_value)</code></td>
<td align="left">删除键值key_value的值</td>
</tr>
<tr>
<td align="left">查找</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s.find(element)</code></td>
<td align="left">查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器</td>
</tr>
<tr>
<td align="left"><code>s.count(element)</code></td>
<td align="left">查找set中的元素出现的个数，由于set中元素唯一，此函数相当于查询element是否出现</td>
</tr>
<tr>
<td align="left"><code>s.lower_bound(k)</code></td>
<td align="left">返回大于等于k的第一个元素的迭代器O(logN)�(����)</td>
</tr>
<tr>
<td align="left"><code>s.upper_bound(k)</code></td>
<td align="left">返回大于k的第一个元素的迭代器O(logN)�(����)</td>
</tr>
</tbody></table>
<h2 id="访问-1"><a href="#访问-1" class="headerlink" title="访问"></a>访问</h2><h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><p>pair只含有两个元素，可以看作是只有两个元素的结构体。<br><strong>应用：</strong></p>
<ul>
<li>代替二元结构体</li>
<li>作为map键值对进行插入（代码如下）</li>
</ul>
<pre><code class="cpp">map&lt;string,int&gt;mp;
mp.insert(pair&lt;string,int&gt;(&quot;xingmaqi&quot;,1));
</code></pre>
<pre><code class="cpp">//头文件
#include&lt;utility&gt;

//1.初始化定义
pair&lt;string,int&gt; p(&quot;wangyaqi&quot;,1);//带初始值的
pair&lt;string,int&gt; p;//不带初始值的

//2.赋值
p = &#123;&quot;wang&quot;,18&#125;;
</code></pre>
<h2 id="访问-2"><a href="#访问-2" class="headerlink" title="访问"></a>访问</h2><pre><code class="cpp">//定义结构体数组
pair&lt;int,int&gt;p[20];
for(int i = 0; i &lt; 20; i++)
&#123;
    //和结构体类似，first代表第一个元素，second代表第二个元素
    cout &lt;&lt; p[i].first &lt;&lt; &quot; &quot; &lt;&lt; p[i].second;
&#125;
</code></pre>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>string是一个字符串类，和<code>char</code>型字符串类似。</p>
<p>可以把string理解为一个字符串类型，像int一样可以定义</p>
<h2 id="初始化及定义"><a href="#初始化及定义" class="headerlink" title="初始化及定义"></a>初始化及定义</h2><pre><code class="cpp">//头文件
#include&lt;string&gt;

//1.
string str1; //生成空字符串

//2.
string str2(&quot;123456789&quot;); //生成&quot;1234456789&quot;的复制品 

//3.
string str3(&quot;12345&quot;, 0, 3);//结果为&quot;123&quot; ，从0位置开始，长度为3

//4.
string str4(&quot;123456&quot;, 5); //结果为&quot;12345&quot; ，长度为5

//5.
string str5(5, &#39;2&#39;); //结果为&quot;22222&quot; ,构造5个字符&#39;2&#39;连接而成的字符串

//6.
string str6(str2, 2); //结果为&quot;3456789&quot;，截取第三个元素（2对应第三位）到最后
</code></pre>
<p><strong>简单使用</strong></p>
<ul>
<li><p>访问单个字符：</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
&#123;
    string s = &quot;xing ma qi!!!&quot;;
    for(int i = 0; i &lt; s.size(); i++)
        cout &lt;&lt; s[i] &lt;&lt; &quot; &quot;;
    return 0;
&#125;
</code></pre>
</li>
</ul>
<ul>
<li><p>string数组使用：</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
&#123;
    string s[10];
    for(int i = 1; i &lt; 10; i++)
    &#123;
        s[i] = &quot;loading...  &quot; ;
        cout &lt;&lt; s[i] &lt;&lt; i &lt;&lt; &quot;\n&quot;;
    &#125; 
    return 0;
&#125;
</code></pre>
<p>结果：</p>
<pre><code class="cpp">loading...  1
loading...  2
loading...  3
loading...  4
loading...  5
loading...  6
loading...  7
loading...  8
loading...  9
</code></pre>
</li>
</ul>
<h2 id="string-特性"><a href="#string-特性" class="headerlink" title="string 特性"></a>string 特性</h2><ul>
<li><p>支持<strong>比较</strong>运算符<br>string字符串支持常见的比较操作符<code>（&gt;,&gt;=,&lt;,&lt;=,==,!=）</code>，支持<code>string</code>与<code>C-string</code>的比较（如 <code>str &lt; &quot;hello&quot;</code>）。<br>在使用<code>&gt;,&gt;=,&lt;,&lt;=</code>这些操作符的时候是根据“当前字符特性”将字符按 <code>字典顺序</code> 进行逐一得 比较。字典排序靠前的字符小， 比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。</p>
<p>同时，&#96;string (“aaaa”) 。</p>
<ul>
<li><p>支持<code>+</code><strong>运算</strong>符，代表拼接字符串<br>string字符串可以拼接，通过”+”运算符进行拼接。</p>
<pre><code class="cpp">string s1 = &quot;123&quot;;
string s2 = &quot;456&quot;;
string s = s1 + s2;
cout &lt;&lt; s;   //123456
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="读入详解"><a href="#读入详解" class="headerlink" title="读入详解"></a>读入详解</h2><p><strong>读入字符串，遇空格，回车结束</strong></p>
<pre><code class="cpp">string s;
cin &gt;&gt; s;
</code></pre>
<p><strong>读入一行字符串（包括空格），遇回车结束</strong></p>
<pre><code class="cpp">string s;
getline(cin, s);
</code></pre>
<p>注意: <code>getline(cin, s)</code>会获取前一个输入的换行符，需要在前面添加读取换行符的语句。如：<code>getchar()</code> 或<code>cin.get()</code></p>
<p>错误读取：</p>
<pre><code class="cpp">int n;
string s;
cin &gt;&gt; n;
getline(cin, s); //此时读取相当于读取了前一个回车字符
</code></pre>
<p>正确读取：</p>
<pre><code class="cpp">int n;
string s;
cin &gt;&gt; n;
getchar(); //cin.get()
getline(cin, s);//可正确读入下一行的输入
</code></pre>
<blockquote>
<p><code>cin</code>与<code>cin.getline()</code>混用</p>
<p>cin输入完后，回车，cin遇到回车结束输入，但回车还在输入流中，cin并不会清除，导致<code>getline()</code>读取回车，结束。<br>需要在cin后面加<code>cin.ignore()</code>；主动删除输入流中的换行符。（不常用）</p>
</blockquote>
<p><strong>cin和cout解锁</strong></p>
<p>代码（写在main函数开头）：</p>
<pre><code class="cpp">ios::sync_with_stdio(false);
cin.tie(0),cout.tie(0);
</code></pre>
<blockquote>
<p>为什么要进行<code>cin</code>和<code>cout</code>的解锁，原因是：</p>
<p>在一些题目中，读入的<strong>数据量很大</strong>，往往超过了1e5（10^5^）的数据量,而<code>cin</code>和<code>cout</code>的读入输出的速度<strong>很慢</strong>（是因为<code>cin</code>和<code>cout</code>为了兼容C语言的读入输出在性能上做了妥协），远不如<code>scanf</code>和<code>printf</code>的速度，具体原因可以搜索相关的博客进行了解。</p>
<p><strong>所以</strong>对<code>cin</code>和<code>cout</code>进行解锁使<code>cin</code>和<code>cout</code>的速度几乎接近<code>scanf</code>和<code>printf</code>，避免输入输出超时。</p>
</blockquote>
<p><strong>注意</strong>：<code>cin cout</code>解锁使用时，不能与 <code>scanf,getchar, printf,cin.getline()</code>混用，一定要注意，会出错。</p>
<blockquote>
<p><strong>string与C语言字符串（C-string）的区别</strong></p>
<ul>
<li>string<br>是C++的一个类，专门实现字符串的相关操作。具有丰富的操作方法，数据类型为<code>string</code>，字符串结尾没有<code>\0</code>字符</li>
<li>C-string<br>C语言中的字符串，用char数组实现，类型为<code>const char *</code>,字符串结尾以<code>\0</code>结尾</li>
</ul>
</blockquote>
<p>一般来说string向char数组转换会出现一些问题，所以为了能够实现转换，string有一个方法<code>c_str()</code>实现string向char数组的转换。</p>
<pre><code class="cpp">string s = &quot;xing ma qi&quot;;
char s2[] = s.c_str();
</code></pre>
<h2 id="函数方法-3"><a href="#函数方法-3" class="headerlink" title="函数方法"></a>函数方法</h2><ul>
<li><strong>获取字符串长度</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>s.size()</code>和<code>s.length()</code></td>
<td align="left">返回string对象的字符个数，他们执行效果相同。</td>
</tr>
<tr>
<td align="left"><code>s.max_size()</code></td>
<td align="left">返回string对象最多包含的字符数，超出会抛出length_error异常</td>
</tr>
<tr>
<td align="left"><code>s.capacity()</code></td>
<td align="left">重新分配内存之前，string对象能包含的最大字符数</td>
</tr>
</tbody></table>
<ul>
<li><strong>插入</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>s.push_back()</code></td>
<td align="left">在末尾插入</td>
</tr>
<tr>
<td align="left">例：<code>s.push_back(&#39;a&#39;)</code></td>
<td align="left">末尾插入一个字符a</td>
</tr>
<tr>
<td align="left"><code>s.insert(pos,element)</code></td>
<td align="left">在pos位置插入element</td>
</tr>
<tr>
<td align="left">例：<code>s.insert(s.begin(),&#39;1&#39;)</code></td>
<td align="left">在第一个位置插入1字符</td>
</tr>
<tr>
<td align="left"><code>s.append(str)</code></td>
<td align="left">在s字符串结尾添加str字符串</td>
</tr>
<tr>
<td align="left">例：<code>s.append(&quot;abc&quot;)</code></td>
<td align="left">在s字符串末尾添加字符串“abc”</td>
</tr>
</tbody></table>
<ul>
<li><strong>删除</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>erase(iterator p)</code></td>
<td align="left">删除字符串中p所指的字符</td>
</tr>
<tr>
<td align="left"><code>erase(iterator first, iterator last)</code></td>
<td align="left">删除字符串中迭代器区间<code>[first,last)</code>上所有字符</td>
</tr>
<tr>
<td align="left"><code>erase(pos, len)</code></td>
<td align="left">删除字符串中从索引位置pos开始的len个字符</td>
</tr>
<tr>
<td align="left"><code>clear()</code></td>
<td align="left">删除字符串中所有字符</td>
</tr>
</tbody></table>
<ul>
<li><strong>字符替换</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>s.replace(pos,n,str)</code></td>
<td align="left">把当前字符串从索引pos开始的n个字符替换为str</td>
</tr>
<tr>
<td align="left"><code>s.replace(pos,n,n1,c)</code></td>
<td align="left">把当前字符串从索引pos开始的n个字符替换为n1个字符c</td>
</tr>
<tr>
<td align="left"><code>s.replace(it1,it2,str)</code></td>
<td align="left">把当前字符串<code>[it1,it2)</code>区间替换为str <strong>it1 ,it2为迭代器哦</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong>大小写转换</strong></li>
</ul>
<p>法一：</p>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>tolower(s[i])</code></td>
<td align="left">转换为小写</td>
</tr>
<tr>
<td align="left"><code>toupper(s[i])</code></td>
<td align="left">转换为大写</td>
</tr>
</tbody></table>
<p>法二：</p>
<p>通过stl的transform算法配合tolower 和toupper 实现。<br>有4个参数，前2个指定要转换的容器的起止范围，第3个参数是结果存放容器的起始位置，第4个参数是一元运算。</p>
<pre><code class="cpp">string s;
transform(s.begin(),s.end(),s.begin(),::tolower);//转换小写
transform(s.begin(),s.end(),s.begin(),::toupper);//转换大写
</code></pre>
<ul>
<li><strong>分割</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>s.substr(pos,n)</code></td>
<td align="left">截取从pos索引开始的n个字符</td>
</tr>
</tbody></table>
<ul>
<li><strong>查找</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>s.find (str, pos)</code></td>
<td align="left">在当前字符串的pos索引位置（默认为0）开始，查找子串str，返回找到的位置索引，-1表示查找不到子串</td>
</tr>
<tr>
<td align="left"><code>s.find (c, pos)</code></td>
<td align="left">在当前字符串的pos索引位置（默认为0）开始，查找字符c，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td align="left"><code>s.rfind (str, pos)</code></td>
<td align="left">在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串</td>
</tr>
<tr>
<td align="left"><code>s.rfind (c,pos)</code></td>
<td align="left">在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td align="left"><code>s.find_first_of (str, pos)</code></td>
<td align="left">在当前字符串的pos索引位置（默认为0）开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td align="left"><code>s.find_first_not_of (str,pos)</code></td>
<td align="left">在当前字符串的pos索引位置（默认为0）开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td align="left"><code>s.find_last_of(str, pos)</code></td>
<td align="left">在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td align="left"><code>s.find_last_not_of ( str, pos)</code></td>
<td align="left">在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串</td>
</tr>
</tbody></table>
<pre><code class="cpp">#include&lt;string&gt;
#include&lt;iostream&gt;
int main()
&#123;
    string s(&quot;dog bird chicken bird cat&quot;);
//字符串查找-----找到后返回首字母在字符串中的下标
// 1. 查找一个字符串
    cout &lt;&lt; s.find(&quot;chicken&quot;) &lt;&lt; endl;// 结果是：9

// 2. 从下标为6开始找字符&#39;i&#39;，返回找到的第一个i的下标
    cout &lt;&lt; s.find(&#39;i&#39;,6) &lt;&lt; endl;// 结果是：11

// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标
    cout &lt;&lt; s.rfind(&quot;chicken&quot;) &lt;&lt; endl;// 结果是：9

// 4. 从字符串的末尾开始查找字符
    cout &lt;&lt; s.rfind(&#39;i&#39;) &lt;&lt; endl;// 结果是：18因为是从末尾开始查找，所以返回第一次找到的字符

// 5. 在该字符串中查找第一个属于字符串s的字符
    cout &lt;&lt; s.find_first_of(&quot;13br98&quot;) &lt;&lt; endl;// 结果是：4---b

// 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4
    cout &lt;&lt; s.find_first_not_of(&quot;hello dog 2006&quot;) &lt;&lt; endl; // 结果是：4
    cout &lt;&lt; s.find_first_not_of(&quot;dog bird 2006&quot;) &lt;&lt; endl;  // 结果是：9

// 7. 在该字符串最后中查找第一个属于字符串s的字符
    cout &lt;&lt; s.find_last_of(&quot;13r98&quot;) &lt;&lt; endl;// 结果是：19

// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21
    cout &lt;&lt; s.find_last_not_of(&quot;teac&quot;) &lt;&lt; endl;// 结果是：21
&#125;
</code></pre>
<ul>
<li><strong>排序</strong></li>
</ul>
<pre><code class="cpp">sort(s.begin(),s.end());  //按ASCII码排序
</code></pre>
<h1 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h1><p>bitset 在 bitset 头文件中，它类似数组，并且每一个元素只能是０或１，每个元素只用１bit空间</p>
<pre><code class="cpp">//头文件
#include&lt;bitset&gt;
</code></pre>
<h2 id="初始化定义"><a href="#初始化定义" class="headerlink" title="初始化定义"></a>初始化定义</h2><p>初始化方法</p>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>bitset &lt; n &gt;a</code></td>
<td align="left">a有n位，每位都为0</td>
</tr>
<tr>
<td align="left"><code>bitset &lt; n &gt;a(b)</code></td>
<td align="left">a是unsigned long型u的一个副本</td>
</tr>
<tr>
<td align="left"><code>bitset &lt; n &gt;a(s)</code></td>
<td align="left">a是string对象s中含有的位串的副本</td>
</tr>
<tr>
<td align="left"><code>bitset &lt; n &gt;a(s,pos,n)</code></td>
<td align="left">a是s中从位置pos开始的n个位的副本</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：<code>n</code>必须为常量表达式</p>
</blockquote>
<p>演示代码：</p>
<pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
&#123;
    bitset&lt;4&gt; bitset1;　　  //无参构造，长度为４，默认每一位为０

    bitset&lt;9&gt; bitset2(12);　//长度为9，二进制保存，前面用０补充

    string s = &quot;100101&quot;;
    bitset&lt;10&gt; bitset3(s);　　//长度为10，前面用０补充

    char s2[] = &quot;10101&quot;;
    bitset&lt;13&gt; bitset4(s2);　　//长度为13，前面用０补充

    cout &lt;&lt; bitset1 &lt;&lt; endl;　　//0000
    cout &lt;&lt; bitset2 &lt;&lt; endl;　　//000001100
    cout &lt;&lt; bitset3 &lt;&lt; endl;　　//0000100101
    cout &lt;&lt; bitset4 &lt;&lt; endl;　//0000000010101
    return 0;
&#125;
</code></pre>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><code>bitset</code>可以进行<strong>位操作</strong></p>
<pre><code class="cpp">bitset&lt;4&gt; foo (string(&quot;1001&quot;));
bitset&lt;4&gt; bar (string(&quot;0011&quot;));

cout &lt;&lt; (foo ^= bar) &lt;&lt; endl;// 1010 (foo对bar按位异或后赋值给foo)

cout &lt;&lt; (foo &amp;= bar) &lt;&lt; endl;// 0010 (按位与后赋值给foo)

cout &lt;&lt; (foo |= bar) &lt;&lt; endl;// 0011 (按位或后赋值给foo)

cout &lt;&lt; (foo &lt;&lt;= 2) &lt;&lt; endl;// 1100 (左移２位，低位补０，有自身赋值)

cout &lt;&lt; (foo &gt;&gt;= 1) &lt;&lt; endl;// 0110 (右移１位，高位补０，有自身赋值)

cout &lt;&lt; (~bar) &lt;&lt; endl;// 1100 (按位取反)

cout &lt;&lt; (bar &lt;&lt; 1) &lt;&lt; endl;// 0110 (左移，不赋值)

cout &lt;&lt; (bar &gt;&gt; 1) &lt;&lt; endl;// 0001 (右移，不赋值)

cout &lt;&lt; (foo == bar) &lt;&lt; endl;// false (0110==0011为false)

cout &lt;&lt; (foo != bar) &lt;&lt; endl;// true  (0110!=0011为true)

cout &lt;&lt; (foo &amp; bar) &lt;&lt; endl;// 0010 (按位与，不赋值)

cout &lt;&lt; (foo | bar) &lt;&lt; endl;// 0111 (按位或，不赋值)

cout &lt;&lt; (foo ^ bar) &lt;&lt; endl;// 0101 (按位异或，不赋值)
</code></pre>
<p><strong>访问</strong></p>
<pre><code class="cpp">//可以通过 [ ] 访问元素(类似数组)，注意最低位下标为０，如下：
bitset&lt;4&gt; foo (&quot;1011&quot;); 

cout &lt;&lt; foo[0] &lt;&lt; endl;　　//1
cout &lt;&lt; foo[1] &lt;&lt; endl;　　//1
cout &lt;&lt; foo[2] &lt;&lt; endl;　　//0
</code></pre>
<h2 id="方法函数-4"><a href="#方法函数-4" class="headerlink" title="方法函数"></a>方法函数</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>b.any()</code></td>
<td align="left">b中是否存在置为1的二进制位，有 返回true</td>
</tr>
<tr>
<td align="left"><code>b.none()</code></td>
<td align="left">b中是否没有1，没有 返回true</td>
</tr>
<tr>
<td align="left"><code>b.count()</code></td>
<td align="left">b中为1的个数</td>
</tr>
<tr>
<td align="left"><code>b.size()</code></td>
<td align="left">b中二进制位的个数</td>
</tr>
<tr>
<td align="left"><code>b.test(pos)</code></td>
<td align="left">测试b在pos位置是否为1，是 返回true</td>
</tr>
<tr>
<td align="left"><code>b[pos]</code></td>
<td align="left">返回b在pos处的二进制位</td>
</tr>
<tr>
<td align="left"><code>b.set()</code></td>
<td align="left">把b中所有位都置为1</td>
</tr>
<tr>
<td align="left"><code>b.set(pos)</code></td>
<td align="left">把b中pos位置置为1</td>
</tr>
<tr>
<td align="left"><code>b.reset()</code></td>
<td align="left">把b中所有位都置为0</td>
</tr>
<tr>
<td align="left"><code>b.reset(pos)</code></td>
<td align="left">把b中pos位置置为0</td>
</tr>
<tr>
<td align="left"><code>b.flip()</code></td>
<td align="left">把b中所有二进制位取反</td>
</tr>
<tr>
<td align="left"><code>b.flip(pos)</code></td>
<td align="left">把b中pos位置取反</td>
</tr>
<tr>
<td align="left"><code>b.to_ulong()</code></td>
<td align="left">用b中同样的二进制位返回一个unsigned long值</td>
</tr>
</tbody></table>
<h1 id="array"><a href="#array" class="headerlink" title="array"></a>array</h1><p>头文件</p>
<pre><code class="cpp">#include&lt;array&gt;
</code></pre>
<p><code>array</code>是C++11新增的容器，效率与普通数据相差无几，比<code>vector</code>效率要高，自身添加了一些成员函数。</p>
<p>和其它容器不同，array 容器的大小是<strong>固定</strong>的，无法动态的扩展或收缩，<strong>只允许访问或者替换存储的元素。</strong></p>
<p><strong>注意：</strong></p>
<p><code>array</code>的使用要在<code>std</code>命名空间里</p>
<h2 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h2><p><strong>基础数据类型</strong></p>
<pre><code class="cpp">//声明一个大小为100的`int`型数组，元素的值不确定
array&lt;int, 100&gt; a;

//声明一个大小为100的int型数组，初始值均为0初始值与默认元素类型等效
array&lt;int, 100&gt; a&#123;&#125;;

//声明一个大小为100的int型数组，初始化部分值，其余全部为0
array&lt;int, 100&gt; a&#123;1, 2, 3&#125;;

//或者可以用等号
array&lt;int, 100&gt; a = &#123;1, 2, 3&#125;;
</code></pre>
<p><strong>高级数据类型</strong></p>
<p>不同于数组的是对元素类型不做要求，可以套结构体</p>
<pre><code class="cpp">array&lt;string, 2&gt; s = &#123;&quot;ha&quot;, string(&quot;haha&quot;)&#125;;
array&lt;node, 2&gt; a;
</code></pre>
<h2 id="存取元素"><a href="#存取元素" class="headerlink" title="存取元素"></a>存取元素</h2><ul>
<li><p>修改元素</p>
<pre><code class="cpp">array&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;
a[0] = 4;
</code></pre>
</li>
<li><p>访问元素</p>
<p>下标访问</p>
<pre><code class="cpp">array&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;
for(int i = 0; i &lt; 4; i++) 
    cout &lt;&lt; a[i] &lt;&lt; &quot; \n&quot;[i == 3];
</code></pre>
<p>利用<code>auto</code>访问</p>
<pre><code class="cpp">for(auto i : a)
    cout &lt;&lt; i &lt;&lt; &quot; &quot;;
</code></pre>
<p>迭代器访问</p>
<pre><code class="cpp">auto it = a.begin();
for(; it != a.end(); it++) 
    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
</code></pre>
<p><code>at()</code>函数访问</p>
<p>下标为<code>1</code>的元素加上下标为<code>2</code>的元素，答案为<code>5</code></p>
<pre><code class="cpp">array&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;
int res = a.at(1) + a.at(2);
cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
</code></pre>
<p><code>get</code>方法访问</p>
<p>将<code>a</code>数组下标为<code>1</code>位置处的值改为<code>x</code></p>
<p>注意：获取的下标只能写数字，不能填变量</p>
<pre><code class="cpp">get&lt;1&gt;(a) = x;
</code></pre>
</li>
</ul>
<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><table>
<thead>
<tr>
<th align="left">成员函数</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>begin()</code></td>
<td align="left">返回容器中第一个元素的访问迭代器（地址）</td>
</tr>
<tr>
<td align="left"><code>end()</code></td>
<td align="left">返回容器最后一个元素之后一个位置的访问迭代器（地址）</td>
</tr>
<tr>
<td align="left"><code>rbegin()</code></td>
<td align="left">返回最后一个元素的访问迭代器（地址）</td>
</tr>
<tr>
<td align="left"><code>rend()</code></td>
<td align="left">返回第一个元素之前一个位置的访问迭代器（地址）</td>
</tr>
<tr>
<td align="left"><code>size()</code></td>
<td align="left">返回容器中元素的数量，其值等于初始化 array 类的第二个模板参数<code>N</code></td>
</tr>
<tr>
<td align="left"><code>max_size()</code></td>
<td align="left">返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N</td>
</tr>
<tr>
<td align="left"><code>empty()</code></td>
<td align="left">判断容器是否为空</td>
</tr>
<tr>
<td align="left"><code>at(n)</code></td>
<td align="left">返回容器中 n 位置处元素的引用，函数会自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常</td>
</tr>
<tr>
<td align="left"><code>front()</code></td>
<td align="left">返回容器中第一个元素的直接引用，函数不适用于空的 array 容器</td>
</tr>
<tr>
<td align="left"><code>back()</code></td>
<td align="left">返回容器中最后一个元素的直接引用，函数不适用于空的 array 容器。</td>
</tr>
<tr>
<td align="left"><code>data()</code></td>
<td align="left">返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能</td>
</tr>
<tr>
<td align="left"><code>fill(x)</code></td>
<td align="left">将 <code>x</code> 这个值赋值给容器中的每个元素,相当于初始化</td>
</tr>
<tr>
<td align="left"><code>array1.swap(array2)</code></td>
<td align="left">交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型</td>
</tr>
</tbody></table>
<h2 id="部分用法示例"><a href="#部分用法示例" class="headerlink" title="部分用法示例"></a>部分用法示例</h2><p><code>data()</code></p>
<p>指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。</p>
<p><code>at()</code></p>
<p>下标为<code>1</code>的元素加上下标为<code>2</code>的元素，答案为<code>5</code></p>
<pre><code class="cpp">array&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;
int res = a.at(1) + a.at(2);
cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
</code></pre>
<p><code>fill()</code></p>
<p>array的<code>fill()</code>函数，将<code>a</code>数组全部元素值变为<code>x</code></p>
<pre><code class="cpp">a.fill(x);
</code></pre>
<p>另外还有其它的<code>fill()</code>函数:将<code>a</code>数组[begin,end)全部值变为<code>x</code></p>
<pre><code class="cpp">fill(a.begin(), a.end(), x);
</code></pre>
<p><strong>get方法获取元素值</strong></p>
<p>将<code>a</code>数组下标为<code>1</code>位置处的值改为<code>x</code></p>
<p>注意:获取的下标只能写数字，不能填变量</p>
<pre><code class="cpp">get&lt;1&gt;(a) = x;
</code></pre>
<p><strong>排序</strong></p>
<pre><code class="cpp">sort(a.begin(), a.end());
</code></pre>
<h1 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h1><p>tuple模板是pair的泛化，可以封装不同类型任意数量的对象。</p>
<p>可以把tuple理解为pair的扩展，tuple可以声明二元组，也可以声明三元组。</p>
<p>tuple可以等价为<strong>结构体</strong>使用</p>
<p><strong>头文件</strong></p>
<pre><code class="cpp">#include &lt;tuple&gt;
</code></pre>
<h2 id="声明初始化"><a href="#声明初始化" class="headerlink" title="声明初始化"></a>声明初始化</h2><p>声明一个空的<code>tuple</code>三元组</p>
<pre><code class="cpp">tuple&lt;int, int, string&gt; t1;
</code></pre>
<p>赋值</p>
<pre><code class="cpp">t1 = make_tuple(1, 1, &quot;hahaha&quot;);
</code></pre>
<p>创建的同时初始化</p>
<pre><code class="cpp">tuple&lt;int, int, int, int&gt; t2(1, 2, 3, 4);
</code></pre>
<p>可以使用pair对象构造tuple对象，但tuple对象必须是两个元素</p>
<pre><code class="cpp">auto p = make_pair(&quot;wang&quot;, 1);
tuple&lt;string, int&gt; t3 &#123;p&#125;; //将pair对象赋给tuple对象
</code></pre>
<h2 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h2><p>获取tuple对象<code>t</code>的第一个元素</p>
<pre><code class="cpp">int first = get&lt;0&gt;(t);
</code></pre>
<p>修改tuple对象<code>t</code>的第一个元素</p>
<pre><code class="cpp">get&lt;0&gt;(t) = 1;
</code></pre>
<h2 id="函数操作"><a href="#函数操作" class="headerlink" title="函数操作"></a>函数操作</h2><p>获取元素个数</p>
<pre><code class="cpp">tuple&lt;int, int, int&gt; t(1, 2, 3);
cout &lt;&lt; tuple_size&lt;decltype(t)&gt;::value &lt;&lt; &quot;\n&quot;; // 3
</code></pre>
<p>获取对应元素的值</p>
<p>通过<code>get(obj)</code>方法获取,<code>n</code>必须为数字不能是变量</p>
<pre><code class="cpp">tuple&lt;int, int, int&gt; t(1, 2, 3);
cout &lt;&lt; get&lt;0&gt;(t) &lt;&lt; &#39;\n&#39;; // 1
cout &lt;&lt; get&lt;1&gt;(t) &lt;&lt; &#39;\n&#39;; // 2
cout &lt;&lt; get&lt;2&gt;(t) &lt;&lt; &#39;\n&#39;; // 3
</code></pre>
<p>通过<code>tie</code>解包 获取元素值</p>
<p><code>tie</code>可以让tuple变量中的三个值依次赋到tie中的三个变量中</p>
<pre><code class="cpp">int one, three;
string two; 
tuple&lt;int, string, int&gt; t(1, &quot;hahaha&quot;, 3);
tie(one, two, three) = t;
cout &lt;&lt; one &lt;&lt; two &lt;&lt; three &lt;&lt; &quot;\n&quot;; // 1hahaha3
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 Adventure
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;AdventureYX
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        




        
    </body>
</html>
