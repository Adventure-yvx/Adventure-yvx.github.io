



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="" href="https://adventure-yx.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://adventure-yx.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://adventure-yx.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="DataBase" />


<link rel="canonical" href="https://adventure-yx.github.io/2023/03/08/CMU15-445%20Project1/">



  <title>
CMU15-445：Project#1 Buffer Pool - DataBase |
Adventure =  = 心有所向。日复一日，必有精进</title>
<meta name="generator" content="Hexo 6.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">CMU15-445：Project#1 Buffer Pool
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2023-03-08 10:03:05">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2023-03-08T10:03:05+08:00">2023-03-08</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Adventure</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://img.picgo.net/2023/04/02/sky-157c501dd887202cec.jpeg"></li>
          <li class="item" data-background-image="https://cdn.jsdelivr.net/gh/Adventure-yx/img/banner/sky-8.jpg"></li>
          <li class="item" data-background-image="https://img.picgo.net/2023/04/02/sky-19f963fbc408cf0014.png"></li>
          <li class="item" data-background-image="https://img.picgo.net/2023/04/02/sky-3b2f6d510326b07dd.jpeg"></li>
          <li class="item" data-background-image="https://img.picgo.net/2023/04/02/sky-134a7b41dbac28cfdf.jpeg"></li>
          <li class="item" data-background-image="https://img.picgo.net/2023/04/02/sky-187e4d08bbd3af08b1.png"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/DataBase/" itemprop="item" rel="index" title="分类于 DataBase"><span itemprop="name">DataBase</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://adventure-yx.github.io/2023/03/08/CMU15-445%20Project1/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="AdventureYX">
    <meta itemprop="description" content="心有所向。日复一日，必有精进, ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="overview"><a class="markdownIt-Anchor" href="#overview">#</a> Overview</h1>
<ul>
<li>本课程要求为 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NtdS1kYi9idXN0dWI=">BusTub</span> DBMS 实现一个新的面向磁盘的存储管理器 (disk-oriented storage manager)。这样的存储管理器假定数据库的主要存储位置是磁盘上。</li>
<li>第一个编程项目是实现一个缓冲池 (buffer pool)。缓冲池负责将物理页从主存中来回移动到磁盘。它允许 DBMS 支持大于系统可用内存量的数据库。缓冲池的操作对系统的其他部分是透明 (transparent) 的。比如：系统使用其唯一的标识符 (page_id_t) 向缓冲池要 (ask) 一个页面，它不知道这个页面是否已经在内存中，或者系统是否必须从磁盘中检索它。</li>
<li>注意：实现必须是线程安全的 (thread-safe)。多个线程都将同时访问数据结构，所以必须确保他们的关键部分收到 latch 的保护。（即：锁）</li>
<li>我们需要在我们的存储管理器中实现以下 3 个部分：
<ul>
<li><a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2022/project1/#extendible-hash-table"><strong>Extendible Hash Table</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2022/project1/#lru-k-replacer"><strong>LRU-K Replacement Policy</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2022/project1/#buffer-pool-instance"><strong>Buffer Pool Manager Instance</strong></a></li>
</ul>
</li>
</ul>
<h1 id="project-specification"><a class="markdownIt-Anchor" href="#project-specification">#</a> Project Specification</h1>
<ul>
<li>对此次任务实现的每个组件，都提供了包含所需要我们实现的 API 的存根类 (stub class)。我们不应该修改这些类中预先定义的函数签名 (function signatures)。如果修改了，用来评分的测试代码可能会被破坏。就评分不了了。</li>
<li>如果一个类已经包含了数据成员，我们不应该删除它们。例如 <code>BufferPoolManagerInstance</code>  里面的 <code>DiskManager</code> ,  <code>ExtendibleHashTable</code>  和 <code>LRUKReplacer</code>  对象。这些都是实现系统其他部分所需要的功能所需要的。另一方面，我们可能要向这些类来添加数据成员，以便正确实现所需要的功能。也可以给这些类添加辅助函数。</li>
<li>除非有规定，我们可以在项目中使用任何的 C++17 容器。可以自行选择。注意多线程安全和锁的使用，来保护它们。但是我们不能带入额外的第三方依赖，比如 boost。</li>
</ul>
<h1 id="extendible-hash-table"><a class="markdownIt-Anchor" href="#extendible-hash-table">#</a> Extendible Hash Table</h1>
<h2 id="task"><a class="markdownIt-Anchor" href="#task">#</a> task</h2>
<p>在这个项目的第一部分，我们将建立一个通用的哈希表，使用无序的桶 (unordered buckets) 来存储唯一的键值对 (key/value pairs)。<br>
我们的哈希表必须支持</p>
<ul>
<li>插入 / 删除键值对的能力。</li>
<li>我们无需指定表的最大 size，表应该可以根据需要逐步增加大小，但是我们不需要缩小表。也就是说，我们不需要实现对缩小或者压缩哈希表的功能。</li>
<li>我们还需要支持检查一个键是否存在于哈希表中，并返回相应的值。</li>
</ul>
<p>在正式开始编程之前，建议先着手一些分割和目录增长的小例子。</p>
<p>我们必须在项目源代码的指定文件中实现哈希表。而且只允许修改哈希表头文件 ( <code>src/include/container/hash/extendible_hash_table.h</code> ) 和对应的实现文件 ( <code>src/container/hash/extendible_hash_table.cpp</code> )。我们不需要修改任何其他文件，在视线中，我们不能在内部使用另一个内置哈希表。而且我们必须在 <code>ExtendibleHashTable</code>  类中实现以下函数：</p>
<ul>
<li>
<p><code>Find(K, V)</code> : 给定键 K，检查它是否存在于哈希表中，如果存在，则在 V 中存储指向其对应值的指针并返回 true。如果键不存在，返回 false。</p>
</li>
<li>
<p><code>Insert(K, V)</code> : 将键值对插入哈希表。如果 K 已经存在，则用新的值 V 覆盖其值，并返回 true。如果键值对不能被插入到桶中（因为桶已经满了，而且键没有更新现有的对），在重试之前做以下步骤：</p>
<ol>
<li>如果桶的本地深度 (local depth) 等于全局深度 (global depth)。递增全局深度。并将目录 (directory) 的大小增加一倍。</li>
<li>增加桶的局部深度。</li>
<li>分割桶。并重新分配目录指针和桶中的 K/V 对。</li>
</ol>
<p><strong>有限实现是在插入后，如果桶满了就分割桶，但是在这个项目中，请检测桶是否溢出，并在插入之前执行分割！</strong></p>
</li>
<li>
<p><code>Remove(K)</code> ：给定 K, 从哈希表删除其对应的键值对，并返回 true。如果不存在，返回 false。</p>
</li>
<li>
<p><code>GetGlobalDepth()</code> : 返回整个哈希表的当前全局深度。</p>
</li>
<li>
<p><code>GetLocalDepth(dir_index)</code> ：返回给定目录索引所指向的桶的当前本地深度。</p>
</li>
<li>
<p><code>GetNumBuckets()</code> : 返回在哈希表中分配的桶的总数。</p>
</li>
<li>
<p>我们可以利用给定的 <code>IndexOf(K)</code>  的私有函数来计算一个给定键所切分的目录索引。此外，还提供了一个 Bucket 嵌套类，表示可扩展哈希表中的桶。通过遵循代码文档，首先完成 Bucket 类的 TODOs 可以让我们更容易实现 ``ExtendibleHashTable` 的 API。但也可以自由的表写我们自己的内部类和辅助函数。</p>
</li>
<li>
<p>我们需要使用 <code>std::mutex</code>  确保哈希表中的所有操作都是线程安全的。如何保护数据机构由我们自己决定。</p>
</li>
</ul>
<h2 id="可扩展哈希表原理"><a class="markdownIt-Anchor" href="#可扩展哈希表原理">#</a> 可扩展哈希表原理</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvZXh0ZW5kaWJsZS1oYXNoaW5nLWR5bmFtaWMtYXBwcm9hY2gtdG8tZGJtcy8=">Extendible Hashing (Dynamic approach to DBMS)</span></p>
<blockquote>
<p><strong>Extendible Hashing</strong> is a dynamic hashing method wherein directories, and buckets are used to hash data. It is an aggressively flexible method in which the hash function also experiences dynamic changes.</p>
<p><strong>Extendible Hashing</strong> 是一种动态哈希方法，其中目录和桶被用于哈希数据。可扩展哈希是一个有力的灵活的方法，其中哈希函数也经历动态的改变。</p>
</blockquote>
<p><strong>Main features of Extendible Hashing</strong>: The main features in this hashing technique are:</p>
<p><strong>Main features of Extendible Hashing</strong>:  在哈希技术中主要的特征如下：</p>
<ul>
<li>
<p><strong>Directories:</strong> The directories store addresses of the buckets in pointers. An id is assigned to each directory which may change each time when Directory Expansion takes place.</p>
<p><strong>目录:</strong> 目录在指针中存储桶的地址。每个目录被分配一个 <code>id</code>  ，每次目录扩张时， <code>id</code>  可能会发生变化。</p>
</li>
<li>
<p><strong>Buckets:</strong> The buckets are used to hash the actual data.</p>
<p><strong>桶:</strong> 桶被用于哈希真实的数据。</p>
</li>
</ul>
<p><strong>Basic Structure of Extendible Hashing</strong></p>
<p>可扩展哈希的基本结构</p>
<p>![image-20230424230000782.png)</p>
<p><strong>Frequently used terms in Extendible Hashing</strong></p>
<p>在可扩展哈希中常用术语</p>
<ul>
<li 全局深度="">
<p><strong>Directories:</strong> These containers store pointers to buckets. Each directory is given a unique id which may change each time when expansion takes place. The hash function returns this directory id which is used to navigate to the appropriate bucket. Number of Directories = 2^Global Depth.</p>
<p><strong>目录:</strong> 这个容器存储指向桶的指针。每个目录给定一个唯一的 id，当扩张发生时 <code>id</code>  可能随之改变。哈希函数返回这个目录的 id，这个 <code>id</code>  被用来指向合适的桶。目录的数量 = 2^</p>
</li>
<li>
<p><strong>Buckets:</strong> They store the hashed keys. Directories point to buckets. A bucket may contain more than one pointers to it if its local depth is less than the global depth.</p>
<p><strong>桶:</strong>  它们存储哈希键。目录指向桶。如果局部深度小于全局深度时，一个桶可能包含不止一个指针指向它。</p>
</li>
<li>
<p><strong>Global Depth:</strong> It is associated with the Directories. They denote the number of bits which are used by the hash function to categorize the keys. Global Depth = Number of bits in directory id.</p>
<p><strong>全局深度</strong>：它跟目录相关联。它们表示哈希函数使用的比特位数目去分类这些键。全局深度 = 目录 id 的比特位数。</p>
</li>
<li>
<p><strong>Local Depth:</strong> It is the same as that of Global Depth except for the fact that Local Depth is associated with the buckets and not the directories. Local depth in accordance with the global depth is used to decide the action that to be performed in case an overflow occurs. Local Depth is always less than or equal to the Global Depth.</p>
<p><strong>局部深度</strong>：和全局深度类似，除了局部深度是跟桶关联，而不是跟目录。当桶溢出发生时，局部深度根据全局深度去决定执行的行为。局部深度通常小于等于全局深度。</p>
</li>
<li>
<p><strong>Bucket Splitting:</strong> When the number of elements in a bucket exceeds a particular size, then the bucket is split into two parts.</p>
<p><strong>桶分裂</strong>：当桶的元素超过了特定的大小，那么桶分裂成两个部分。</p>
</li>
<li>
<p><strong>Directory Expansion:</strong> Directory Expansion Takes place when a bucket overflows. Directory Expansion is performed when the local depth of the overflowing bucket is equal to the global depth.</p>
<p><strong>目录扩容</strong>：当桶溢出时，产生目录扩容。当溢出桶的局部深度等于全局深度时，目录扩容被执行。</p>
</li>
</ul>
<p><strong>Basic Working of Extendible Hashing</strong>:</p>
<p>可扩展哈希基本工作流程</p>
<p><img data-src="image-20230424230307442.png" alt="image-20230424230307442"></p>
<ol>
<li>
<p><strong>Step 1 – Analyze Data Elements:</strong> Data elements may exist in various forms eg. Integer, String, Float, etc… Currently, let us consider data elements of type integer. eg: 49.</p>
<p><strong>步骤 1 – 分析数据元素</strong>：数据元素可能以各种形式存在，比如整形，字符串，浮点数等等… 当前，我们考虑整形这类数据元素，比如 49。</p>
</li>
<li>
<p><strong>Step 2 – Convert into binary format:</strong> Convert the data element in Binary form. For string elements, consider the ASCII equivalent integer of the starting character and then convert the integer into binary form. Since we have 49 as our data element, its binary form is 110001.</p>
<p><strong>步骤 2 - 转换成二进制形式</strong>：将数据元素转换为二进制形式。对于字符串元素，考虑 ASCII 码起始字符的对应整数，然后转换成二进制形式。因为我们是将 49 作为数据元素，它的二进制形式是 11001。</p>
</li>
<li>
<p><strong>Step 3 – Check Global Depth of the directory.</strong> Suppose the global depth of the Hash-directory is 3.</p>
<p><strong>步骤 3 - 检查目录的全局深度</strong>：假设哈希目录的全局深度是 3。</p>
</li>
<li>
<p><strong>Step 4 – Identify the Directory:</strong> Consider the ‘Global-Depth’ number of LSBs in the binary number and match it to the directory id.  Eg. The binary obtained is: 110001 and the global-depth is 3. So, the hash function will return 3 LSBs of 110<strong>001</strong> viz. 001.</p>
<p><strong>步骤 4 - 识别目录</strong>：考虑在二进制下最低 “全局深度” 位，然后去匹配目录 id。比如，二进制是：110001，全局深度是 3，所以哈希函数会返回 110<strong>001</strong> 最后三位，即 001。</p>
</li>
<li>
<p><strong>Step 5 – Navigation:</strong> Now, navigate to the bucket pointed by the directory with directory-id 001.</p>
<p><strong>步骤 5 - 导航</strong>：现在，访问目录 id=001 指向的桶。</p>
</li>
<li>
<p><strong>Step 6 – Insertion and Overflow Check:</strong> Insert the element and check if the bucket overflows. If an overflow is encountered, go to <strong>step 7</strong> followed by <strong>Step 8</strong>, otherwise, go to <strong>step 9</strong>.</p>
<p><strong>步骤 6 – 插入和溢出检查</strong>：插入元素并且检查桶是否溢出。如果遇到溢出，转向步骤 7 和步骤 8，否则转到步骤 9。</p>
</li>
<li>
<p><strong>Step 7 – Tackling Over Flow Condition during Data Insertion:</strong> Many times, while inserting data in the buckets, it might happen that the Bucket overflows. In such cases, we need to follow an appropriate procedure to avoid mishandling of data.  First, Check if the local depth is less than or equal to the global depth. Then choose one of the cases below.</p>
<p><strong>步骤 7– 处理数据插入过程中的溢出情况:</strong>  很多情况下，当在桶里插入数据时，可能发生桶溢出。在这种情况下，我们需要采取下面合适的流程去避免误操作数据。首先，检查局部深度是否小于或等于全局深度。然后选择下述情况之一。</p>
<ul>
<li>
<p><strong>Case1:</strong> If the local depth of the overflowing Bucket is equal to the global depth, then Directory Expansion, as well as Bucket Split, needs to be performed. Then increment the global depth and the local depth value by 1. And, assign appropriate pointers.  Directory expansion will double the number of directories present in the hash structure.</p>
<p><strong>情况 1:</strong> 如果溢出桶的本地深度等于全局深度，那么需要执行目录扩张和桶分裂。然后全局深度和局部深度的值增加 1，并且指定合适的指针。目录扩张会 double 哈希结果中的目录数量。</p>
</li>
<li>
<p><strong>Case2:</strong> In case the local depth is less than the global depth, then only Bucket Split takes place. Then increment only the local depth value by 1. And, assign appropriate pointers.</p>
<p><strong>情况 2:</strong> 如果本地深度小于全局深度，那么仅仅发生桶分裂。然后仅仅把局部深度增加 1。并且指定合适的指针。</p>
<p><img data-src="image-20230424231204645.png" alt="image-20230424231204645"></p>
</li>
</ul>
</li>
<li>
<p><strong>Step 8 – Rehashing of Split Bucket Elements:</strong> The Elements present in the overflowing bucket that is split are rehashed w.r.t the new global depth of the directory.</p>
<p><strong>步骤 8 - 分裂桶的元素重新哈希</strong>：在被分裂的溢出桶中呈现的元素会根据目录的全局深度进行重新哈希。</p>
</li>
<li>
<p><strong>Step 9 –</strong> The element is successfully hashed.</p>
<p><strong>步骤 9</strong> - 元素被成功哈希。</p>
</li>
</ol>
<blockquote>
<p><strong>Example based on Extendible Hashing:</strong> Now, let us consider a prominent example of hashing the following elements: <strong>16,4,6,22,24,10,31,7,9,20,26.</strong></p>
<p><strong>基于可扩展哈希的样例</strong>：现在让我们考虑一个哈希以下元素的典型样例：16,4,6,22,24,10,31,7,9,20,26。（共 11 个元素）</p>
<p><strong>Bucket Size:</strong> 3 (Assume)</p>
<p><strong>桶大小</strong>：3（假设）</p>
<p><strong>Hash Function:</strong> Suppose the global depth is X. Then the Hash Function returns X LSBs.</p>
<p><strong>哈希函数</strong>：假设全局深度是 X，那么哈希函数返回 X 的最低位。</p>
</blockquote>
<ol>
<li>
<p><strong>Solution:</strong> First, calculate the binary forms of each of the given numbers.</p>
<p>** 解决方案：** 首先，计算每个给定数值的二进制形式。</p>
<p>16- 10000</p>
<p>4- 00100</p>
<p>6- 00110</p>
<p>22- 10110</p>
<p>24- 11000</p>
<p>10- 01010</p>
<p>31- 11111</p>
<p>7- 00111</p>
<p>9- 01001</p>
<p>20- 10100</p>
<p>26- 11010</p>
</li>
<li>
<p>Initially, the global-depth and local-depth is always 1. Thus, the hashing frame looks like this:</p>
<p>首先，全局深度和局部深度总是 1。因此哈希图看起来像这样：</p>
<p><img data-src="image-20230424231857524.png" alt="image-20230424231857524"></p>
</li>
<li>
<p><strong>Inserting 16:</strong>  The binary format of 16 is 10000 and global-depth is 1. The hash function returns 1 LSB of 1000<strong>0</strong> which is 0. Hence, 16 is mapped to the directory with id=0.</p>
<p><strong>插入 16:</strong>  16 的二进制形式是 10000，且全局深度是 1。哈希函数返回 1000<strong>0</strong> 最低 1 位为 0。因此，16 映射到目录的 <code>id=0</code> 。</p>
<p><img data-src="image-20230424231954017.png" alt="image-20230424231954017"></p>
</li>
<li>
<p><strong>Inserting 4 and 6:</strong>  Both 4(10<strong>0</strong>) and 6(11<strong>0</strong>)have 0 in their LSB. Hence, they are hashed as follows:</p>
<p><strong>插入 4 和 6</strong>：4(10<strong>0</strong>) and 6(11<strong>0</strong>) 的最低 1 位都是 0。因此，他们哈希结果如下：</p>
<p><img data-src="image-20230424232039916.png" alt="image-20230424232039916"></p>
</li>
<li>
<p><strong>Inserting 22:</strong> The binary form of 22 is 1011<strong>0</strong>. Its LSB is 0. The bucket pointed by directory 0 is already full. Hence, Over Flow occurs.</p>
<p><strong>插入 22</strong>：22 的二进制形式是 1011**0。** 它的最低位是 0。目录 0 指向的桶已经满了。因此溢出发生了。</p>
<p><img data-src="image-20230424232131329.png" alt="image-20230424232131329"></p>
</li>
<li>
<p>As directed by <strong>Step 7-Case 1</strong>, Since Local Depth = Global Depth, the bucket splits and directory expansion takes place. Also, rehashing of numbers present in the overflowing bucket takes place after the split. And, since the global depth is incremented by 1, now,the global depth is 2. Hence, 16,4,6,22 are now rehashed w.r.t 2 LSBs.[ 16(100<strong>00</strong>),4(1<strong>00</strong>),6(1<strong>10</strong>),22(101<strong>10</strong>) ]</p>
<p>正如<strong> Step 7-Case 1</strong> 指示的，因为局部深度 = 全局深度，桶分裂且目录扩张。同时，分裂之后在溢出的桶中重新哈希数值。并且因为全局深度增加了 1，所以现在全局深度是 2。因此，16,4,6,22 被重新哈希为最低 2 位。[16 (100<strong>00</strong>),4(1<strong>00</strong>),6(1<strong>10</strong>),22(101<strong>10</strong>) ]</p>
<p><img data-src="image-20230424232239402.png" alt="image-20230424232239402"></p>
<blockquote>
<p><em>Notice that the bucket which was underflow has remained untouched. But, since the number of directories has doubled, we now have 2 directories 01 and 11 pointing to the same bucket. This is because the local-depth of the bucket has remained 1. And, any bucket having a local depth less than the global depth is pointed-to by more than one directories.</em></p>
<p>注意，未溢出的桶存在没有触及的。但是，因为目录的数量已经翻倍，我们现在有 2 个目录 01 和 11 指向了同一个桶。这是因为桶的局部深度保持为 1。并且，任何局部深度小于全局深度的桶会被不止一个目录指向。</p>
</blockquote>
</li>
<li>
<p><strong>Inserting 24 and 10:</strong> 24(110<strong>00</strong>) and 10 (10<strong>10</strong>) can be hashed based on directories with id 00 and 10. Here, we encounter no overflow condition.</p>
<p><strong>插入 24 and 10:</strong> 24(110<strong>00</strong>) 和 10 (10<strong>10</strong>) 基于目录 id 00 和 10 可以被哈希。此处，我们没有遇到溢出的情况。</p>
<p><img data-src="image-20230424232401349.png" alt="image-20230424232401349"></p>
</li>
<li>
<p><strong>Inserting 31,7,9:</strong> All of these elements[ 31(111<strong>11</strong>), 7(1<strong>11</strong>), 9(10<strong>01</strong>) ] have either 01 or 11 in their LSBs. Hence, they are mapped on the bucket pointed out by 01 and 11. We do not encounter any overflow condition here.</p>
<p><strong>插入 31,7,9:</strong> 所有这些元素 [ 31 (111<strong>11</strong>), 7(1<strong>11</strong>), 9(10<strong>01</strong>) ] 在最低 2 位要么 01，要么 11。因此，我们映射到 01 和 11 对应的桶。我们没有遇到任何溢出的情况。</p>
<p><img data-src="image-20230424232504474.png" alt="image-20230424232504474"></p>
</li>
<li>
<p><strong>Inserting 20:</strong> Insertion of data element 20 (101<strong>00</strong>) will again cause the overflow problem.</p>
<p><strong>插入 20:</strong> 插入元素 20 (101<strong>00</strong>) 时再一次遇到了溢出问题。</p>
<p><img data-src="image-20230424232547238.png" alt="image-20230424232547238"></p>
</li>
<li>
<p>20 is inserted in bucket pointed out by 00. As directed by <strong>Step 7-Case 1</strong>, since the <strong>local depth of the bucket = global-depth</strong>, directory expansion (doubling) takes place along with bucket splitting. Elements present in overflowing bucket are rehashed with the new global depth. Now, the new Hash table looks like this:</p>
<p>20 插入的桶被 00 所指向。正如<strong> Step 7-Case 1</strong> 提示的那样，因为<strong>桶的局部深度 = 全局深度</strong>，目录扩张和桶分裂发生了。在溢出桶中的元素在新的全局深度下重新哈希。现在，新的哈希表如下：</p>
<p><img data-src="image-20230424232653483.png" alt="image-20230424232653483"></p>
</li>
<li>
<p><strong>Inserting 26:</strong> Global depth is 3. Hence, 3 LSBs of 26(11<strong>010</strong>) are considered. Therefore 26 best fits in the bucket pointed out by directory 010.</p>
<p><strong>插入 26</strong>：全局深度是 3。因此 26 (11<strong>010</strong>) 的最低 3 位被考虑。因此 26 最适合的桶被目录 010 指向。</p>
<p>![image-20230424232743216](D:\Blog\source_posts\CMU15-445 Project1\image-20230424232743216.png)</p>
</li>
<li>
<p>The bucket overflows, and, as directed by <strong>Step 7-Case 2,</strong> since the <strong>local depth of bucket &lt; Global depth (2&lt;3)</strong>, directories are not doubled but, only the bucket is split and elements are rehashed.  Finally, the output of hashing the given list of numbers is obtained.</p>
<p>桶发生了溢出，并且按照<strong> Step 7-Case 2</strong> 的指示，因此桶的<strong>局部深度小于全局深度（2&lt;3）</strong>，目录不会翻倍，仅仅是桶分裂和元素重新哈希。最后，哈希给定数值列表的结果已经获得。</p>
<p><img data-src="image-20230424232914876.png" alt="image-20230424232914876"></p>
</li>
<li>
<p><strong>Hashing of 11 Numbers is Thus Completed.</strong></p>
<p>11 个数值的哈希已经完成。</p>
</li>
</ol>
<p><strong>Key Observations 关键观察：</strong></p>
<ol>
<li>A Bucket will have more than one pointers pointing to it if its local depth is less than the global depth. 如果局部深度小于全局深度，一个桶会被超过 1 个指针指向。</li>
<li>When overflow condition occurs in a bucket, all the entries in the bucket are rehashed with a new local depth. 当桶发生溢出时，在这个桶里的所有元素都要用新的局部深度重新哈希。</li>
<li>If Local Depth of the overflowing bucket. 如果溢出桶的局部深度</li>
<li>The size of a bucket cannot be changed after the data insertion process begins. 在数据插入操作开始之后桶的大小不能改变。</li>
</ol>
<p><strong>Advantages:</strong>   <strong>优势</strong></p>
<ol>
<li>Data retrieval is less expensive (in terms of computing). 数据检索很便宜（根据计算）</li>
<li>No problem of Data-loss since the storage capacity increases dynamically. 因此存储容量动态增长，数据丢失没有问题。</li>
<li>With dynamic changes in hashing function, associated old values are rehashed w.r.t the new hash function. 随着在哈希函数中的动态改变，相关联的旧值被重新哈希到新的哈希函数中。</li>
</ol>
<p><strong>Limitations Of Extendible Hashing:</strong>   <strong>可扩展哈希的限制</strong></p>
<ol>
<li>The directory size may increase significantly if several records are hashed on the same directory while keeping the record distribution non-uniform. 当记录保持非均匀分布，如果多个记录被哈希到同一个目录，那么目录的大小会显著增加。</li>
<li>Size of every bucket is fixed. 每个桶的大小是固定的。</li>
<li>Memory is wasted in pointers when the global depth and local depth difference becomes drastic. 当全局深度和局部深度差距很大时，内存在指针上是浪费的。</li>
<li>This method is complicated to code. 这个方法在代码上很复杂。</li>
</ol>
<h1 id="lru-k-replacement-policy"><a class="markdownIt-Anchor" href="#lru-k-replacement-policy">#</a> LRU-K Replacement Policy</h1>
<h2 id="task-2"><a class="markdownIt-Anchor" href="#task-2">#</a> task</h2>
<p>这个组件负责跟踪缓冲池中的页面使用情况。我们将在 <code>src/include/buffer/lru_k_replacer.h</code>  中实现一个名为 <code>LRUKReplacer</code>  的新类。并在 <code>src/buffer/lru_k_replacer.cpp</code>  中实现相应的实现文件。<br>
注意： <code>LRUKReplacer</code>  是一个独立的类，它与其他的 Replacer 类没有关系。我们应该只实现 LRU-K 替换策略，而不需要实现 LRU 或者时钟 (clock) 替换策略，即使有相应的文件。</p>
<p>LRU-K 算法驱逐一个帧，该帧的后向 k - 距离 (Backward k-distance) 是替换器中所有帧的最大值。** 后向 k - 距离的计算方法是当前时间戳和第 k 次访问的时间戳之间的时间差。** 一个少于 k 次历史访问的帧被赋予  <code>+inf</code>  来作为它的后向 k - 距离。<br>
当多个帧有 <code>+inf</code>  的后向 k - 距离的时候，替换器会驱逐具有最早时间戳的帧。</p>
<p><code>LRUReplacer</code>  的最大尺寸与缓冲池的尺寸相同，因为它包含 <code>BufferPoolManager</code>  中所有帧的占位符（记录每个 page 的访问次数）。然而在任何给定的时刻，并不是复制器中的所有帧都被认为是可驱逐的。 <code>LRUReplacer</code>  的大小由可驱逐的数量表示。 <code>LRUReplacer</code>  被初始化为里面没有帧，然后只有当一个帧标记为可驱逐后，替换器 (replacer) 的大小才会增加。</p>
<p>我们需要实现课堂上讨论的 LRU-K 策略。我们将实现以下方法:</p>
<ul>
<li><code>Evict(frame_id_t*)</code> <br>
 驱逐 Replacer 正在跟踪的所有其他可驱逐帧相比，具有最大后向 k - 距离的帧。在输出参数中存储该帧的 ID，并返回 true。如果没有可驱逐帧，返回 false。</li>
<li><code>RecordAccess(frame_id_t)</code> <br>
 记录给定的帧 ID 在当前时间戳被访问，这个方法应该在一个页面被 pin 在 <code>BufferPoolManager</code>  后被调用。</li>
<li><code>Remove(frame_id_t)</code> <br>
 清除与一个帧相关的所有访问历史。只有在 <code>BufferPoolManager</code>  中删除一个页面的时候，才应该调用这个方法。</li>
<li><code>SetEvictable(frame_id_t, bool set_evictable)</code> <br>
 该方法控制一个帧是否可以被驱逐。它还控制 LRUReplacer 的大小。<br>
当我们实现 <code>BufferPoolManager</code>  的时候，我们就会知道啥时候调用这个函数。<br>
具体来说，当一个页面的 pin count 达到 0 的时候，其对应的帧就会标记为可驱逐 (Evictable)。Replacer 的大小也会增加。</li>
<li><code>Size()</code> <br>
 这个方法返回当前在 LRUReplacer 中可驱逐帧的数量。</li>
<li>实现的方法取决于我们。我们被允许使用内置的 STL 容器。而且可以假定不会耗尽内存，但必须保证操作是线程安全的 (thread-safe)。</li>
</ul>
<h2 id="lru-k算法原理"><a class="markdownIt-Anchor" href="#lru-k算法原理">#</a> LRU-K 算法原理</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9scnUtY2FjaGUv">146. LRU 缓存 - 力扣（LeetCode）</span></p>
<p>请你设计并实现一个<strong>满足 LRU (Least Recently Used 最近最少使用) 缓存</strong>约束的数据结构。<br>
实现  <code>LRUCache</code>  类：</p>
<ul>
<li><code>LRUCache(int capacity)</code>  以 <strong>正整数</strong> 作为容量  <code>capacity</code>  初始化 LRU 缓存</li>
<li><code>int get(int key)</code>  如果关键字  <code>key</code>  存在于缓存中，则返回关键字的值，否则返回  <code>-1</code>  。</li>
<li><code>void put(int key, int value)</code>  如果关键字  <code>key</code>  已经存在，则变更其数据值  <code>value</code>  ；如果不存在，则向缓存中插入该组  <code>key-value</code>  。如果插入操作导致关键字数量超过  <code>capacity</code>  ，则应该 逐出 最久未使用的关键字。</li>
</ul>
<p>函数  <code>get</code>  和  <code>put</code>  必须以  <code>O(1)</code>  的平均时间复杂度运行。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 输入</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span><span class="token string">"LRUCache"</span><span class="token punctuation">,</span> <span class="token string">"put"</span><span class="token punctuation">,</span> <span class="token string">"put"</span><span class="token punctuation">,</span> <span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"put"</span><span class="token punctuation">,</span> <span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"put"</span><span class="token punctuation">,</span> <span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"get"</span><span class="token punctuation">,</span> <span class="token string">"get"</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 输出</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">[</span>null<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 解释</span></pre></td></tr><tr><td data-num="8"></td><td><pre>LRUCache lRUCache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>lRUCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 缓存是 &#123;1=1&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>lRUCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 缓存是 &#123;1=1, 2=2&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>lRUCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回 1</span></pre></td></tr><tr><td data-num="12"></td><td><pre>lRUCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>lRUCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回 -1 (未找到)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>lRUCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>lRUCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回 -1 (未找到)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>lRUCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回 3</span></pre></td></tr><tr><td data-num="17"></td><td><pre>lRUCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回 4</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 1. 哈希表</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 2. 双向链表</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">int</span> key<span class="token punctuation">,</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        Node <span class="token operator">*</span>prev<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">key</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">val</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">prev</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> Node<span class="token operator">*</span><span class="token operator">></span> mp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">//3. 容量</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">int</span> n<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 哨兵</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    Node <span class="token operator">*</span>L <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    Node <span class="token operator">*</span>R <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        n <span class="token operator">=</span> capacity<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>        L<span class="token operator">-></span>next <span class="token operator">=</span> R<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        R<span class="token operator">-></span>prev <span class="token operator">=</span> L<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    </pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            Node <span class="token operator">*</span>node <span class="token operator">=</span> mp<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token comment">// 最近使用</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 从链表中移除该节点</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token function">insert</span><span class="token punctuation">(</span>node<span class="token operator">-></span>key<span class="token punctuation">,</span> node<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 在链表的最右边插入该节点</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token keyword">return</span> node<span class="token operator">-></span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    </pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>            Node<span class="token operator">*</span> node <span class="token operator">=</span> mp<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            <span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>            <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>                Node <span class="token operator">*</span>node <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>   <span class="token comment">// 最久未使用。左哨兵的下一个节点</span></pre></td></tr><tr><td data-num="43"></td><td><pre>                <span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>                <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>                <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>    <span class="token comment">// 4. 同时在链表和哈希表中删除节点</span></pre></td></tr><tr><td data-num="51"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>        <span class="token keyword">auto</span> pre <span class="token operator">=</span> node<span class="token operator">-></span>prev<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>        <span class="token keyword">auto</span> nxt <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>        </pre></td></tr><tr><td data-num="55"></td><td><pre>        pre<span class="token operator">-></span>next <span class="token operator">=</span> nxt<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>        nxt<span class="token operator">-></span>prev <span class="token operator">=</span> pre<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>        </pre></td></tr><tr><td data-num="58"></td><td><pre>        mp<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>node<span class="token operator">-></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="59"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="61"></td><td><pre>        <span class="token keyword">auto</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="62"></td><td><pre>        </pre></td></tr><tr><td data-num="63"></td><td><pre>        <span class="token keyword">auto</span> pre <span class="token operator">=</span> R<span class="token operator">-></span>prev<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="64"></td><td><pre>        <span class="token keyword">auto</span> nxt <span class="token operator">=</span> R<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="65"></td><td><pre>        </pre></td></tr><tr><td data-num="66"></td><td><pre>        <span class="token comment">// 从左往右</span></pre></td></tr><tr><td data-num="67"></td><td><pre>        pre<span class="token operator">-></span>next <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="68"></td><td><pre>        node<span class="token operator">-></span>next <span class="token operator">=</span> nxt<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="69"></td><td><pre>        <span class="token comment">// 从右往左</span></pre></td></tr><tr><td data-num="70"></td><td><pre>        nxt<span class="token operator">-></span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="71"></td><td><pre>        node<span class="token operator">-></span>prev <span class="token operator">=</span> pre<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="72"></td><td><pre>        </pre></td></tr><tr><td data-num="73"></td><td><pre>        mp<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="74"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="75"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="76"></td><td><pre><span class="token comment">/**</pre></td></tr><tr><td data-num="77"></td><td><pre> * Your LRUCache object will be instantiated and called as such:</pre></td></tr><tr><td data-num="78"></td><td><pre> * LRUCache* obj = new LRUCache(capacity);</pre></td></tr><tr><td data-num="79"></td><td><pre> * int param_1 = obj->get(key);</pre></td></tr><tr><td data-num="80"></td><td><pre> * obj->put(key,value);</pre></td></tr><tr><td data-num="81"></td><td><pre> */</span></pre></td></tr></table></figure><p>LRU-K 算法参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9jNGU0ZDU1NzA2ZmY=">LRU-K 和 2Q 缓存算法介绍</span></p>
<ul>
<li>
<p>算法思想</p>
<p>LRU-K 中的 K 代表最近使用的次数，因此 LRU 可以认为是 LRU-1。LRU-K 的主要目的是为了解决 LRU 算法 “缓存污染” 的问题，其核心思想是将 “最近使用过 1 次” 的判断标准扩展为 “最近使用过 K 次”。</p>
</li>
<li>
<p>工作原理</p>
<p>相比 LRU，LRU-K 需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到 K 次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K 会淘汰第 K 次访问时间距当前时间最大的数据。详细实现如下</p>
<p>![img](D:\Blog\source_posts\CMU15-445 Project1\20230425001.png)</p>
<ol>
<li>数据第一次被访问，加入到访问历史列表；</li>
<li>如果数据在访问历史列表里后没有达到 K 次访问，则按照一定规则（FIFO，LRU）淘汰；</li>
<li>当访问历史队列中的数据访问次数达到 K 次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</li>
<li>缓存数据队列中被再次访问后，重新排序；</li>
<li>需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰 “倒数第 K 次访问离现在最久” 的数据。</li>
</ol>
</li>
</ul>
<p>LRU-K 具有 LRU 的优点，同时能够避免 LRU 的缺点，实际应用中 LRU-2 是综合各种因素后最优的选择，LRU-3 或者更大的 K 值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。</p>
<p><strong>Two queues（2Q）</strong></p>
<ul>
<li>
<p>算法思想</p>
<p>该算法类似于 LRU-2，不同点在于 2Q 将 LRU-2 算法中的访问历史队列（注意这不是缓存数据的）改为一个 FIFO 缓存队列，即：2Q 算法有两个缓存队列，一个是 FIFO 队列，一个是 LRU 队列。</p>
</li>
<li>
<p>工作原理</p>
<p>当数据第一次访问时，2Q 算法将数据缓存在 FIFO 队列里面，当数据第二次被访问时，则将数据从 FIFO 队列移到 LRU 队列里面，两个队列各自按照自己的方法淘汰数据。详细实现如下：</p>
<p>![img](D:\Blog\source_posts\CMU15-445 Project1\20230425002.png)</p>
<ol>
<li>新访问的数据插入到 FIFO 队列；</li>
<li>如果数据在 FIFO 队列中一直没有被再次访问，则最终按照 FIFO 规则淘汰；</li>
<li>如果数据在 FIFO 队列中被再次访问，则将数据移到 LRU 队列头部；</li>
<li>如果数据在 LRU 队列再次被访问，则将数据移到 LRU 队列头部；</li>
<li>LRU 队列淘汰末尾的数据。</li>
</ol>
</li>
</ul>
<h1 id="buffer-pool-manager-instance"><a class="markdownIt-Anchor" href="#buffer-pool-manager-instance">#</a> Buffer Pool Manager Instance</h1>
<h2 id="review"><a class="markdownIt-Anchor" href="#review">#</a> review</h2>
<p>实现缓冲池的两个重要数据结构：</p>
<ul>
<li>可扩展哈希表</li>
<li>LRU-K</li>
</ul>
<p>本节将介绍缓冲池实现的具体细节，通过模式关系图和代码，加深对传统关系型数据库中缓冲池的理解。</p>
<h2 id="task-3"><a class="markdownIt-Anchor" href="#task-3">#</a> task</h2>
<p>最后我们需要实现缓冲池管理系统 ( <code>BufferPoolManagerInstance</code> )。 <code>BufferPoolManagerInstance</code>  是用来从 <code>DiskManager</code>  中获取数据库的页的，以及在内存中存储它们。 <code>BufferPoolManagerInstance</code>  也可以将脏页 (dirty page) 写到磁盘上，当它被明确指示的时候，或者当它需要驱逐一个页面来腾出空间给新的页面的时候。(计组和 OS 的知识)。</p>
<p>为了确保我们的实现能和系统的其他部分正常工作，本项目将提供一些已经填写好的函数。我们也不需要实现向磁盘实际读写数据的代码 (这些在我们的实现中被称为:  <code>DiskManager</code> )。本项目将提供这一功能。</p>
<p>系统中的所有内存页都由 <code>Page</code>  对象表示。 <code>BufferPoolManagerInstance</code>  不需要理解这些页面的内容。但是作为系统开发者，我们必须了解 <code>Page</code>  对象只是缓冲池中内容的容器，因此并不特定于某个独立的页面。也就是说，每个 <code>Page</code>  对象都包含一个内存块， <code>DiskManager</code>  将把它作为一个位置来复制从磁盘读取的物理页的内容。</p>
<p><code>BufferPoolManagerInstance</code>  将重复使用同一个 <code>Page</code>  对象来存储数据，因为它从磁盘来回移动。这意味着在系统的整个生命周期中，同一个 <code>Page</code>  对象可能包含不同的物理页。 <code>Page</code>  对象的标识符 ( <code>page_id</code> ) 可以跟踪它所包含的物理页。如果一个 <code>Page</code>  对象不包含一个物理页，那么 <code>page_id</code>  被设为 <code>INVALID_PAGE_ID</code></p>
<p>每个页面对象也维护一个计数器，用于记录 Pinned 该页面的线程数量。我们的 <code>BufferPoolManagerInstance</code>  不允许释放一个被 Pinned 住的页面！每个页面对象也会记录它是否是脏的，我们的工作就是记录一个页面在被解除 Pinned 住之前，是否被修改过。 我们的 <code>BufferPoolManagerInstance</code>  必须将一个脏页的内容写回到磁盘上。然后该对象才能被重新使用。</p>
<p>我们的 <code>BufferPoolManagerInstance</code>  实现将使用我们在本作业中前几步中创建的 <code>ExtendibleHashTable</code>  和 <code>LRUReplacer</code>  类。它将使用 <code>ExtendibleHashTable</code>  表来映射 <code>page_id</code>  到 <code>frame_id</code> 。它还将使用 <code>LRUKReplacer</code>  来跟踪 <code>Page</code>  对象被访问的时间，这样当它必须释放一个 frame 以便为从磁盘复制一个新的物理页腾出空间的时候，它就可以决定驱逐哪个。</p>
<p>我们需要实现定义在头文件 ( <code>src/include/buffer/buffer_pool_manager_instance.h</code> ) 的源文件 ( <code>src/buffer/buffer_pool_manager_instance.cpp</code> )</p>
<ul>
<li><code>FetchPgImp(page_id)</code></li>
<li><code>UnpinPgImp(page_id, is_dirty)</code></li>
<li><code>FlushPgImp(page_id)</code></li>
<li><code>NewPgImp(page_id)</code></li>
<li><code>DeletePgImp(page_id)</code></li>
<li><code>FlushAllPagesImpl()</code></li>
</ul>
<p>函数的解释：</p>
<ul>
<li>
<p>For  <code>FetchPgImp</code> , 如果空闲列表没有可用的页面，并且所有的其他页面目前都被 Pinned 住了，我们应该返回 <code>nullptr</code> 。 <code>FlushPgImp</code>  应该刷新一个页面，不管它的 pin status 如何。</p>
</li>
<li>
<p>For  <code>UnpinPgImp</code> ,  <code>is_dirty</code>  参数记录了一个页面在 Pin 住的时候是否被修改。</p>
</li>
<li>
<p>当我们向在 <code>NewPgImp()</code>  创建一个新的页面的时候， <code>AllocatePage</code>  私有方法为 <code>BufferPoolManager</code>  提供了一个唯一的新页面 ID。另一个方面， <code>DeallocatePage()</code>  方法是一个模仿释放磁盘上的页面的 no-op，我们应该在 <code>DeletePgImp()</code>  实现中调用，</p>
<blockquote>
<p>原文：<br>
On the other hand, the  <code>DeallocatePage()</code>  method is a no-op that imitates freeing a page on the disk and you should call this in your  <code>DeletePgImp()</code>  implementation.</p>
</blockquote>
</li>
<li>
<p>最后请参考函数文档，来了解如何实现这些函数，以及 <code>BufferPoolManagerInstance</code>  如何与 <code>LRUKReplacer</code>  互动的细节。不要碰那些 non-impl 版本，本项目需要这些来评分。</p>
</li>
</ul>
<p>Disk Manager</p>
<p>磁盘管理器类 ( <code>src/include/storage/disk/disk_manager.h</code> ), 从磁盘读取和写入页面数据。当我们的缓冲池管理器将在需要向缓冲池获取页面，或者向磁盘刷新页面的时候，使用 <code>DiskManager::ReadPage()</code>  和 <code>DiskManager::WritePage()</code> 。</p>
<h2 id="难点"><a class="markdownIt-Anchor" href="#难点">#</a> 难点</h2>
<ol>
<li>NewPage 和 FetchPage 两个函数有什么区别？</li>
<li>page 和 frame 是什么关系？</li>
<li>flush 到磁盘后要不要清空 page 中的数据？</li>
<li>pip-count 引用计数不为 0 能不能 flush 刷新到磁盘？</li>
</ol>
<h2 id="架构关系图"><a class="markdownIt-Anchor" href="#架构关系图">#</a> 架构关系图</h2>
<ul>
<li></li>
</ul>

      <div class="tags">
          <a href="/tags/DataBase/" rel="tag"><i class="ic i-tag"></i> DataBase</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2023-03-10 19:20:01" itemprop="dateModified" datetime="2023-03-10T19:20:01+08:00">2023-03-10</time>
  </span>
  <span id="2023/03/08/CMU15-445 Project1/" class="item leancloud_visitors" data-flag-title="CMU15-445：Project#1 Buffer Pool" title="阅读次数">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">阅读次数</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">次</span>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>AdventureYX <i class="ic i-at"><em>@</em></i>
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://adventure-yx.github.io/2023/03/08/CMU15-445%20Project1/" title="CMU15-445：Project#1 Buffer Pool">https://adventure-yx.github.io/2023/03/08/CMU15-445 Project1/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aC1DTg=="><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2023/03/06/CMU15-445%20Project0/" itemprop="url" rel="prev" data-background-image="&#x2F;2023&#x2F;03&#x2F;06&#x2F;CMU15-445%20Project0&#x2F;cover-12.jpg" title="CMU15-445 Project#0 字典树trie">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> DataBase</span>
  <h3>CMU15-445 Project#0 字典树trie</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2023/03/10/STL/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.picgo.net&#x2F;2023&#x2F;04&#x2F;10&#x2F;cover-165df1ad39e75388b4.jpeg" title="STL">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> C++</span>
  <h3>STL</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#overview"><span class="toc-number">1.</span> <span class="toc-text"> Overview</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#project-specification"><span class="toc-number">2.</span> <span class="toc-text"> Project Specification</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#extendible-hash-table"><span class="toc-number">3.</span> <span class="toc-text"> Extendible Hash Table</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#task"><span class="toc-number">3.1.</span> <span class="toc-text"> task</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E5%93%88%E5%B8%8C%E8%A1%A8%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text"> 可扩展哈希表原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lru-k-replacement-policy"><span class="toc-number">4.</span> <span class="toc-text"> LRU-K Replacement Policy</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#task-2"><span class="toc-number">4.1.</span> <span class="toc-text"> task</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lru-k%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text"> LRU-K 算法原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#buffer-pool-manager-instance"><span class="toc-number">5.</span> <span class="toc-text"> Buffer Pool Manager Instance</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#review"><span class="toc-number">5.1.</span> <span class="toc-text"> review</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#task-3"><span class="toc-number">5.2.</span> <span class="toc-text"> task</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9"><span class="toc-number">5.3.</span> <span class="toc-text"> 难点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">5.4.</span> <span class="toc-text"> 架构关系图</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li><a href="/2023/03/06/CMU15-445/" rel="bookmark" title="CMU15-445（2022Fall）">CMU15-445（2022Fall）</a></li><li><a href="/2023/03/06/CMU15-445%20Project0/" rel="bookmark" title="CMU15-445 Project#0 字典树trie">CMU15-445 Project#0 字典树trie</a></li><li class="active"><a href="/2023/03/08/CMU15-445%20Project1/" rel="bookmark" title="CMU15-445：Project#1 Buffer Pool">CMU15-445：Project#1 Buffer Pool</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="AdventureYX"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">AdventureYX</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">27</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">5</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">13</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FkdmVudHVyZS15eA==" title="https:&#x2F;&#x2F;github.com&#x2F;Adventure-yx"><i class="ic i-github"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2023/03/06/CMU15-445%20Project0/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2023/03/10/STL/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Linux/" title="分类于 Linux">Linux</a>
</div>

    <span><a href="/2023/04/18/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="C++网络编程">C++网络编程</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/06/10/MFC%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/" title="MFC 常用控件">MFC 常用控件</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/03/30/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/" title="算法进阶">算法进阶</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/06/05/C++Boost%E5%BA%93%20%E5%87%BD%E6%95%B0%E4%B8%8E%E5%9B%9E%E8%B0%83/" title="C++Boost库 函数与回调">C++Boost库 函数与回调</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/05/25/MFC%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/" title="MFC 应用程序框架">MFC 应用程序框架</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/06/25/MFC%E6%96%87%E6%A1%A3%E8%A7%86%E5%9B%BE%E6%A1%86%E6%9E%B6/" title="MFC 文档&#x2F;视图框架">MFC 文档/视图框架</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/DataBase/" title="分类于 DataBase">DataBase</a>
</div>

    <span><a href="/2023/03/06/CMU15-445/" title="CMU15-445（2022Fall）">CMU15-445（2022Fall）</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/06/09/MFC%E5%B8%B8%E7%94%A8%E7%B1%BB/" title="MFC 常用类">MFC 常用类</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Qt/" title="分类于 Qt">Qt</a>
</div>

    <span><a href="/2023/03/26/QML&QtQuick/" title="QML &amp; Qt Quick">QML & Qt Quick</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Qt/" title="分类于 Qt">Qt</a>
</div>

    <span><a href="/2023/04/20/qtchat/" title="基于Qt框架实现网络聊天室">基于Qt框架实现网络聊天室</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2022 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">AdventureYX @ Adventure</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2023/03/08/CMU15-445 Project1/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
