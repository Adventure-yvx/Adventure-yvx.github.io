



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="" href="https://adventure-yx.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://adventure-yx.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://adventure-yx.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="Linux" />


<link rel="canonical" href="https://adventure-yx.github.io/2023/03/01/Linux/">



  <title>
Linux - Linux |
Adventure =  = 心有所向。日复一日，必有精进</title>
<meta name="generator" content="Hexo 6.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">Linux
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2023-03-01 22:03:56">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2023-03-01T22:03:56+08:00">2023-03-01</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Adventure</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="https://img.picgo.net/2023/04/02/cover-4eb532c64ce3f5188.jpeg">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Linux/" itemprop="item" rel="index" title="分类于 Linux"><span itemprop="name">Linux</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://adventure-yx.github.io/2023/03/01/Linux/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="AdventureYX">
    <meta itemprop="description" content="心有所向。日复一日，必有精进, ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="linux-配置"><a class="markdownIt-Anchor" href="#linux-配置">#</a> Linux 配置</h1>
<p>windows powershell</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>wsl <span class="token parameter variable">--installl</span> <span class="token parameter variable">-d</span> Ubuntu-20.04</pre></td></tr></table></figure><p>linux</p>
<p>uname -r ： 显示操作系统的发行版号<br>
 uname -a ：显示系统名、节点名称、操作系统的发行版号、内核版本等等。</p>
<p><img data-src="image-20230420174648351.png" alt="image-20230420174648351"></p>
<blockquote>
<p><strong>系统名：</strong></p>
<p>Linux</p>
<p><strong>节点名称：</strong></p>
<p>LAPTOP-G8CK4FEN</p>
<p><strong>操作系统的发行版号：</strong></p>
<p>5.10.16.3-microsoft-standard-WSL2</p>
<p><strong>硬件平台：</strong><br>
x86_64</p>
<p><strong>机器硬件名：</strong><br>
x86_64</p>
<p><strong>系统处理器的体系结构：</strong><br>
x86_64</p>
<p><strong>操作系统：</strong><br>
GNU/Linux</p>
</blockquote>
<p>更新软件包</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">apt-get</span> update</pre></td></tr></table></figure><p>安装最常用 linux 桌面程序 gedit</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">apt</span> <span class="token function">install</span> gedit</pre></td></tr></table></figure><p>安装编译工具 gcc+cmake</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">apt</span> <span class="token function">install</span> build-essential</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">apt</span> <span class="token function">install</span> cmake</pre></td></tr></table></figure><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">vim</span></pre></td></tr></table></figure><ul>
<li>
<p>Linux yum 命令</p>
<p><code>yum</code> （ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。</p>
<p>基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p>
<p><code>yum</code>  提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
</li>
<li>
<p>Linux apt 命令</p>
<p><code>apt</code> （Advanced Packaging Tool）是一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。</p>
<p><code>apt</code>  命令提供了查找、安装、升级、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
<p><code>apt</code>  命令执行需要超级管理员权限 (root)。</p>
</li>
</ul>
<h1 id="linux基础"><a class="markdownIt-Anchor" href="#linux基础">#</a> Linux 基础</h1>
<h2 id="一些名词"><a class="markdownIt-Anchor" href="#一些名词">#</a> 一些名词</h2>
<p>在学习和使用 Linux 的过程中，经常会见到一些特有名词:</p>
<ul>
<li>GNU：Gnu’s Not Unix. 可以理解成一种口号，最早由 Richard Stallman 呼吁并倡导的，号召软件自由。</li>
<li>GPL：General Public License. GNU 通用公共许可证，GPL 授予程序的接受方下述的权利，即 GPL 所倡导的 “自由”：
<ul>
<li>可以以任何目的运行所购买的程序；</li>
<li>在得到程序代码的前提下，可以以学习为目的，对源程序进行修改；</li>
<li>可以对复制件进行再发行；</li>
<li>对所购买的程序进行改进，并进行公开发布。</li>
</ul>
</li>
<li>LGPL (GNU Lesser General Public License): LGPL 是 GPL 的一个为主要为类库使用设计的开源协议。
<ul>
<li>LGPL 允许商业软件通过类库引用 (link) 方式使用 LGPL 类库而不需要开源商业软件的代码。</li>
<li>采用 LGPL 协议的开源代码可以被商业软件作为类库引用并发布和销售。</li>
</ul>
</li>
<li>BSD 开源协议: BSD 开源协议是一个给于使用者很大自由的协议。基本上使用者可以” 为所欲为”，以 BSD 协议代码为基础做二次开发自己的产品时，需要满足三个条件：
<ul>
<li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的 BSD 协议。</li>
<li>不可以用开源代码的作者 / 机构名字和原来产品的名字做市场推广。</li>
<li>BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。</li>
</ul>
</li>
<li>FSF：自由软件基本会，给 GNU 提供资金支付的，毕竟没钱难成事啊。</li>
<li>自由软件：GNU 项目下的所有软件都基于 GPL 许可证（非 GNU 项目也可使用 GPL），都是自由软件。</li>
<li>开源软件：是美国 Open Source Initiative 协会定义，软件开放源代码。</li>
<li>POSIX：（Portable Operating System Interface for Computing Systems）是由 IEEE 和 ISO/IEC 开发的一套标准。POSIX 标准是对 UNIX 操作系统的经验和实践的总结，对操作系统调用的服务接口进行了标准化，保证所编制的应用程序在源代码一级可以在多种操作系统上进行移植。</li>
</ul>
<h2 id="linux-内核"><a class="markdownIt-Anchor" href="#linux-内核">#</a> Linux 内核</h2>
<p>Linux 系统从应用角度来看，分为内核空间和用户空间两个部分。内核空间是 Linux 操作系统的主要部分，但是仅有内核的操作系统是不能完成用户任务的。丰富并且功能强大的应用程序包是一个操作系统成功的必要件。</p>
<p>Linux 的内核主要由 5 个子系统组成：** 进程调度、内存管理、虚拟文件系统、网络接口、进程间通信。** 下面将依次讲解这 5 个子系统。</p>
<ul>
<li>
<p>进程调度 SCHED</p>
<p>进程调度指的是系统对进程的多种状态之间转换的策略。Linux 下的进程调度有 3 种策略：SCHED_OTHER、SCHED_FIFO 和 SCHED_RR。</p>
<ul>
<li>SCHED_OTHER：分时调度策略（默认），是用于针对普通进程的时间片轮转调度策略。</li>
<li>SCHED_FIFO：实时调度策略，是针对运行的实时性要求比较高、运行时间短的进程调度策略</li>
<li>SCHED_RR：实时调度策略，是针对实时性要求比较高、运行时间比较长的进程调度策略。</li>
</ul>
</li>
<li>
<p>内存管理 MMU</p>
<ul>
<li>内存管理是多个进程间的内存共享策略。在 Linux 中，内存管理主要说的是虚拟内存。</li>
<li>虚拟内存可以让进程拥有比实际物理内存更大的内存，可以是实际内存的很多倍。</li>
<li>每个进程的虚拟内存有不同的地址空间，多个进程的虚拟内存不会冲突。</li>
</ul>
</li>
<li>
<p>虚拟文件系统 VFS</p>
<ul>
<li>在 Linux 下支持多种文件系统，如 ext、ext2、minix、umsdos、msdos、vfat、ntfs、proc、smb、ncp、iso9660、sysv、hpfs、affs 等。</li>
<li>目前 Linux 下最常用的文件格式是 ext2 和 ext3。</li>
</ul>
</li>
<li>
<p>网络接口</p>
<p>Linux 是在 Internet 飞速发展的时期成长起来的，所以 Linux 支持多种网络接口和协议。网络接口分为网络协议和驱动程序，网络协议是一种网络传输的通信标准，而网络驱动则是对硬件设备的驱动程序。Linux 支持的网络设备多种多样，几乎目前所有网络设备都有驱动程序。</p>
</li>
<li>
<p>进程间通信</p>
<p>Linux 操作系统支持多进程，进程之间需要进行数据的交流才能完成控制、协同工作等功能，Linux 的进程间通信是从 UNIX 系统继承过来的。Linux 下的进程间的通信方式主要有管道、信号、消息队列、共享内存和套接字等方法。</p>
</li>
</ul>
<h2 id="linux-系统目录结构"><a class="markdownIt-Anchor" href="#linux-系统目录结构">#</a> Linux 系统目录结构</h2>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">ls</span> /</pre></td></tr></table></figure><p><img data-src="image-20230309080718084.png" alt="image-20230309080718084"></p>
<p>树状目录结构：</p>
<p><img data-src="d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="img"></p>
<p><strong>系统启动必须：</strong></p>
<ul>
<li>
<p><code>/boot</code> ：存放的启动 Linux 时使用的内核文件，包括连接文件以及镜像文件。</p>
</li>
<li>
<p><code>/etc</code> ：<strong>存放</strong>所有<strong>的系统需要的</strong>配置文件<strong>和</strong>子目录列表，** 更改目录下的文件可能会导致系统不能启动。</p>
</li>
<li>
<p><code>/lib</code> ：存放基本代码库（比如 c++ 库），其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p>
</li>
<li>
<p><code>/sys</code> ： 这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中</p>
</li>
</ul>
<p><strong>指令集合：</strong></p>
<ul>
<li>
<p><code>/bin</code> ：存放着最常用的程序和指令</p>
</li>
<li>
<p><code>/sbin</code> ：只有系统管理员能使用的程序和指令。是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p>
</li>
</ul>
<p><strong>外部文件管理：</strong></p>
<ul>
<li>
<p><code>/dev</code>  ：Device (设备) 的缩写，存放的是 Linux 的外部设备。<strong>注意</strong>：在 Linux 中访问设备和访问文件的方式是相同的。</p>
</li>
<li>
<p><code>/media</code> ：类 windows 的<strong>其他设备</strong>，例如 U 盘、光驱等等，识别后 linux 会把设备放到这个目录下。</p>
</li>
<li>
<p><code>/mnt</code> ：临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
</ul>
<p><strong>临时文件：</strong></p>
<ul>
<li>
<p><code>/run</code> ：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p>
</li>
<li>
<p><code>/lost+found</code> ：一般情况下为空的，系统非法关机后，这里就存放一些文件。</p>
</li>
<li>
<p><code>/tmp</code> ：这个目录是用来存放一些临时文件的。</p>
</li>
</ul>
<p><strong>账户：</strong></p>
<ul>
<li>
<p><code>/root</code> ：系统管理员的用户主目录。</p>
</li>
<li>
<p><code>/home</code> ：用户的主目录，以用户的账号命名的。</p>
</li>
<li>
<p><code>/usr</code> ： usr 是 unix shared resources (共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p>
</li>
<li>
<p><code>/usr/bin</code> ：系统用户使用的应用程序与指令。</p>
</li>
<li>
<p><code>/usr/sbin</code> ：超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li>
<p><code>/usr/src</code> ：内核源代码默认的放置目录。</p>
</li>
</ul>
<p><strong>运行过程中要用：</strong></p>
<ul>
<li>
<p><code>/var</code> ：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。</p>
</li>
<li>
<p><code>/proc</code> ：管理 ** 内存空间！** 虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</p>
</li>
</ul>
<p><strong>扩展用的：</strong></p>
<ul>
<li>
<p><code>/opt</code> ：默认是空的，我们安装额外软件可以放在这个里面。</p>
</li>
<li>
<p><code>/srv</code> ：存放服务启动后需要提取的数据 **（不用服务器就是空）**</p>
</li>
</ul>
<h2 id="linux-文件基本属性"><a class="markdownIt-Anchor" href="#linux-文件基本属性">#</a> Linux 文件基本属性</h2>
<p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。</p>
<p>为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p>
<p>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p>
<ul>
<li><code>chown</code>  (change owner) ： 修改所属用户与组。</li>
<li><code>chmod</code>  (change mode) ： 修改用户的权限。</li>
</ul>
<p>在 Linux 中我们可以使用  <code>ll</code>  或者  <code>ls –l</code>  命令来显示一个文件的属性以及文件所属的用户和组，如：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>root@LAPTOP-G8CK4FEN:/<span class="token comment"># ll</span></pre></td></tr><tr><td data-num="2"></td><td><pre>total <span class="token number">1480</span></pre></td></tr><tr><td data-num="3"></td><td><pre>drwxr-xr-x  <span class="token number">19</span> root root    <span class="token number">4096</span> Mar  <span class="token number">9</span> 08:01 ./</pre></td></tr><tr><td data-num="4"></td><td><pre>drwxr-xr-x  <span class="token number">19</span> root root    <span class="token number">4096</span> Mar  <span class="token number">9</span> 08:01 <span class="token punctuation">..</span>/</pre></td></tr><tr><td data-num="5"></td><td><pre>lrwxrwxrwx   <span class="token number">1</span> root root       <span class="token number">7</span> Apr <span class="token number">23</span>  <span class="token number">2020</span> bin -<span class="token operator">></span> usr/bin/</pre></td></tr><tr><td data-num="6"></td><td><pre>drwxr-xr-x   <span class="token number">2</span> root root    <span class="token number">4096</span> Apr <span class="token number">23</span>  <span class="token number">2020</span> boot/</pre></td></tr></table></figure><p>实例中，<strong>boot</strong> 文件的第一个属性用 <strong>d</strong> 表示。<strong>d</strong> 在 Linux 中代表该文件是一个目录文件。</p>
<p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p>
<ul>
<li>当为 <strong>d</strong> 则是目录</li>
<li>当为 <strong>-</strong> 则是文件；</li>
<li>若是 <strong>l</strong> 则表示为链接文档 (link file)；</li>
<li>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备 (可随机存取装置)；</li>
<li>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标 (一次性读取装置)。</li>
</ul>
<p>接下来的字符中，以三个为一组，且均为 <strong>rwx</strong> 的三个参数的组合。其中， <strong>r</strong> 代表可读 (read)、 <strong>w</strong> 代表可写 (write)、 <strong>x</strong> 代表可执行 (execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 <strong>-</strong> 而已。</p>
<p><img data-src="file-llls22.jpg" alt="img"></p>
<p><img data-src="363003_1227493859FdXT.png" alt="363003_1227493859FdXT"></p>
<p>从左至右用 <strong>0-9</strong> 这些数字来表示。</p>
<p>第 <strong>0</strong> 位确定文件类型，第 <strong>1-3</strong> 位确定属主（该文件的所有者）拥有该文件的权限。</p>
<p>第 4-6 位确定属组（所有者的同组用户）拥有该文件的权限，第 7-9 位确定其他用户拥有该文件的权限。</p>
<p>其中，第 <strong>1、4、7</strong> 位表示读权限，如果用 <strong>r</strong> 字符表示，则有读权限，如果用 <strong>-</strong> 字符表示，则没有读权限；第 <strong>2、5、8</strong> 位表示写权限，如果用 <strong>w</strong> 字符表示，则有写权限，如果用 <strong>-</strong> 字符表示没有写权限；第 <strong>3、6、9</strong> 位表示可执行权限，如果用 <strong>x</strong> 字符表示，则有执行权限，如果用 <strong>-</strong> 字符表示，则没有执行权限。</p>
<h2 id="linux-文件与目录管理"><a class="markdownIt-Anchor" href="#linux-文件与目录管理">#</a> Linux 文件与目录管理</h2>
<p>我们知道 Linux 的目录结构为树状结构，最顶级的目录为根目录 <strong>/</strong>。</p>
<p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p>
<ul>
<li><strong>绝对路径：</strong><br>
路径的写法，由根目录 <strong>/</strong> 写起，例如： <code>/usr/share/doc</code>  这个目录。</li>
<li><strong>相对路径：</strong><br>
路径的写法，不是由 <strong>/</strong> 写起，例如由  <code>/usr/share/doc</code>  要到  <code>/usr/share/man</code>  底下时，可以写成：  <code>cd ../man</code>  这就是相对路径的写法。</li>
</ul>
<p><strong>“/” 在系统文件中表示绝对路径；</strong></p>
<p>“/” 处于 Linux 文件系统<strong>树形结构</strong>的最顶端，我们称它为 Linux 文件系统的 root，<strong>它是 Linux 文件系统的入口</strong>；<br>
所有的目录、文件、设备都在 “/” 之下，它是 Linux 文件系统最顶层的唯一的目录；<br>
一般建议在根目录下面只有目录，不要直接存放文件；<br>
根目录是 linux 系统启动时系统第一个载入的分区，所以启动过程中用到的文件应该都放在这个分区中；<br>
其中 <code>/etc</code> 、 <code>/bin</code> 、 <code>/dev</code> 、 <code>/lib</code> 、 <code>/sbin</code>  这 5 个子目录都应该要与根目录连在一起，不可独立成为某个分区。</p>
<p><strong>“./” 代表的意思是</strong>： ./ 代表当前文件目录，某一个文件（或者目录）的查找路径是从当前目录 “.” 下面开始进行查找。</p>
<p><strong>“~” 代表的意思是</strong>：表示代码主目录，也就是当前登录用户的用户目录。</p>
<p><strong>“…” 代表的意思是</strong>：“…” 表示上级目录</p>
<h2 id="命令解析器"><a class="markdownIt-Anchor" href="#命令解析器">#</a> 命令解析器</h2>
<blockquote>
<p>在 Linux 中需要通过终端执行对应的命令来完成某些操作，那么这些命令是如何被执行的呢？</p>
<p>这些命令都是通过命令解析器解析完成并执行的，如果用户在终端输入是正确的内部指令，命令解析器就执行这个命令，如果不是正确的指令，则提示命令无法解析。</p>
</blockquote>
<h3 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理">#</a> 工作原理</h3>
<p>命令解析器在 Linux 操作系统中就是一个进程 (运行的应用程序), 它的名字叫做 bash 通常我们更习惯将其称之为 shell (即: sh)。他们之间的渊源是这样的，在 Unix 操作系统诞生之后一个叫伯恩 (Bourne) 的人为其编写了命令解析器取名为 shell, Linux 操作系统诞生之后伯恩再次改写了 shell (sh), 将其称之为 bash (Bourne Again SHell), bash 就是 sh 的增强版本。</p>
<p>在 Linux 操作系统中默认使用的命令解析器是 bash, 当然也同样支持使用 sh。当用户打开一个终端窗口，并输入相关指令， 按回车键， 这时候命令解析器就开始工作了， 具体步骤如下：</p>
<ul>
<li>
<p>在 Linux 中有一个叫做 PATH 的环境变量，里边存储了一些系统目录 (windows 也有，叫 Path)</p>
<figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 通过 echo 命令可以查看环境变量 PATH 中的值，在 shell 中变量名前加 $ 就是取值</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>root@VM-8-14-centos ~<span class="token punctuation">]</span><span class="token comment"># echo $PATH</span></pre></td></tr><tr><td data-num="3"></td><td><pre>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</pre></td></tr></table></figure></li>
<li>
<p>命令解析器需要依次搜索 PATH 中的各个目录，检查这些目录中是否有用户输入的指令</p>
<ul>
<li>
<p>如果找到了，执行该目录下的可执行程序，用户输入的命令就被执行完毕了</p>
</li>
<li>
<p>如果没有找到，继续搜索其他目录，最后还是没有找到，会提示命令找不到，因此无法被执行</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@VM-8-14-centos ~<span class="token punctuation">]</span><span class="token comment"># asdjflksd</span></pre></td></tr><tr><td data-num="2"></td><td><pre>-bash: asdjflksd: <span class="token builtin class-name">command</span> not found</pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="命令提示行"><a class="markdownIt-Anchor" href="#命令提示行">#</a> 命令提示行</h3>
<p>在 Linux 终端中，输入要执行的指令之前会有想用的命令提示，我们将其称之为命令提示行，例如:</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@VM-8-14-centos ~/mywork/workspace<span class="token punctuation">]</span><span class="token comment">#</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>user01@VM-8-14-centos ~/mywork/workspace<span class="token punctuation">]</span>$</pre></td></tr></table></figure><ul>
<li><code>root</code>  : 当前登录的用户的用户名</li>
<li><code>@</code> : at -&gt; 在</li>
<li><code>VM-8-14-centos</code> : 主机名，在安装这个 linux 操作系统的时候手动指定，可以修改
<ul>
<li><code>~</code> : 当前用户的家目录
<ul>
<li>在 linux 中有很多用户，每个用户都用一个属于自己的目录，这个目录称之为家目录</li>
<li>普通用户家目录 /home/ 用户名，root 用户家目录 /root</li>
</ul>
</li>
<li><code>~/mywork/workspace</code> : 当前用户所在的工作目录，也可以使用 pwd 命令查看</li>
<li><code>#</code> : 代表当前用户是  <code>root</code>  用户</li>
<li><code>$:</code>  当前用户是普通用户，也就是说例子中的 <code>user01</code>  是一个普通用户</li>
</ul>
</li>
</ul>
<h3 id="命令行快捷键"><a class="markdownIt-Anchor" href="#命令行快捷键">#</a> 命令行快捷键</h3>
<ul>
<li><code>Tab</code> 	命令自动补齐
<ul>
<li>在终端中输入 某个命令的前一个或若干个字符，再按 Tab 键</li>
<li>由于很多 shell 命令的开头字母是相同的，在这种情况下，按一次 Tab 是不会自动补齐的，我们可以连续按两次 Tab 键，在当前终端中就可以显示出所有匹配成功的 shell 命令</li>
<li>为了能够快速补全 shell 指令，我们可以多输入一些前缀字符之后，再按 Tab 键</li>
</ul>
</li>
<li><code>Ctrl+p</code> 	显示输入的上一个历史命令
<ul>
<li>从输入的最后一个命令往前倒，也可以使用 ↑键</li>
</ul>
</li>
<li><code>Ctrl+n</code> 	显示输入的下一个历史命令	也可以使用 ↓键</li>
<li><code>Ctrl+a</code> 	光标移动命命令行首	也可以使用 Home 键</li>
<li><code>Ctrl+e</code> 	光标移动命命令行尾	也可以使用 End 键</li>
<li><code>Ctrl+u</code> 	删除光标前的部分字符串</li>
<li><code>Ctrl+k</code> 	删除光标后的部分字符串</li>
<li><code>Backspace/Delete</code> 	删除光标前 / 后的一个字符</li>
</ul>
<h2 id="处理目录的常用命令"><a class="markdownIt-Anchor" href="#处理目录的常用命令">#</a> 处理目录的常用命令</h2>
<ul>
<li><code>ls</code> （英文全拼：list files）: 列出目录及文件名</li>
<li><code>cd</code> （英文全拼：change directory）：切换目录</li>
<li><code>pwd</code> （英文全拼：print work directory）：显示目前的目录</li>
<li><code>mkdir</code> （英文全拼：make directory）：创建一个新的目录</li>
<li><code>rmdir</code> （英文全拼：remove directory）：删除一个空的目录</li>
<li><code>cp</code> （英文全拼：copy file）: 复制文件或目录</li>
<li><code>rm</code> （英文全拼：remove）: 删除文件或目录</li>
<li><code>mv</code> （英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p>可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p>
<h3 id="ls-列出目录"><a class="markdownIt-Anchor" href="#ls-列出目录">#</a> ls (列出目录)</h3>
<p>在 Linux 系统当中， ls 命令可能是最常被运行的。</p>
<p>选项与参数：</p>
<ul>
<li>-a ：全部的文件，连同隐藏文件 (开头为。的文件) 一起列出来 (常用)</li>
<li>-d ：仅列出目录本身，而不是列出目录内的文件数据 (常用)</li>
<li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li>
</ul>
<h3 id="cd-切换目录"><a class="markdownIt-Anchor" href="#cd-切换目录">#</a> cd (切换目录)</h3>
<p>cd 是 Change Directory 的缩写，这是用来变换工作目录的命令。</p>
<p>语法：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token builtin class-name">cd</span> <span class="token punctuation">[</span>相对路径或绝对路径<span class="token punctuation">]</span></pre></td></tr></table></figure><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">#使用 mkdir 命令创建 runoob 目录</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># mkdir runoob</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">#使用绝对路径切换到 runoob 目录</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># cd /root/runoob/</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">#使用相对路径切换到 runoob 目录</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># cd ./runoob/</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment"># 表示回到自己的家目录，亦即是 /root 这个目录</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">[</span>root@www runoob<span class="token punctuation">]</span><span class="token comment"># cd ~</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment"># 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># cd ..</span></pre></td></tr></table></figure><h3 id="pwd-显示目前所在的目录"><a class="markdownIt-Anchor" href="#pwd-显示目前所在的目录">#</a> pwd (显示目前所在的目录)</h3>
<p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># pwd [-P]</span></pre></td></tr></table></figure><p>选项与参数：</p>
<ul>
<li><strong>-P</strong> ：显示出确实的路径，而非使用链接 (link) 路径。</li>
</ul>
<h3 id="mkdir-创建新目录"><a class="markdownIt-Anchor" href="#mkdir-创建新目录">#</a> mkdir (创建新目录)</h3>
<p>如果想要创建新的目录的话，那么就使用 mkdir (make directory) 吧。</p>
<p>语法：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">mkdir</span> <span class="token punctuation">[</span>-mp<span class="token punctuation">]</span> 目录名称</pre></td></tr></table></figure><p>选项与参数：</p>
<ul>
<li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li>
<li>-p ：帮助你直接将所需要的目录 (包含上一级目录) 递归创建起来！</li>
</ul>
<p>实例：请到 /tmp 底下尝试创建数个新目录看看：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># cd /tmp</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>root@www tmp<span class="token punctuation">]</span><span class="token comment"># mkdir test    &lt;== 创建一名为 test 的新目录</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">[</span>root@www tmp<span class="token punctuation">]</span><span class="token comment"># mkdir test1/test2/test3/test4</span></pre></td></tr><tr><td data-num="4"></td><td><pre>mkdir: cannot create directory `test1/test2/test3/test4': </pre></td></tr><tr><td data-num="5"></td><td><pre>No such <span class="token function">file</span> or directory       <span class="token operator">&lt;=</span><span class="token operator">=</span> 没办法直接创建此目录啊！</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">[</span>root@www tmp<span class="token punctuation">]</span><span class="token comment"># mkdir -p test1/test2/test3/test4</span></pre></td></tr></table></figure><h3 id="rmdir-删除空的目录"><a class="markdownIt-Anchor" href="#rmdir-删除空的目录">#</a> rmdir (删除空的目录)</h3>
<p>语法：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">rmdir</span> <span class="token punctuation">[</span>-p<span class="token punctuation">]</span> 目录名称</pre></td></tr></table></figure><p>选项与参数：</p>
<ul>
<li>**-p ：** 从该目录起，一次删除多级空目录</li>
</ul>
<p>删除 runoob 目录</p>
<pre><code>[root@www tmp]# rmdir runoob/
</code></pre>
<p>将 mkdir 实例中创建的目录 (/tmp 底下) 删除掉！</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@www tmp<span class="token punctuation">]</span><span class="token comment"># ls -l   &lt;== 看看有多少目录存在？</span></pre></td></tr><tr><td data-num="2"></td><td><pre>drwxr-xr-x  <span class="token number">3</span> root  root <span class="token number">4096</span> Jul <span class="token number">18</span> <span class="token number">12</span>:50 <span class="token builtin class-name">test</span></pre></td></tr><tr><td data-num="3"></td><td><pre>drwxr-xr-x  <span class="token number">3</span> root  root <span class="token number">4096</span> Jul <span class="token number">18</span> <span class="token number">12</span>:53 test1</pre></td></tr><tr><td data-num="4"></td><td><pre>drwx--x--x  <span class="token number">2</span> root  root <span class="token number">4096</span> Jul <span class="token number">18</span> <span class="token number">12</span>:54 test2</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">[</span>root@www tmp<span class="token punctuation">]</span><span class="token comment"># rmdir test   &lt;== 可直接删除掉，没问题</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">[</span>root@www tmp<span class="token punctuation">]</span><span class="token comment"># rmdir test1  &lt;== 因为尚有内容，所以无法删除！</span></pre></td></tr><tr><td data-num="7"></td><td><pre>rmdir: `test1': Directory not empty</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">[</span>root@www tmp<span class="token punctuation">]</span><span class="token comment"># rmdir -p test1/test2/test3/test4</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">[</span>root@www tmp<span class="token punctuation">]</span><span class="token comment"># ls -l        &lt;== 您看看，底下的输出中 test 与 test1 不见了！</span></pre></td></tr><tr><td data-num="10"></td><td><pre>drwx--x--x  <span class="token number">2</span> root  root <span class="token number">4096</span> Jul <span class="token number">18</span> <span class="token number">12</span>:54 test2</pre></td></tr></table></figure><p>利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。</p>
<p>不过要注意的是，这个 <strong>rmdir 仅能删除空的目录</strong>，你可以使用 <strong>rm 命令来删除非空目录</strong>。</p>
<h3 id="cp-复制文件或目录"><a class="markdownIt-Anchor" href="#cp-复制文件或目录">#</a> cp (复制文件或目录)</h3>
<p>cp 即拷贝文件和目录。</p>
<p>语法:</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># cp [-adfilprsu] 来源档 (source) 目标档 (destination)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># cp [options] source1 source2 source3 .... directory</span></pre></td></tr></table></figure><p>选项与参数：</p>
<ul>
<li>**-a：** 相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li>
<li>**-d：** 若来源档为链接档的属性 (link file)，则复制链接档属性而非文件本身；</li>
<li>**-f：** 为强制 (force) 的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li>
<li>**-i：** 若目标档 (destination) 已经存在时，在覆盖时会先询问动作的进行 (常用)</li>
<li>**-l：** 进行硬式链接 (hard link) 的链接档创建，而非复制文件本身；</li>
<li>**-p：** 连同文件的属性一起复制过去，而非使用默认属性 (备份常用)；</li>
<li>**-r：** 递归持续复制，用於目录的复制行为；(常用)</li>
<li>**-s：** 复制成为符号链接档 (symbolic link)，亦即『捷径』文件；</li>
<li>**-u：** 若 destination 比 source 旧才升级 destination ！</li>
</ul>
<p>用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># cp ~/.bashrc /tmp/bashrc</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># cp -i ~/.bashrc /tmp/bashrc</span></pre></td></tr><tr><td data-num="3"></td><td><pre>cp: overwrite `/tmp/bashrc'? n  <span class="token operator">&lt;=</span><span class="token operator">=</span>n不覆盖，y为覆盖</pre></td></tr></table></figure><h3 id="rm-移除文件或目录"><a class="markdownIt-Anchor" href="#rm-移除文件或目录">#</a> rm (移除文件或目录)</h3>
<p>语法：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">rm</span> <span class="token punctuation">[</span>-fir<span class="token punctuation">]</span> 文件或目录</pre></td></tr></table></figure><p>选项与参数：</p>
<ul>
<li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li>
<li>-i ：互动模式，在删除前会询问使用者是否动作</li>
<li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
</ul>
<p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@www tmp<span class="token punctuation">]</span><span class="token comment"># rm -i bashrc</span></pre></td></tr><tr><td data-num="2"></td><td><pre>rm: remove regular <span class="token function">file</span> `bashrc'? y</pre></td></tr></table></figure><p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p>
<h3 id="mv-移动文件与目录或修改名称"><a class="markdownIt-Anchor" href="#mv-移动文件与目录或修改名称">#</a> mv (移动文件与目录，或修改名称)</h3>
<p>语法：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># mv [-fiu] source destination</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># mv [options] source1 source2 source3 .... directory</span></pre></td></tr></table></figure><p>选项与参数：</p>
<ul>
<li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li>
<li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li>
</ul>
<p>复制一文件，创建一目录，将文件移动到目录中</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># cd /tmp</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">[</span>root@www tmp<span class="token punctuation">]</span><span class="token comment"># cp ~/.bashrc bashrc</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">[</span>root@www tmp<span class="token punctuation">]</span><span class="token comment"># mkdir mvtest</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">[</span>root@www tmp<span class="token punctuation">]</span><span class="token comment"># mv bashrc mvtest</span></pre></td></tr></table></figure><p>将某个文件移动到某个目录去，就是这样做！</p>
<p>将刚刚的目录名称更名为 mvtest2</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@www tmp<span class="token punctuation">]</span><span class="token comment"># mv mvtest mvtest2</span></pre></td></tr></table></figure><h2 id="linux-文件内容查看"><a class="markdownIt-Anchor" href="#linux-文件内容查看">#</a> Linux 文件内容查看</h2>
<p>Linux 系统中使用以下命令来查看文件的内容：</p>
<ul>
<li><code>cat</code>  由第一行开始显示文件内容</li>
<li><code>tac</code>  从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>
<li><code>nl</code>   显示的时候，顺道输出行号！</li>
<li><code>more</code>  一页一页的显示文件内容</li>
<li><code>less</code>  与  <code>more</code>  类似，但是比 more 更好的是，他可以往前翻页！</li>
<li><code>head</code>  只看头几行</li>
<li><code>tail</code>  只看尾巴几行</li>
</ul>
<p>你可以使用 *man [命令]* 来查看各个命令的使用文档，如 ：man cp。</p>
<h3 id="cat"><a class="markdownIt-Anchor" href="#cat">#</a> cat</h3>
<p>由第一行开始显示文件内容</p>
<p>语法：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">cat</span> <span class="token punctuation">[</span>-AbEnTv<span class="token punctuation">]</span></pre></td></tr></table></figure><p>选项与参数：</p>
<ul>
<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li>-E ：将结尾的断行字节 $ 显示出来；</li>
<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>
<li>-v ：列出一些看不出来的特殊字符</li>
</ul>
<p>检看 /etc/issue 这个文件的内容：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># cat /etc/issue</span></pre></td></tr><tr><td data-num="2"></td><td><pre>CentOS release <span class="token number">6.4</span> <span class="token punctuation">(</span>Final<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>Kernel <span class="token punctuation">\</span>r on an <span class="token punctuation">\</span>m</pre></td></tr></table></figure><h3 id="tac"><a class="markdownIt-Anchor" href="#tac">#</a> tac</h3>
<p>tac 与 cat 命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># tac /etc/issue</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>Kernel <span class="token punctuation">\</span>r on an <span class="token punctuation">\</span>m</pre></td></tr><tr><td data-num="4"></td><td><pre>CentOS release <span class="token number">6.4</span> <span class="token punctuation">(</span>Final<span class="token punctuation">)</span></pre></td></tr></table></figure><h3 id="nl"><a class="markdownIt-Anchor" href="#nl">#</a> nl</h3>
<p>显示行号</p>
<p>语法：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">nl</span> <span class="token punctuation">[</span>-bnw<span class="token punctuation">]</span> 文件</pre></td></tr></table></figure><p>选项与参数：</p>
<ul>
<li>-b ：指定行号指定的方式，主要有两种：<br>
-b a ：表示不论是否为空行，也同样列出行号 (类似 cat -n)；<br>
-b t ：如果有空行，空的那一行不要列出行号 (默认值)；</li>
<li>-n ：列出行号表示的方法，主要有三种：<br>
-n ln ：行号在荧幕的最左方显示；<br>
-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>
-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li>
<li>-w ：行号栏位的占用的位数。</li>
</ul>
<p>实例一：用 nl 列出 /etc/issue 的内容</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># nl /etc/issue</span></pre></td></tr><tr><td data-num="2"></td><td><pre>     <span class="token number">1</span>  CentOS release <span class="token number">6.4</span> <span class="token punctuation">(</span>Final<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>     <span class="token number">2</span>  Kernel <span class="token punctuation">\</span>r on an <span class="token punctuation">\</span>m</pre></td></tr></table></figure><h3 id="more"><a class="markdownIt-Anchor" href="#more">#</a> more</h3>
<p>一页一页翻动</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># more /etc/man_db.config </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">#</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># Generated automatically from man.conf.in by the</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># configure script.</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">#</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment"># man.conf from man-1.6d</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">(</span>中间省略<span class="token punctuation">)</span><span class="token punctuation">..</span><span class="token punctuation">..</span></pre></td></tr><tr><td data-num="8"></td><td><pre>--More--<span class="token punctuation">(</span><span class="token number">28</span>%<span class="token punctuation">)</span>  <span class="token operator">&lt;=</span><span class="token operator">=</span> 重点在这一行喔！你的光标也会在这里等待你的命令</pre></td></tr></table></figure><p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>
<ul>
<li>空白键 (space)：代表向下翻一页；</li>
<li>Enter     ：代表向下翻『一行』；</li>
<li>/ 字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>
<li>:f      ：立刻显示出档名以及目前显示的行数；</li>
<li>q      ：代表立刻离开 more ，不再显示该文件内容。</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<h3 id="less"><a class="markdownIt-Anchor" href="#less">#</a> less</h3>
<p>一页一页翻动，以下实例输出 /etc/man.config 文件的内容：</p>
<pre><code>[root@www ~]# less /etc/man.config
#
# Generated automatically from man.conf.in by the
# configure script.
#
# man.conf from man-1.6d
....(中间省略)....
:   &lt;== 这里可以等待你输入命令！
</code></pre>
<p>less 运行时可以输入的命令有：</p>
<ul>
<li>空白键  ：向下翻动一页；</li>
<li>[pagedown]：向下翻动一页；</li>
<li>[pageup] ：向上翻动一页；</li>
<li>/ 字串   ：向下搜寻『字串』的功能；</li>
<li>? 字串   ：向上搜寻『字串』的功能；</li>
<li>n     ：重复前一个搜寻 (与 / 或？有关！)</li>
<li>N     ：反向的重复前一个搜寻 (与 / 或？有关！)</li>
<li>q     ：离开 less 这个程序；</li>
</ul>
<h3 id="head"><a class="markdownIt-Anchor" href="#head">#</a> head</h3>
<p>取出文件前面几行</p>
<p>语法：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">head</span> <span class="token punctuation">[</span>-n number<span class="token punctuation">]</span> 文件</pre></td></tr></table></figure><p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
</ul>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># head /etc/man.config</span></pre></td></tr></table></figure><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># head -n 20 /etc/man.config</span></pre></td></tr></table></figure><h3 id="tail"><a class="markdownIt-Anchor" href="#tail">#</a> tail</h3>
<p>取出文件后面几行</p>
<p>语法：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">tail</span> <span class="token punctuation">[</span>-n number<span class="token punctuation">]</span> 文件</pre></td></tr></table></figure><p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
<li>-f ：表示持续侦测后面所接的档名，要等到按下 [ctrl]-c 才会结束 tail 的侦测</li>
</ul>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># tail /etc/man.config</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment"># tail -n 20 /etc/man.config</span></pre></td></tr></table></figure><h1 id="linux-链接概念"><a class="markdownIt-Anchor" href="#linux-链接概念">#</a> Linux 链接概念</h1>
<p>Linux 链接分两种，一种被称为<strong>硬链接（Hard Link）</strong>，另一种被称为<strong>符号链接（Symbolic Link）</strong>。默认情况下，<strong>ln</strong> 命令产生硬链接。</p>
<h2 id="硬连接"><a class="markdownIt-Anchor" href="#硬连接">#</a> 硬连接</h2>
<p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号 (Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p>
<p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止 “误删” 的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>
<h2 id="软连接"><a class="markdownIt-Anchor" href="#软连接">#</a> 软连接</h2>
<p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是 “主从” 关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p>
<p><strong>通过实验加深理解</strong></p>
<pre><code>[oracle@Linux]$ touch f1          #创建一个测试文件f1
[oracle@Linux]$ ln f1 f2          #创建f1的一个硬连接文件f2
[oracle@Linux]$ ln -s f1 f3       #创建f1的一个符号连接文件f3
[oracle@Linux]$ ls -li            # -i参数显示文件的inode节点信息
total 0
9797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f1
9797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f2
9797649 lrwxrwxrwx  1 oracle oinstall 2 Apr 21 08:11 f3 -&gt; f1
</code></pre>
<p>从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 9797648，然而符号连接文件的 inode 节点不同。</p>
<pre><code>[oracle@Linux]$ echo &quot;I am f1 file&quot; &gt;&gt;f1
[oracle@Linux]$ cat f1
I am f1 file
[oracle@Linux]$ cat f2
I am f1 file
[oracle@Linux]$ cat f3
I am f1 file
[oracle@Linux]$ rm -f f1
[oracle@Linux]$ cat f2
I am f1 file
[oracle@Linux]$ cat f3
cat: f3: No such file or directory
</code></pre>
<p>通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f3 文件无效</p>
<p><strong>总结</strong></p>
<p>依此您可以做一些相关的测试，可以得到以下全部结论：</p>
<ul>
<li>1). 删除符号连接 f3, 对 f1,f2 无影响；</li>
<li>2). 删除硬连接 f2，对 f1,f3 也无影响；</li>
<li>3). 删除原文件 f1，对硬连接 f2 没有影响，导致符号连接 f3 失效；</li>
<li>4). 同时删除原文件 f1, 硬连接 f2，整个文件会真正的被删除。</li>
</ul>
<h1 id="linux-用户和用户组管理"><a class="markdownIt-Anchor" href="#linux-用户和用户组管理">#</a> Linux 用户和用户组管理</h1>
<p>Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>
<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p>
<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>
<ul>
<li>用户账号的添加、删除与修改。</li>
<li>用户口令的管理。</li>
<li>用户组的管理。</li>
</ul>
<h1 id="linux-压缩命令"><a class="markdownIt-Anchor" href="#linux-压缩命令">#</a> Linux 压缩命令</h1>
<h1 id="linux-查找命令"><a class="markdownIt-Anchor" href="#linux-查找命令">#</a> Linux 查找命令</h1>
<h1 id="linux-磁盘管理"><a class="markdownIt-Anchor" href="#linux-磁盘管理">#</a> Linux 磁盘管理</h1>
<p>Linux 磁盘管理好坏直接关系到整个系统的性能问题。</p>
<p>Linux 磁盘管理常用三个命令为  <code>df</code> 、 <code>du</code>  和  <code>fdisk</code> 。</p>
<ul>
<li><code>df</code> （英文全称：disk free）：列出文件系统的整体磁盘使用量</li>
<li><code>du</code> （英文全称：disk used）：检查磁盘空间使用量</li>
<li><code>fdisk</code> ：用于磁盘分区</li>
</ul>
<h2 id="df"><a class="markdownIt-Anchor" href="#df">#</a> df</h2>
<p>df 命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<p>语法：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">df</span> <span class="token punctuation">[</span>-ahikHTm<span class="token punctuation">]</span> <span class="token punctuation">[</span>目录或文件名<span class="token punctuation">]</span></pre></td></tr></table></figure><p>选项与参数：</p>
<ul>
<li><code>-a</code>  ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；</li>
<li><code>-k</code>  ：以 KBytes 的容量显示各文件系统；</li>
<li><code>-m</code>  ：以 MBytes 的容量显示各文件系统；</li>
<li><code>-h</code>  ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li>
<li><code>-H</code>  ：以 M=1000K 取代 M=1024K 的进位方式；</li>
<li><code>-T</code>  ：显示文件系统类型，连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li>
<li><code>-i</code>  ：不用硬盘容量，而以 inode 的数量来显示</li>
</ul>
<h2 id="du"><a class="markdownIt-Anchor" href="#du">#</a> du</h2>
<p>Linux du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看，还是和 df 命令有一些区别的，这里介绍 Linux du 命令。</p>
<p>语法：</p>
<pre><code>du [-ahskm] 文件或目录名称
</code></pre>
<p>选项与参数：</p>
<ul>
<li><code>-a</code>  ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li>
<li><code>-h</code>  ：以人们较易读的容量格式 (G/M) 显示；</li>
<li><code>-s</code>  ：列出总量而已，而不列出每个各别的目录占用容量；</li>
<li><code>-S</code>  ：不包括子目录下的总计，与 -s 有点差别。</li>
<li><code>-k</code>  ：以 KBytes 列出容量显示；</li>
<li><code>-m</code>  ：以 MBytes 列出容量显示；</li>
</ul>
<h2 id="fdisk"><a class="markdownIt-Anchor" href="#fdisk">#</a> fdisk</h2>
<p>fdisk 是 Linux 的磁盘分区表操作工具。</p>
<p>语法：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">fdisk</span> <span class="token punctuation">[</span>-l<span class="token punctuation">]</span> 装置名称</pre></td></tr></table></figure><p>选项与参数：</p>
<ul>
<li><code>-l</code>  ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。</li>
</ul>
<h1 id="linux-vivim"><a class="markdownIt-Anchor" href="#linux-vivim">#</a> Linux vi/vim</h1>
<p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p>
<p>但是目前我们使用比较多的是 vim 编辑器。</p>
<p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p>
<h2 id="什么是-vim"><a class="markdownIt-Anchor" href="#什么是-vim">#</a> 什么是 vim？</h2>
<p>Vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>
<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p>
<p>连 vim 的官方网站 (<span class="exturl" data-url="aHR0cHM6Ly93d3cudmltLm9yZy8=">https://www.vim.org/</span>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p>
<p><img data-src="vi-vim-cheat-sheet-sch.gif" alt="img"></p>
<h2 id="vivim-的使用"><a class="markdownIt-Anchor" href="#vivim-的使用">#</a> vi/vim 的使用</h2>
<p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）<strong>和</strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是：</p>
<h3 id="命令模式"><a class="markdownIt-Anchor" href="#命令模式">#</a> 命令模式：</h3>
<p>用户刚刚启动 vi/vim，便进入了命令模式。</p>
<p>此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符。比如我们此时按下 i，并不会输入一个字符，i 被当作了一个命令。</p>
<p>以下是常用的几个命令：</p>
<ul>
<li><code>i</code>  切换到输入模式，以输入字符。</li>
<li><code>x</code>  删除当前光标所在处的字符。</li>
<li><code>:</code>  切换到底线命令模式，以在最底一行输入命令。</li>
</ul>
<p>若想要编辑文本：启动 Vim，进入了命令模式，按下 i，切换到输入模式。</p>
<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>
<h3 id="输入模式"><a class="markdownIt-Anchor" href="#输入模式">#</a> 输入模式</h3>
<p>在命令模式下按下 i 就进入了输入模式。</p>
<p>在输入模式中，可以使用以下按键：</p>
<ul>
<li><strong>字符按键以及 Shift 组合</strong>，输入字符</li>
<li><strong>ENTER</strong>，回车键，换行</li>
<li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li>
<li><strong>DEL</strong>，删除键，删除光标后一个字符</li>
<li><strong>方向键</strong>，在文本中移动光标</li>
<li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首 / 行尾</li>
<li><strong>Page Up</strong>/<strong>Page Down</strong>，上 / 下翻页</li>
<li><strong>Insert</strong>，切换光标为输入 / 替换模式，光标将变成竖线 / 下划线</li>
<li><strong>ESC</strong>，退出输入模式，切换到命令模式</li>
</ul>
<h3 id="底线命令模式"><a class="markdownIt-Anchor" href="#底线命令模式">#</a> 底线命令模式</h3>
<p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li><code>q</code>  退出程序</li>
<li><code>w</code>  保存文件</li>
</ul>
<p>按 ESC 键可随时退出底线命令模式。</p>
<p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>
<p><img data-src="vim-vi-workmodel.png" alt="img"></p>
<h2 id="vivim-使用实例"><a class="markdownIt-Anchor" href="#vivim-使用实例">#</a> vi/vim 使用实例</h2>
<p><strong>使用 vi/vim 进入一般模式</strong></p>
<p>如果你想要使用 vi 来建立一个名为 runoob.txt 的文件时，你可以这样做：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ <span class="token function">vim</span> runoob.txt</pre></td></tr></table></figure><p>直接输入 <strong>vi 文件名</strong> 就能够进入 vi 的一般模式了。请注意，记得 <strong>vi 后面一定要加文件名，不管该文件存在与否！</strong></p>
<p><img data-src="078207F0-B204-4464-AAEF-982F45EDDAE9.jpg" alt="img"></p>
<p><strong>按下 i 进入输入模式 (也称为编辑模式)，开始编辑文字</strong></p>
<p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p>
<p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p>
<p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p>
<p><img data-src="1C928383-471E-4AF1-A61E-9E2CCBD5A913.jpg" alt="img"></p>
<p><strong>按下 ESC 按钮回到一般模式</strong></p>
<p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p>
<p><strong>在一般模式中按下 :wq 储存后离开 vi</strong></p>
<p>OK，我们要存档了，存盘并离开的指令很简单，输入  <code>:wq</code>  即可保存离开！</p>
<p><img data-src="B2FB5146-327C-4019-AC96-DD7A8EE7460C.jpg" alt="img"></p>
<p>OK! 这样我们就成功创建了一个 runoob.txt 的文件。</p>
<h1 id="gcc"><a class="markdownIt-Anchor" href="#gcc">#</a> GCC</h1>
<p><code>GCC</code>  是 Linux 下的编译工具集，是 GNU Compiler Collection 的缩写，包含 gcc、g++ 等编译器。这个工具集不仅包含编译器，还包含其他工具集，例如 ar、nm 等。</p>
<p>GCC 工具集不仅能编译 C/C++ 语言，其他例如 Objective-C、Pascal、Fortran、Java、Ada 等语言均能进行编译。<strong>GCC 在可以根据不同的硬件平台进行编译，即能进行交叉编译</strong>，在 A 平台上编译 B 平台的程序，支持常见的 X86、ARM、PowerPC、mips 等，以及 Linux、Windows 等软件平台。</p>
<h2 id="安装gcc"><a class="markdownIt-Anchor" href="#安装gcc">#</a> 安装 GCC</h2>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 安装软件必须要有管理员权限</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># ubuntu</span></pre></td></tr><tr><td data-num="3"></td><td><pre>$ <span class="token function">sudo</span> <span class="token function">apt</span> update   		<span class="token comment"># 更新本地的软件下载列表，得到最新的下载地址</span></pre></td></tr><tr><td data-num="4"></td><td><pre>$ <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> gcc g++	<span class="token comment"># 通过下载列表中提供的地址下载安装包，并安装</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment"># centos</span></pre></td></tr><tr><td data-num="7"></td><td><pre>$ <span class="token function">sudo</span> yum update   		<span class="token comment"># 更新本地的软件下载列表，得到最新的下载地址</span></pre></td></tr><tr><td data-num="8"></td><td><pre>$ <span class="token function">sudo</span> yum <span class="token function">install</span> gcc g++	<span class="token comment"># 通过下载列表中提供的地址下载安装包，并安装</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment"># 查看 gcc 版本</span></pre></td></tr><tr><td data-num="11"></td><td><pre>$ gcc <span class="token parameter variable">-v</span></pre></td></tr><tr><td data-num="12"></td><td><pre>$ gcc <span class="token parameter variable">--version</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment"># 查看 g++ 版本</span></pre></td></tr><tr><td data-num="15"></td><td><pre>$ g++ <span class="token parameter variable">-v</span></pre></td></tr><tr><td data-num="16"></td><td><pre>$ g++ <span class="token parameter variable">--version</span></pre></td></tr></table></figure><h2 id="gcc工作流程"><a class="markdownIt-Anchor" href="#gcc工作流程">#</a> gcc 工作流程</h2>
<p>GCC 编译器对程序的编译下图所示，分为 4 个阶段：预处理（预编译）、编译和优化、汇编和链接。GCC 的编译器可以将这 4 个步骤合并成一个。 先介绍一个每个步骤都分别做了写什么事儿:</p>
<ul>
<li>
<p>预处理：在这个阶段主要做了三件事：展开头文件 、宏替换 、去掉注释行</p>
<p>这个阶段需要 GCC 调用预处理器来完成，最终得到的还是源文件，文本格式</p>
</li>
<li>
<p>编译：这个阶段需要 GCC 调用编译器对文件进行编译，最终得到一个汇编文件</p>
</li>
<li>
<p>汇编：这个阶段需要 GCC 调用汇编器对文件进行汇编，最终得到一个二进制文件</p>
</li>
<li>
<p>链接：这个阶段需要 GCC 调用链接器对程序需要调用的库进行链接，最终得到一个可执行的二进制文件</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>文件名后缀</th>
<th>说明</th>
<th>gcc 参数<br/></th>
</tr>
</thead>
<tbody>
<tr>
<td>.c</td>
<td>源文件</td>
<td>无<br/></td>
</tr>
<tr>
<td>.i</td>
<td>预处理后的 C 文件</td>
<td>-E<br/></td>
</tr>
<tr>
<td>.s</td>
<td>编译之后得到的汇编语言的源文件</td>
<td>-S<br/></td>
</tr>
<tr>
<td>.o</td>
<td>汇编后得到的二进制文件</td>
<td>-c</td>
</tr>
</tbody>
</table>
<p>在 Linux 下使用 GCC 编译器编译单个文件十分简单，直接使用 gcc 命令后面加上要编译的 C 语言的源文件，GCC 会自动生成文件名为 a.out 的可执行文件（也可以通过参数 -o 指定生成的文件名），也就是通过一个简单的命令上边提到的 4 个步骤就全部执行完毕了。但是如果想要单步执行也是没问题的， 示例如下：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 源文件名 test.c</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"array[%d] = %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol>
<li>
<p>对源文件进行预处理，需要使用的 gcc 参数为 -E</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 1. 预处理，-o 指定生成的文件名</span></pre></td></tr><tr><td data-num="2"></td><td><pre>$ gcc <span class="token parameter variable">-E</span> test.c <span class="token parameter variable">-o</span> test.i</pre></td></tr></table></figure></li>
<li>
<p>编译预处理之后的文件，需要使用的 gcc 参数为 -S</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 2. 编译，得到汇编文件</span></pre></td></tr><tr><td data-num="2"></td><td><pre>$ gcc <span class="token parameter variable">-S</span> test.i <span class="token parameter variable">-o</span> test.s</pre></td></tr></table></figure></li>
<li>
<p>对得到的汇编文件进行汇编，需要使用的 gcc 参数为 -c</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 3. 汇编</span></pre></td></tr><tr><td data-num="2"></td><td><pre>$ gcc <span class="token parameter variable">-c</span> test.s <span class="token parameter variable">-o</span> test.o</pre></td></tr></table></figure></li>
<li>
<p>将得到的二进制文件和标准库进制链接，得到可执行的二进制文件，不需要任何参数</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 4. 链接</span></pre></td></tr><tr><td data-num="2"></td><td><pre>$ gcc test.o <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span></pre></td></tr></table></figure></li>
</ol>
<p>在使用 gcc 编译程序的时候可以通过参数控制内部自动执行几个步骤:</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l </span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 参数 -c 是进行文件的汇编，汇编之前的两步会自动执行</span></pre></td></tr><tr><td data-num="2"></td><td><pre>$ gcc test.c <span class="token parameter variable">-c</span> <span class="token parameter variable">-o</span> app.o</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 该命令是直接进行链接生成可执行程序，链接之前的三步会自动执行</span></pre></td></tr><tr><td data-num="5"></td><td><pre>$ gcc test.c <span class="token parameter variable">-o</span> app</pre></td></tr></table></figure><h2 id="gcc常用参数"><a class="markdownIt-Anchor" href="#gcc常用参数">#</a> gcc 常用参数</h2>
<p>下面的表格中列出了常用的一些  <code>gcc</code>  参数，这些<strong>参数在 gcc 命令中没有位置要求</strong>，只需要编译程序的时候将需要的参数指定出来即可。</p>
<table>
<thead>
<tr>
<th>gcc 编译选项</th>
<th>选项的意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-E</td>
<td>预处理指定的源文件，不进行编译</td>
</tr>
<tr>
<td>-S</td>
<td>编译指定的源文件，但是不进行汇编</td>
</tr>
<tr>
<td>-c</td>
<td>编译、汇编指定的源文件，但是不进行链接</td>
</tr>
<tr>
<td>-o [file1] [file2] / [file2] -o [file1]</td>
<td>将文件 file2 编译成文件 file1</td>
</tr>
<tr>
<td>-I directory</td>
<td>指定 include 包含文件的搜索目录</td>
</tr>
<tr>
<td>-g</td>
<td>在编译的时候，生成调试信息，该程序可以被调试器调试</td>
</tr>
<tr>
<td>-D</td>
<td>在程序编译的时候，指定一个宏</td>
</tr>
<tr>
<td>-w</td>
<td>不生成任何警告信息，不建议使用，有些时候警告就是错误</td>
</tr>
<tr>
<td>-Wall</td>
<td>生成所有警告信息</td>
</tr>
<tr>
<td>-On</td>
<td>n 的取值范围：0~3。编译器的优化选项的 4 个级别，-O0 表示没有优化，-O1 为缺省值，-O3 优化级别最高</td>
</tr>
<tr>
<td>-l</td>
<td>在程序编译的时候，指定使用的库</td>
</tr>
<tr>
<td>-L</td>
<td>指定编译的时候，搜索的库的路径。</td>
</tr>
<tr>
<td>-fPIC/fpic</td>
<td>生成与位置无关的代码</td>
</tr>
<tr>
<td>-shared</td>
<td>生成共享目标文件。通常用在建立共享库时</td>
</tr>
<tr>
<td>-std</td>
<td>指定 C 方言，如:-std=c99，gcc 默认的方言是 GNU C</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>指定生成的文件名 (-o)</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 参数 -o 的用法，原材料 test.c 最终生成的文件名为 app</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># test.c 写在 -o 之前</span></pre></td></tr><tr><td data-num="3"></td><td><pre>$ gcc test.c <span class="token parameter variable">-o</span> app</pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment"># test.c 写在 -o 之后</span></pre></td></tr><tr><td data-num="6"></td><td><pre>$ gcc <span class="token parameter variable">-o</span> app test.c</pre></td></tr></table></figure></li>
<li>
<p>搜索头文件 (-I)</p>
<p>如果在程序中包含了一些头文件，但是包含的一些头文件在程序预处理的时候因为找不到无法被展开，导致程序编译失败，这时候我们可以在 gcc 命令中添加 -I 参数重新指定要引用的头文件路径，保证编译顺利完成。</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># -I, 指定头文件目录</span></pre></td></tr><tr><td data-num="2"></td><td><pre>$ tree</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token builtin class-name">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre>├── add.c</pre></td></tr><tr><td data-num="5"></td><td><pre>├── div.c</pre></td></tr><tr><td data-num="6"></td><td><pre>├── include</pre></td></tr><tr><td data-num="7"></td><td><pre>│   └── head.h</pre></td></tr><tr><td data-num="8"></td><td><pre>├── main.c</pre></td></tr><tr><td data-num="9"></td><td><pre>├── mult.c</pre></td></tr><tr><td data-num="10"></td><td><pre>└── sub.c</pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment"># 编译当前目录中的所有源文件，得到可执行程序</span></pre></td></tr><tr><td data-num="13"></td><td><pre>$ gcc *.c <span class="token parameter variable">-o</span> calc</pre></td></tr><tr><td data-num="14"></td><td><pre>main.c:2:18: fatal error: head.h: No such <span class="token function">file</span> or directory</pre></td></tr><tr><td data-num="15"></td><td><pre>compilation terminated.</pre></td></tr><tr><td data-num="16"></td><td><pre>sub.c:2:18: fatal error: head.h: No such <span class="token function">file</span> or directory</pre></td></tr><tr><td data-num="17"></td><td><pre>compilation terminated.</pre></td></tr></table></figure><p>通过编译得到的错误信息可以知道，源文件中包含的头文件无法被找到。通过提供的目录结构可以得知头文件 head.h 在 include 目录中，因此可以在编译的时候重新指定头文件位置，具体操作如下：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 可以在编译的时候重新指定头文件位置 -I 头文件目录</span></pre></td></tr><tr><td data-num="2"></td><td><pre>$ gcc *.c <span class="token parameter variable">-o</span> calc <span class="token parameter variable">-I</span> ./include</pre></td></tr></table></figure></li>
<li>
<p>指定一个宏 (-D)</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 在编译命令中定义这个 DEBUG 宏，</span></pre></td></tr><tr><td data-num="2"></td><td><pre>$ gcc test.c <span class="token parameter variable">-o</span> app <span class="token parameter variable">-D</span> DEBUG</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 执行生成的程序， 可以看到程序第 9 行的输出</span></pre></td></tr><tr><td data-num="5"></td><td><pre>$ ./app </pre></td></tr><tr><td data-num="6"></td><td><pre>我是一个程序猿, 我不会爬树<span class="token punctuation">..</span>.</pre></td></tr><tr><td data-num="7"></td><td><pre>hello, GCC<span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span></pre></td></tr><tr><td data-num="8"></td><td><pre>hello, GCC<span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span></pre></td></tr><tr><td data-num="9"></td><td><pre>hello, GCC<span class="token operator">!</span><span class="token operator">!</span><span class="token operator">!</span></pre></td></tr></table></figure><blockquote>
<p>-D 参数的应用场景:<br>
 在发布程序的时候，一般都会要求将程序中所有的 log 输出去掉，如果不去掉会影响程序的执行效率，很显然删除这些打印 log 的源代码是一件很麻烦的事情，解决方案是这样的：</p>
<p>将所有的打印 log 的代码都写到一个宏判定中，可以模仿上边的例子<br>
在编译程序的时候指定 -D 就会有 log 输出<br>
在编译程序的时候不指定 -D, log 就不会输出</p>
</blockquote>
</li>
</ul>
<h2 id="多文件编译"><a class="markdownIt-Anchor" href="#多文件编译">#</a> 多文件编译</h2>
<p>GCC 可以自动编译链接多个文件，不管是目标文件还是源文件，都可以使用同一个命令编译到一个可执行文件中。</p>
<ul>
<li>
<p>头文件</p>
<figure class="highlight c"><figcaption data-lang="c"><span>c</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_STRING_H_</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_STRING_H_</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">strLength</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// _STRING_H_</span></span></pre></td></tr></table></figure></li>
<li>
<p>源文件 string.c</p>
<figure class="highlight c"><figcaption data-lang="c"><span>c</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">strLength</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>string<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>string<span class="token operator">++</span> <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> 	<span class="token comment">// 当 * string 的值为 '\0' 时，停止计算</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        len<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token keyword">return</span> len<span class="token punctuation">;</span> 	<span class="token comment">// 返回字符串长度</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li>
<li>
<p>源文件 main.c</p>
<figure class="highlight c"><figcaption data-lang="c"><span>c</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">char</span> <span class="token operator">*</span>src <span class="token operator">=</span> <span class="token string">"Hello, I'am Monkey·D·Luffy!!!"</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"string length is: %d\n"</span><span class="token punctuation">,</span> <span class="token function">strLength</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>因为头文件是包含在源文件中的，因此在使用 gcc 编译程序的时候不需要指定头文件的名字（在头文件无法被找到的时候需要使用参数 -I 指定其具体路径而不是名字）。我们可以通过一个 gcc 命令将多个源文件编译并生成可执行程序，也可以分多步完成这个操作。</p>
</blockquote>
<p>直接链接生成可执行程序</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 直接生成可执行程序 test</span></pre></td></tr><tr><td data-num="2"></td><td><pre>$ gcc <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span> string.c main.c</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 运行可执行程序</span></pre></td></tr><tr><td data-num="5"></td><td><pre>$ ./test</pre></td></tr></table></figure><p>先将源文件编成目标文件，然后进行链接得到可执行程序</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 汇编生成二进制目标文件，指定了 -c 参数之后，源文件会自动生成 string.o 和 main.o</span></pre></td></tr><tr><td data-num="2"></td><td><pre>$ gcc –c string.c main.c</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 链接目标文件，生成可执行程序 test</span></pre></td></tr><tr><td data-num="5"></td><td><pre>$ gcc –o <span class="token builtin class-name">test</span> string.o main.o</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment"># 运行可执行程序</span></pre></td></tr><tr><td data-num="8"></td><td><pre>$ ./test</pre></td></tr></table></figure><h2 id="gcc和g"><a class="markdownIt-Anchor" href="#gcc和g">#</a> gcc 和 g++</h2>
<ol>
<li>在代码编译阶段（第二个阶段）:
<ul>
<li>后缀为  <code>.c</code>  的，gcc 把它当作是 C 程序，而 g++ 当作是 C++ 程序</li>
<li>后缀为 <code>.cpp</code>  的，两者都会认为是 C++ 程序，C++ 的语法规则更加严谨一些</li>
<li>g++ 会调用 gcc，对于 C++ 代码，两者是等价的，也就是说 gcc 和 g++ 都可以编译 C/C++ 代码</li>
</ul>
</li>
<li>在链接阶段（最后一个阶段）:
<ul>
<li>gcc 和 g++ 都可以自动链接到标准 C 库</li>
<li>g++ 可以自动链接到标准 C++ 库，gcc 如果要链接到标准 C++ 库需要加参数  <code>-lstdc++</code></li>
</ul>
</li>
<li>关于  <code>__cplusplus</code>  宏的定义
<ul>
<li>g++ 会自动定义 <code>__cplusplus</code>  宏，但是这个不影响它去编译 C 程序</li>
<li>gcc 需要根据文件后缀判断是否需要定义  <code>__cplusplus</code>  宏 （规则参考第一条）</li>
</ul>
</li>
</ol>
<blockquote>
<p>综上所述：</p>
<ul>
<li>不管是 gcc 还是 g++ 都可以编译 C 程序，编译程序的规则和参数都相同</li>
<li>g++ 可以直接编译 C++ 程序， gcc 编译 C++ 程序需要添加额外参数 -lstdc++</li>
<li>不管是 gcc 还是 g++ 都可以定义 __cplusplus 宏</li>
</ul>
</blockquote>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 编译 c 程序</span></pre></td></tr><tr><td data-num="2"></td><td><pre>$ gcc test.c <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span>	<span class="token comment"># 使用 gcc</span></pre></td></tr><tr><td data-num="3"></td><td><pre>$ g++ test.c <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span>	<span class="token comment"># 使用 g++</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment"># 编译 c++ 程序</span></pre></td></tr><tr><td data-num="6"></td><td><pre>$ g++ test.cpp <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span>              <span class="token comment"># 使用 g++</span></pre></td></tr><tr><td data-num="7"></td><td><pre>$ gcc test.cpp -lstdc++ <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span>     <span class="token comment"># 使用 gcc</span></pre></td></tr></table></figure><h1 id="gdb调试"><a class="markdownIt-Anchor" href="#gdb调试">#</a> GDB 调试</h1>
<p>gdb 是由 GNU 软件系统社区提供的调试器，同 gcc 配套组成了一套完整的开发环境，可移植性很好，支持非常多的体系结构并被移植到各种系统中（包括各种类 Unix 系统与 Windows 系统里的 MinGW 和 Cygwin ）。此外，除了 C 语言之外，gcc/gdb 还支持包括 C++、Objective-C、Ada 和 Pascal 等各种语言后端的编译和调试。 gcc/gdb 是 Linux 和许多类 Unix 系统中的标准开发环境，Linux 内核也是专门针对 gcc 进行编码的。</p>
<p><strong>GDB 是一套字符界面的程序集，可以使用命令 gdb 加载要调试的程序。</strong> 一些常用的 GDB 调试命令：</p>
<h2 id="调试准备"><a class="markdownIt-Anchor" href="#调试准备">#</a> 调试准备</h2>
<p>项目程序如果是为了进行调试而编译时， 必须要打开调试选项  <code>-g</code>  另外还有一些可选项，比如：在尽量不影响程序行为的情况下关掉编译器的优化选项  <code>-O0</code> ， <code>-Wall</code>  选项打开所有 warning，也可以发现许多问题，避免一些不必要的 bug。</p>
<p><code>-g</code>  选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 gdb 能找到源文件。</p>
<p>习惯上如果是 c 程序就使用 gcc 编译，如果是 c++ 程序就使用 g++ 编译，编译命令中添加上边提到的参数即可。</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># -g 将调试信息写入到可执行程序中</span></pre></td></tr><tr><td data-num="2"></td><td><pre>$ gcc <span class="token parameter variable">-g</span> args.c <span class="token parameter variable">-o</span> app</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 编译不添加 -g 参数</span></pre></td></tr><tr><td data-num="5"></td><td><pre>$ gcc args.c <span class="token parameter variable">-o</span> app1  </pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment"># 查看生成的两个可执行程序的大小</span></pre></td></tr><tr><td data-num="8"></td><td><pre>$ ll</pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>-rwxrwxr-x  <span class="token number">1</span> robin robin <span class="token number">9816</span> Apr <span class="token number">19</span> 09:25 app*	<span class="token comment"># 可以用于 gdb 调试</span></pre></td></tr><tr><td data-num="11"></td><td><pre>-rwxrwxr-x  <span class="token number">1</span> robin robin <span class="token number">8608</span> Apr <span class="token number">19</span> 09:25 app1*	<span class="token comment"># 不能用于 gdb 调试</span></pre></td></tr></table></figure><h2 id="启动和退出gdb"><a class="markdownIt-Anchor" href="#启动和退出gdb">#</a> 启动和退出 gdb</h2>
<h3 id="启动gdb"><a class="markdownIt-Anchor" href="#启动gdb">#</a> 启动 gdb</h3>
<p>gdb 是一个用于应用程序调试的进程，需要先将其打开，一定要注意 gdb 进程启动之后，需要的被调试的应用程序是没有执行的。打开 Linux 终端，切换到要调试的可执行程序所在路径，执行如下命令就可以启动 gdb 了。</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 在终端中执行如下命令</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># gdb 程序启动了，但是可执行程序并没有执行</span></pre></td></tr><tr><td data-num="3"></td><td><pre>$ gdb 可执行程序的名字</pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment"># 使用举例：</span></pre></td></tr><tr><td data-num="6"></td><td><pre>$ gdb app</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> 		<span class="token comment"># gdb 等待输入调试的相关命令</span></pre></td></tr></table></figure><h3 id="命令行传参"><a class="markdownIt-Anchor" href="#命令行传参">#</a> 命令行传参</h3>
<p>有些程序在启动的时候需要传递命令行参数，如果要调试这类程序，这些命令行参数必须要在应用程序启动之前通过调试程序的 gdb 进程传递进去。</p>
<figure class="highlight c"><figcaption data-lang="c"><span>c</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// args.c</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM</span> <span class="token expression"><span class="token number">10</span></span></span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">//argc, argv 是命令行参数</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 启动应用程序的时候</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"参数个数: %d\n"</span><span class="token punctuation">,</span> argc<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> NUM<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"参数 %d: %s\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol>
<li>
<p>编译出可执行程序</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>$ gcc args.c <span class="token parameter variable">-o</span> app <span class="token parameter variable">-g</span></pre></td></tr></table></figure></li>
<li>
<p>启动 gdb 进程，指定需要 gdb 调试的应用程序名称</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre>$ gdb app</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span></pre></td></tr></table></figure></li>
<li>
<p>在启动应用程序  <code>app</code>  之前设置命令行参数。</p>
<p>gdb 中设置参数的命令叫做  <code>set args ...</code> ，查看设置的命令行参数命令是  <code>show args</code> 。 语法格式如下：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 设置的时机：启动 gdb 之后，在应用程序启动之前</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token builtin class-name">set</span> args 参数1 参数2 <span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token punctuation">..</span>.</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 查看设置的命令行参数</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> show args</pre></td></tr></table></figure></li>
</ol>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l </span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 非 gdb 调试命令行传参</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># argc 参数总个数，argv [0] == ./app， argv [1] == "11"  argv [2] == "22"  ...  argv [5] == "55"</span></pre></td></tr><tr><td data-num="3"></td><td><pre>$ ./app <span class="token number">11</span> <span class="token number">22</span> <span class="token number">33</span> <span class="token number">44</span> <span class="token number">55</span>		<span class="token comment"># 这是数据传递给 main 函数</span></pre></td></tr><tr><td data-num="4"></td><td><pre> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment"># 使用 gdb 调试</span></pre></td></tr><tr><td data-num="6"></td><td><pre>$ gdb app</pre></td></tr><tr><td data-num="7"></td><td><pre>GNU gdb <span class="token punctuation">(</span>Ubuntu <span class="token number">7.11</span>.1-0ubuntu1~16.5<span class="token punctuation">)</span> <span class="token number">7.11</span>.1</pre></td></tr><tr><td data-num="8"></td><td><pre>Copyright <span class="token punctuation">(</span>C<span class="token punctuation">)</span> <span class="token number">2016</span> Free Software Foundation, Inc.</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment"># 通过 gdb 给应用程序设置命令行参数</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token builtin class-name">set</span> args <span class="token number">11</span> <span class="token number">22</span> <span class="token number">33</span> <span class="token number">44</span> <span class="token number">55</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment"># 查看设置的命令行参数</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> show args</pre></td></tr><tr><td data-num="13"></td><td><pre>Argument list to give program being debugged when it is started is <span class="token string">"11 22 33 44 55"</span><span class="token builtin class-name">.</span></pre></td></tr></table></figure><h3 id="gdb中启动程序"><a class="markdownIt-Anchor" href="#gdb中启动程序">#</a> gdb 中启动程序</h3>
<p>在 gdb 中启动要调试的应用程序有两种方式，一种是使用 run 命令，另一种是使用 start 命令启动。在整个 gdb 调试过程中，启动应用程序的命令只能使用一次。</p>
<ul>
<li><code>run</code> : 可以缩写为  <code>r</code> , 如果程序中设置了断点会停在第一个断点的位置，如果没有设置断点，程序就执行完了</li>
<li><code>start</code> : 启动程序，最终会阻塞在 main 函数的第一行，等待输入后续其它 gdb 指令</li>
<li><code>continue</code>  ：如果想让程序 start 之后继续运行，或者在断点处继续运行，可以使用  <code>continue</code>  命令，可以简写为  <code>c</code></li>
</ul>
<h3 id="退出gdb"><a class="markdownIt-Anchor" href="#退出gdb">#</a> 退出 gdb</h3>
<p>退出 gdb 调试，就是终止 gdb 进程，需要使用  <code>quit</code>  命令，可以缩写为  <code>q</code></p>
<h2 id="查看代码"><a class="markdownIt-Anchor" href="#查看代码">#</a> 查看代码</h2>
<p>因为 gdb 调试没有 IDE 那样的完善的可视化窗口界面，给调试的程序打断点又是调试之前必须做的一项工作。因此 gdb 提供了查看代码的命令，这样就可以轻松定位要调试的代码行的位置了。</p>
<p>查看代码的命令叫做  <code>list</code>  可以缩写为  <code>l</code> , 通过这个命令我们可以查看项目中任意一个文件中的内容，并且还可以通过文件行号，函数名等方式查看。</p>
<h3 id="当前文件"><a class="markdownIt-Anchor" href="#当前文件">#</a> 当前文件</h3>
<p>一个项目中一般是有很多源文件的，默认情况下通过  <code>list</code>  查看到代码信息位于程序入口函数  <code>main</code>  对应的的那个文件中。因此如果不进行文件切换  <code>main</code>  函数所在的文件就是当前文件，如果进行了文件切换，切换到哪个文件哪个文件就是当前文件。查看文件内容的方式如下：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 使用 list 和使用 l 都可以</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># 从第一行开始显示</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> list </pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment"># 列值这行号对应的上下文代码，默认情况下只显示 10 行内容</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> list 行号</pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment"># 显示这个函数的上下文内容，默认显示 10 行</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> list 函数名</pre></td></tr></table></figure><p>通过 list 去查看文件代码，默认只显示 10 行，如果还想继续查看后边的内容，可以继续执行 list 命令，也可以直接回车（再次执行上一次执行的那个 gdb 命令）</p>
<h3 id="切换文件"><a class="markdownIt-Anchor" href="#切换文件">#</a> 切换文件</h3>
<p>在查看文件内容的时候，很多情况下需要进行文件切换，我们只需要在 list 命令后边将要查看的文件名指定出来就可以了，切换命令执行完毕之后，这个文件就变成了当前文件。文件切换方式如下：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 切换到指定的文件，并列出这行号对应的上下文代码，默认情况下只显示 10 行内容</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> l 文件名:行号</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 切换到指定的文件，并显示这个函数的上下文内容，默认显示 10 行</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> l 文件名:函数名</pre></td></tr></table></figure><h3 id="设置显示行数"><a class="markdownIt-Anchor" href="#设置显示行数">#</a> 设置显示行数</h3>
<p>默认通过 list 只能一次查看 10 行代码，如果想显示更多，可以通过 set listsize 设置，同样如果想查看当前显示的行数可以通过 show listsize 查看，这里的 listsize 可以简写为 list。具体语法格式如下:</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 以下两个命令中的 listsize 都可以写成 list</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token builtin class-name">set</span> listsize 行数</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 查看当前 list 一次显示的行数</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> show listsize</pre></td></tr></table></figure><h2 id="断点操作"><a class="markdownIt-Anchor" href="#断点操作">#</a> 断点操作</h2>
<p>想要通过 gdb 调试某一行或者得到某个变量在运行状态下的实际值，就需要在在这一行设置断点，程序指定到断点的位置就会阻塞，我们就可以通过 gdb 的调试命令得到我们想要的信息了。</p>
<p>设置断点的命令叫做  <code>break</code>  可以缩写为  <code>b</code> 。</p>
<h3 id="设置断点"><a class="markdownIt-Anchor" href="#设置断点">#</a> 设置断点</h3>
<p>断点的设置有两种方式一种是<strong>常规断点</strong>，程序只要运行到这个位置就会被阻塞，还有一种叫<strong>条件断点</strong>，只有指定的条件被满足了程序才会在断点处阻塞。</p>
<p>调试程序的断点可以设置到某个具体的行，也可以设置到某个函数上，具体的设置方式如下：</p>
<ul>
<li>
<p>设置普通断点到当前文件</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 在当前文件的某一行上设置断点</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># break == b</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> b 行号</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> b 函数名		<span class="token comment"># 停止在函数的第一行</span></pre></td></tr></table></figure></li>
<li>
<p>设置普通断点到某个非当前文件上</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 在非当前文件的某一行上设置断点</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> b 文件名:行号</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> b 文件名:函数名		<span class="token comment"># 停止在函数的第一行</span></pre></td></tr></table></figure></li>
<li>
<p>设置条件断点</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 必须要满足某个条件，程序才会停在这个断点的位置上</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># 通常情况下，在循环中条件断点用的比较多</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> b 行数 <span class="token keyword">if</span> 变量名<span class="token operator">==</span>某个值</pre></td></tr></table></figure></li>
</ul>
<h3 id="查看断点"><a class="markdownIt-Anchor" href="#查看断点">#</a> 查看断点</h3>
<p>断点设置完毕之后，可以通过  <code>info break</code>  命令查看设置的断点信息，其中  <code>info</code>  可以缩写为  <code>i</code></p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># info == i</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># 查看设置的断点信息</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> i b   <span class="token comment">#info break</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment"># 举例</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> i b</pre></td></tr><tr><td data-num="7"></td><td><pre>Num     Type           Disp Enb Address            What</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token number">1</span>       breakpoint     keep y   0x0000000000400cb5 <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:12</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token number">2</span>       breakpoint     keep y   0x0000000000400cbd <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:13</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token number">3</span>       breakpoint     keep y   0x0000000000400cec <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:18</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token number">4</span>       breakpoint     keep y   0x00000000004009a5 <span class="token keyword">in</span> insertionSort<span class="token punctuation">(</span>int*, int<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="12"></td><td><pre>                                                   at insert.cpp:8</pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token number">5</span>       breakpoint     keep y   0x0000000000400cdd <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:16</pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token number">6</span>       breakpoint     keep y   0x00000000004009e5 <span class="token keyword">in</span> insertionSort<span class="token punctuation">(</span>int*, int<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="15"></td><td><pre>                                                   at insert.cpp:16</pre></td></tr></table></figure><p>在显示的断点信息中有一些属性需要在其他操作中被使用，下面介绍一下:</p>
<ul>
<li><code>Num</code> : 断点的编号，删除断点或者设置断点状态的时候都需要使用</li>
<li><code>Enb</code> : 当前断点的状态，y 表示断点可用，n 表示断点不可用</li>
<li><code>What</code> : 描述断点被设置在了哪个文件的哪一行或者哪个函数上</li>
</ul>
<h3 id="删除断点"><a class="markdownIt-Anchor" href="#删除断点">#</a> 删除断点</h3>
<p>如果确定设置的某个断点不再被使用了，可用将其删除，删除命令是  <code>delete</code>  断点编号，这个  <code>delete</code>  可以简写为  <code>del</code>  也可以再简写为 <code>d</code> 。</p>
<p>删除断点的方式有两种: <strong>删除 (一个或者多个) 指定断点</strong>或者<strong>删除一个连续的断点区间</strong>，具体操作如下：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># delete == del == d</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># 需要 info b 查看断点的信息，第一列就是编号</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> d 断点的编号1 <span class="token punctuation">[</span>断点编号2 <span class="token punctuation">..</span>.<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 举例: </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> d <span class="token number">1</span>          <span class="token comment"># 删除第 1 个断点</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> d <span class="token number">2</span> <span class="token number">4</span> <span class="token number">6</span>      <span class="token comment"># 删除第 2,4,6 个断点</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment"># 删除一个范围，断点编号 num1 - numN 是一个连续区间</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> d num1-numN</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment"># 举例，删除第 1 到第 5 个断点</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> d <span class="token number">1</span>-5</pre></td></tr></table></figure><h3 id="设置断点状态"><a class="markdownIt-Anchor" href="#设置断点状态">#</a> 设置断点状态</h3>
<p>如果某个断点只是临时不需要了，我们可以将其设置为不可用状态，设置命令为  <code>disable</code>  断点编号，当需要的时候再将其设置回可用状态，设置命令为  <code>enable</code>  断点编号。</p>
<ul>
<li>
<p>设置断点无效</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 让断点失效之后，gdb 调试过程中程序是不会停在这个位置的</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># disable == dis</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 设置某一个或者某几个断点无效</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> dis 断点1的编号 <span class="token punctuation">[</span>断点2的编号 <span class="token punctuation">..</span>.<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment"># 设置某个区间断点无效</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> dis 断点1编号-断点n编号</pre></td></tr></table></figure><p>演示设置断点为无效状态:</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 查看断点信息</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> i b</pre></td></tr><tr><td data-num="3"></td><td><pre>Num     Type           Disp Enb Address            What</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">2</span>       breakpoint     keep y   0x0000000000400cce <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:14</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">4</span>       breakpoint     keep y   0x0000000000400cdd <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:16</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token number">5</span>       breakpoint     keep y   0x0000000000400d46 <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:23</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token number">6</span>       breakpoint     keep y   0x0000000000400d4e <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:25</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token number">7</span>       breakpoint     keep y   0x0000000000400d6e <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:28</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token number">8</span>       breakpoint     keep y   0x0000000000400d7d <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:30</pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment"># 设置第 2, 第 4 个断点无效</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> dis <span class="token number">2</span> <span class="token number">4</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment"># 查看断点信息</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> i b</pre></td></tr><tr><td data-num="16"></td><td><pre>Num     Type           Disp Enb Address            What</pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token number">2</span>       breakpoint     keep n   0x0000000000400cce <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:14</pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token number">4</span>       breakpoint     keep n   0x0000000000400cdd <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:16</pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token number">5</span>       breakpoint     keep y   0x0000000000400d46 <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:23</pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token number">6</span>       breakpoint     keep y   0x0000000000400d4e <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:25</pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token number">7</span>       breakpoint     keep y   0x0000000000400d6e <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:28</pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token number">8</span>       breakpoint     keep y   0x0000000000400d7d <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:30</pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment"># 设置 第 5,6,7,8 个 断点无效</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> dis <span class="token number">5</span>-8</pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token comment"># 查看断点信息</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> i b</pre></td></tr><tr><td data-num="29"></td><td><pre>Num     Type           Disp Enb Address            What</pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token number">2</span>       breakpoint     keep n   0x0000000000400cce <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:14</pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token number">4</span>       breakpoint     keep n   0x0000000000400cdd <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:16</pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token number">5</span>       breakpoint     keep n   0x0000000000400d46 <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:23</pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token number">6</span>       breakpoint     keep n   0x0000000000400d4e <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:25</pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token number">7</span>       breakpoint     keep n   0x0000000000400d6e <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:28</pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token number">8</span>       breakpoint     keep n   0x0000000000400d7d <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:30</pre></td></tr></table></figure></li>
<li>
<p>让无效的断点生效</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># enable == ena</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># 设置某一个或者某几个断点有效</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> ena 断点1的编号 <span class="token punctuation">[</span>断点2的编号 <span class="token punctuation">..</span>.<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment"># 设置某个区间断点有效</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> ena 断点1编号-断点n编号</pre></td></tr></table></figure><p>演示设置断点为有效状态:</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 查看断点信息</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> i b</pre></td></tr><tr><td data-num="3"></td><td><pre>Num     Type           Disp Enb Address            What</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">2</span>       breakpoint     keep n   0x0000000000400cce <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:14</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">4</span>       breakpoint     keep n   0x0000000000400cdd <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:16</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token number">5</span>       breakpoint     keep n   0x0000000000400d46 <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:23</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token number">6</span>       breakpoint     keep n   0x0000000000400d4e <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:25</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token number">7</span>       breakpoint     keep n   0x0000000000400d6e <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:28</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token number">8</span>       breakpoint     keep n   0x0000000000400d7d <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:30</pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment"># 设置第 2, 第 4 个断点有效</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> ena <span class="token number">2</span> <span class="token number">4</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment"># 查看断点信息</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> i b</pre></td></tr><tr><td data-num="16"></td><td><pre>Num     Type           Disp Enb Address            What</pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token number">2</span>       breakpoint     keep y   0x0000000000400cce <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:14</pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token number">4</span>       breakpoint     keep y   0x0000000000400cdd <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:16</pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token number">5</span>       breakpoint     keep n   0x0000000000400d46 <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:23</pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token number">6</span>       breakpoint     keep n   0x0000000000400d4e <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:25</pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token number">7</span>       breakpoint     keep n   0x0000000000400d6e <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:28</pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token number">8</span>       breakpoint     keep n   0x0000000000400d7d <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:30</pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment"># 设置第 5,6,7 个断点有效</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> ena <span class="token number">5</span>-7</pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token comment"># 查看断点信息</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> i b</pre></td></tr><tr><td data-num="29"></td><td><pre>Num     Type           Disp Enb Address            What</pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token number">2</span>       breakpoint     keep y   0x0000000000400cce <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:14</pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token number">4</span>       breakpoint     keep y   0x0000000000400cdd <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:16</pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token number">5</span>       breakpoint     keep y   0x0000000000400d46 <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:23</pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token number">6</span>       breakpoint     keep y   0x0000000000400d4e <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:25</pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token number">7</span>       breakpoint     keep y   0x0000000000400d6e <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:28</pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token number">8</span>       breakpoint     keep n   0x0000000000400d7d <span class="token keyword">in</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> at test.cpp:30</pre></td></tr></table></figure></li>
</ul>
<h2 id="调试命令"><a class="markdownIt-Anchor" href="#调试命令">#</a> 调试命令</h2>
<h3 id="继续运行-gdb"><a class="markdownIt-Anchor" href="#继续运行-gdb">#</a> 继续运行 gdb</h3>
<p>如果调试的程序被断点阻塞了又想让程序继续执行，这时候就可以使用  <code>continue</code>  命令。程序会继续运行，直到遇到下一个有效的断点。 <code>continue</code>  可以缩写为  <code>c</code> 。</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># continue == c</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token builtin class-name">continue</span></pre></td></tr></table></figure><h3 id="手动打印信息"><a class="markdownIt-Anchor" href="#手动打印信息">#</a> 手动打印信息</h3>
<p>当程序被某个断点阻塞之后，可以通过一些命令打印变量的名字或者变量的类型，并且还可以跟踪打印某个变量的值。</p>
<ol>
<li>
<p>打印变量值</p>
<p>在 gdb 调试的时候如果需要打印变量的值， 使用的命令是  <code>print</code> , 可缩写为  <code>p</code> 。如果打印的变量是整数还可以指定输出的整数的格式，格式化输出的整数对应的字符表如下：</p>
<table>
<thead>
<tr>
<th>格式化字符 (/fmt)</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>/x</td>
<td>以十六进制的形式打印出整数。</td>
</tr>
<tr>
<td>/d</td>
<td>以有符号、十进制的形式打印出整数。</td>
</tr>
<tr>
<td>/u</td>
<td>以无符号、十进制的形式打印出整数。</td>
</tr>
<tr>
<td>/o</td>
<td>以八进制的形式打印出整数。</td>
</tr>
<tr>
<td>/t</td>
<td>以二进制的形式打印出整数。</td>
</tr>
<tr>
<td>/f</td>
<td>以浮点数的形式打印变量或表达式的值。</td>
</tr>
<tr>
<td>/c</td>
<td>以字符形式打印变量或表达式的值。</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 举例</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p i       <span class="token comment"># 10 进制</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token variable">$5</span> <span class="token operator">=</span> <span class="token number">3</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/x i     <span class="token comment"># 16 进制</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token variable">$6</span> <span class="token operator">=</span> 0x3</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/o i     <span class="token comment"># 8 进制</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token variable">$7</span> <span class="token operator">=</span> 03</pre></td></tr></table></figure></li>
<li>
<p>打印变量类型</p>
<p>如果在调试过程中需要查看某个变量的类型，可以使用命令  <code>ptype</code></p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 打印变量类型</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> ptype i</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token builtin class-name">type</span> <span class="token operator">=</span> int</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> ptype array<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token builtin class-name">type</span> <span class="token operator">=</span> int</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> ptype array</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token builtin class-name">type</span> <span class="token operator">=</span> int <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span></pre></td></tr></table></figure></li>
</ol>
<h3 id="自动打印信息"><a class="markdownIt-Anchor" href="#自动打印信息">#</a> 自动打印信息</h3>
<ol>
<li>
<p>设置变量名自动显示</p>
<p>和 print 命令一样，display 命令也用于调试阶段查看某个变量或表达式的值，它们的区别是，使用 display 命令查看变量或表达式的值，每当程序暂停执行（例如单步执行）时，GDB 调试器都会自动帮我们打印出来，而 print 命令则不会。因此，当我们想频繁查看某个变量或表达式的值从而观察它的变化情况时，使用 display 命令可以一劳永逸。display 命令没有缩写形式，常用的语法格式如下 2 种：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 在变量的有效取值范围内，自动打印变量的值 (设置一次，以后就会自动显示)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> display 变量名</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 以指定的整形格式打印变量的值，关于 fmt 的取值，请参考 print 命令</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> display/fmt 变量名</pre></td></tr></table></figure></li>
<li>
<p>查看自动显示列表</p>
<p>对于使用 display 命令查看的目标变量或表达式，都会被记录在一张列表（称为自动显示列表）中。通过执行 info dispaly 命令，可以打印出这张表：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># info == i</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> info display</pre></td></tr><tr><td data-num="3"></td><td><pre>Auto-display expressions now <span class="token keyword">in</span> effect:</pre></td></tr><tr><td data-num="4"></td><td><pre>Num Enb Expression</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">1</span>:   y  i</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token number">2</span>:   y  array<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token number">3</span>:   y  /x array<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr></table></figure><p>在展示出的信息中，每个列的含义如下:</p>
<ul>
<li>Num : 变量或表达式的编号，GDB 调试器为每个变量或表达式都分配有唯一的编号</li>
<li>Enb : 表示当前变量（表达式）是处于激活状态还是禁用状态，如果处于激活状态（用 y 表示），则每次程序停止执行，该变量的值都会被打印出来；反之，如果处于禁用状态（用 n 表示），则该变量（表达式）的值不会被打印。</li>
<li>Expression ：被自动打印值的变量或表达式的名字。</li>
</ul>
</li>
<li>
<p>取消自动显示</p>
<p>对于不需要再打印值的变量或表达式，可以将其删除或者禁用。</p>
<ul>
<li>
<p>删除自动显示列表中的变量或表达式</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 命令中的 num 是通过 info display 得到的编号，编号可以是一个或者多个</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> undisplay num <span class="token punctuation">[</span>num1 <span class="token punctuation">..</span>.<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># num1 - numN 表示一个范围</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> undisplay num1-numN</pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> delete display num <span class="token punctuation">[</span>num1 <span class="token punctuation">..</span>.<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> delete display num1-numN</pre></td></tr></table></figure><p>举例说明:</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 查看显示列表</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> info display</pre></td></tr><tr><td data-num="3"></td><td><pre>Auto-display expressions now <span class="token keyword">in</span> effect:</pre></td></tr><tr><td data-num="4"></td><td><pre>Num Enb Expression</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">1</span>:   y  i</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token number">2</span>:   y  array<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token number">3</span>:   y  /x array<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment"># 删除变量显示，需要使用 info display 得到的变量 / 表达式编号</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> undisplay <span class="token number">1</span> <span class="token number">2</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment"># 查看显示列表，只剩下一个了</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> i display</pre></td></tr><tr><td data-num="14"></td><td><pre>Auto-display expressions now <span class="token keyword">in</span> effect:</pre></td></tr><tr><td data-num="15"></td><td><pre>Num Enb Expression</pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token number">3</span>:   y  /x array<span class="token punctuation">[</span>i<span class="token punctuation">]</span></pre></td></tr></table></figure></li>
<li>
<p>如果不想删除自动显示的变量，也可以禁用自动显示列表中处于激活状态下的变量或表达式</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 命令中的 num 是通过 info display 得到的编号，编号可以是一个或者多个</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> disable display num <span class="token punctuation">[</span>num1 <span class="token punctuation">..</span>.<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># num1 - numN 表示一个范围</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> disable display num1-numN</pre></td></tr></table></figure></li>
<li>
<p>当需要启用自动显示列表中被禁用的变量或表达式时，可以使用下边的命令</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 命令中的 num 是通过 info display 得到的编号，编号可以是一个或者多个</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token builtin class-name">enable</span>  display num <span class="token punctuation">[</span>num1 <span class="token punctuation">..</span>.<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># num1 - numN 表示一个范围</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> disable display num1-numN</pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="单步调试"><a class="markdownIt-Anchor" href="#单步调试">#</a> 单步调试</h3>
<p>当程序阻塞到某个断点上之后，可以通过以下命令对程序进行单步调试:</p>
<ul>
<li>
<p><code>step</code></p>
<p><code>step</code>  命令可以缩写为  <code>s</code> , 命令被执行一次代码被向下执行一行，如果这一行是一个函数调用，那么程序会进入到函数体内部。</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 从当前代码行位置，一次调试当前行下的每一行代码</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># step == s</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 如果这一行是函数调用，执行这个命令，就可以进入到函数体的内部</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> step</pre></td></tr></table></figure></li>
<li>
<p>finish</p>
<p>如果通过  <code>s</code>  单步调试进入到函数内部，想要跳出这个函数体， 可以执行  <code>finish</code>  命令。如果想要跳出函数体必须要保证函数体内不能有有效断点，否则无法跳出。</p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 如果通过 s 单步调试进入到函数内部，想要跳出这个函数体</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> finish</pre></td></tr></table></figure></li>
<li>
<p>next</p>
<p><code>next</code>  命令和  <code>step</code>  命令功能是相似的，只是在使用  <code>next</code>  调试程序的时候不会进入到函数体内部， <code>next</code>  可以缩写为  <code>n</code></p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># next == n</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># 如果这一行是函数调用，执行这个命令，不会进入到函数体的内部</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> next</pre></td></tr></table></figure></li>
<li>
<p>until</p>
<p>通过 until 命令可以直接跳出某个循环体，这样就能提高调试效率了。如果想直接从循环体中跳出，必须要满足以下的条件，否则命令不会生效：</p>
<ol>
<li>要跳出的循环体内部不能有有效的断点</li>
<li>必须要在循环体的开始 / 结束行执行该命令</li>
</ol>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">until</span></pre></td></tr></table></figure></li>
</ul>
<h3 id="设置变量值"><a class="markdownIt-Anchor" href="#设置变量值">#</a> 设置变量值</h3>
<p>在调试程序的时候，我们需要在某个变量等于某个特殊值的时候查看程序的运行状态，但是通过程序运行让变量等于这个值又非常困难，这种情况下就可以在 gdb 中直接对这个变量进行值的设置，或者是在单步调试的时候通过设置循环因子的值直接跳出某个循环，值设置的命令格式为:  <code>set var 变量名=值</code></p>
<figure class="highlight shell"><figcaption data-lang="Bash"><span>l</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 可以在循环中使用，直接设置循环因子的值</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># 假设某个变量的值在程序中 ==90 的概率是 5%, 这时候可以直接通过命令将这个变量值设置为 90</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token builtin class-name">set</span> var 变量名<span class="token operator">=</span>值</pre></td></tr></table></figure>
      <div class="tags">
          <a href="/tags/Linux/" rel="tag"><i class="ic i-tag"></i> Linux</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2023-04-23 22:20:02" itemprop="dateModified" datetime="2023-04-23T22:20:02+08:00">2023-04-23</time>
  </span>
  <span id="2023/03/01/Linux/" class="item leancloud_visitors" data-flag-title="Linux" title="阅读次数">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">阅读次数</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">次</span>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>AdventureYX <i class="ic i-at"><em>@</em></i>
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://adventure-yx.github.io/2023/03/01/Linux/" title="Linux">https://adventure-yx.github.io/2023/03/01/Linux/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aC1DTg=="><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2023/02/24/C++Study/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.picgo.net&#x2F;2023&#x2F;04&#x2F;02&#x2F;cover-28d1c78c70833bb4b.jpeg" title="C++ Study">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> C++</span>
  <h3>C++ Study</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2023/03/05/C++%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.picgo.net&#x2F;2023&#x2F;04&#x2F;02&#x2F;cover-8a5b052ddb664bba9.jpeg" title="C++面经">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> C++</span>
  <h3>C++面经</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#linux-%E9%85%8D%E7%BD%AE"><span class="toc-number">1.</span> <span class="toc-text"> Linux 配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text"> Linux 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%90%8D%E8%AF%8D"><span class="toc-number">2.1.</span> <span class="toc-text"> 一些名词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-%E5%86%85%E6%A0%B8"><span class="toc-number">2.2.</span> <span class="toc-text"> Linux 内核</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text"> Linux 系统目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="toc-number">2.4.</span> <span class="toc-text"> Linux 文件基本属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86"><span class="toc-number">2.5.</span> <span class="toc-text"> Linux 文件与目录管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">2.6.</span> <span class="toc-text"> 命令解析器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.1.</span> <span class="toc-text"> 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E8%A1%8C"><span class="toc-number">2.6.2.</span> <span class="toc-text"> 命令提示行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">2.6.3.</span> <span class="toc-text"> 命令行快捷键</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%9B%AE%E5%BD%95%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.7.</span> <span class="toc-text"> 处理目录的常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ls-%E5%88%97%E5%87%BA%E7%9B%AE%E5%BD%95"><span class="toc-number">2.7.1.</span> <span class="toc-text"> ls (列出目录)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cd-%E5%88%87%E6%8D%A2%E7%9B%AE%E5%BD%95"><span class="toc-number">2.7.2.</span> <span class="toc-text"> cd (切换目录)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pwd-%E6%98%BE%E7%A4%BA%E7%9B%AE%E5%89%8D%E6%89%80%E5%9C%A8%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="toc-number">2.7.3.</span> <span class="toc-text"> pwd (显示目前所在的目录)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mkdir-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9B%AE%E5%BD%95"><span class="toc-number">2.7.4.</span> <span class="toc-text"> mkdir (创建新目录)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rmdir-%E5%88%A0%E9%99%A4%E7%A9%BA%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="toc-number">2.7.5.</span> <span class="toc-text"> rmdir (删除空的目录)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cp-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95"><span class="toc-number">2.7.6.</span> <span class="toc-text"> cp (复制文件或目录)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rm-%E7%A7%BB%E9%99%A4%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95"><span class="toc-number">2.7.7.</span> <span class="toc-text"> rm (移除文件或目录)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mv-%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E6%88%96%E4%BF%AE%E6%94%B9%E5%90%8D%E7%A7%B0"><span class="toc-number">2.7.8.</span> <span class="toc-text"> mv (移动文件与目录，或修改名称)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B"><span class="toc-number">2.8.</span> <span class="toc-text"> Linux 文件内容查看</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cat"><span class="toc-number">2.8.1.</span> <span class="toc-text"> cat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tac"><span class="toc-number">2.8.2.</span> <span class="toc-text"> tac</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nl"><span class="toc-number">2.8.3.</span> <span class="toc-text"> nl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#more"><span class="toc-number">2.8.4.</span> <span class="toc-text"> more</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#less"><span class="toc-number">2.8.5.</span> <span class="toc-text"> less</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#head"><span class="toc-number">2.8.6.</span> <span class="toc-text"> head</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tail"><span class="toc-number">2.8.7.</span> <span class="toc-text"> tail</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux-%E9%93%BE%E6%8E%A5%E6%A6%82%E5%BF%B5"><span class="toc-number">3.</span> <span class="toc-text"> Linux 链接概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.1.</span> <span class="toc-text"> 硬连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.2.</span> <span class="toc-text"> 软连接</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux-%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text"> Linux 用户和用户组管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux-%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4"><span class="toc-number">5.</span> <span class="toc-text"> Linux 压缩命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux-%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4"><span class="toc-number">6.</span> <span class="toc-text"> Linux 查找命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text"> Linux 磁盘管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#df"><span class="toc-number">7.1.</span> <span class="toc-text"> df</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#du"><span class="toc-number">7.2.</span> <span class="toc-text"> du</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fdisk"><span class="toc-number">7.3.</span> <span class="toc-text"> fdisk</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux-vivim"><span class="toc-number">8.</span> <span class="toc-text"> Linux vi&#x2F;vim</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-vim"><span class="toc-number">8.1.</span> <span class="toc-text"> 什么是 vim？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vivim-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">8.2.</span> <span class="toc-text"> vi&#x2F;vim 的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.2.1.</span> <span class="toc-text"> 命令模式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.2.2.</span> <span class="toc-text"> 输入模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E7%BA%BF%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.2.3.</span> <span class="toc-text"> 底线命令模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vivim-%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">8.3.</span> <span class="toc-text"> vi&#x2F;vim 使用实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gcc"><span class="toc-number">9.</span> <span class="toc-text"> GCC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85gcc"><span class="toc-number">9.1.</span> <span class="toc-text"> 安装 GCC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gcc%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">9.2.</span> <span class="toc-text"> gcc 工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gcc%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text"> gcc 常用参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">9.4.</span> <span class="toc-text"> 多文件编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gcc%E5%92%8Cg"><span class="toc-number">9.5.</span> <span class="toc-text"> gcc 和 g++</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gdb%E8%B0%83%E8%AF%95"><span class="toc-number">10.</span> <span class="toc-text"> GDB 调试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%87%86%E5%A4%87"><span class="toc-number">10.1.</span> <span class="toc-text"> 调试准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%92%8C%E9%80%80%E5%87%BAgdb"><span class="toc-number">10.2.</span> <span class="toc-text"> 启动和退出 gdb</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8gdb"><span class="toc-number">10.2.1.</span> <span class="toc-text"> 启动 gdb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E5%8F%82"><span class="toc-number">10.2.2.</span> <span class="toc-text"> 命令行传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gdb%E4%B8%AD%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">10.2.3.</span> <span class="toc-text"> gdb 中启动程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%80%E5%87%BAgdb"><span class="toc-number">10.2.4.</span> <span class="toc-text"> 退出 gdb</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">10.3.</span> <span class="toc-text"> 查看代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6"><span class="toc-number">10.3.1.</span> <span class="toc-text"> 当前文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E6%96%87%E4%BB%B6"><span class="toc-number">10.3.2.</span> <span class="toc-text"> 切换文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%98%BE%E7%A4%BA%E8%A1%8C%E6%95%B0"><span class="toc-number">10.3.3.</span> <span class="toc-text"> 设置显示行数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">10.4.</span> <span class="toc-text"> 断点操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9"><span class="toc-number">10.4.1.</span> <span class="toc-text"> 设置断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%96%AD%E7%82%B9"><span class="toc-number">10.4.2.</span> <span class="toc-text"> 查看断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%AD%E7%82%B9"><span class="toc-number">10.4.3.</span> <span class="toc-text"> 删除断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9%E7%8A%B6%E6%80%81"><span class="toc-number">10.4.4.</span> <span class="toc-text"> 设置断点状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="toc-number">10.5.</span> <span class="toc-text"> 调试命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E7%BB%AD%E8%BF%90%E8%A1%8C-gdb"><span class="toc-number">10.5.1.</span> <span class="toc-text"> 继续运行 gdb</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF"><span class="toc-number">10.5.2.</span> <span class="toc-text"> 手动打印信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF"><span class="toc-number">10.5.3.</span> <span class="toc-text"> 自动打印信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95"><span class="toc-number">10.5.4.</span> <span class="toc-text"> 单步调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F%E5%80%BC"><span class="toc-number">10.5.5.</span> <span class="toc-text"> 设置变量值</span></a></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li class="active"><a href="/2023/03/01/Linux/" rel="bookmark" title="Linux">Linux</a></li><li><a href="/2023/03/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%97%E5%A4%A72023%EF%BC%89/" rel="bookmark" title="操作系统（南大2023）">操作系统（南大2023）</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="AdventureYX"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">AdventureYX</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">12</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">4</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">9</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FkdmVudHVyZS15eA==" title="https:&#x2F;&#x2F;github.com&#x2F;Adventure-yx"><i class="ic i-github"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2023/02/24/C++Study/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2023/03/05/C++%E9%9D%A2%E7%BB%8F/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/03/12/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/" title="算法进阶">算法进阶</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/03/05/C++%E9%9D%A2%E7%BB%8F/" title="C++面经">C++面经</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">设计模式</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/04/02/C++11/" title="C++11特性">C++11特性</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Linux/" title="分类于 Linux">Linux</a>
</div>

    <span><a href="/2023/03/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%97%E5%A4%A72023%EF%BC%89/" title="操作系统（南大2023）">操作系统（南大2023）</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/DataBase/" title="分类于 DataBase">DataBase</a>
</div>

    <span><a href="/2023/03/06/CMU15-445/" title="CMU15-445（2022Fall）">CMU15-445（2022Fall）</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/02/24/C++Study/" title="C++ Study">C++ Study</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/DataBase/" title="分类于 DataBase">DataBase</a>
</div>

    <span><a href="/2023/03/06/CMU15-445%20Project0/" title="CMU15-445 Project#0 字典树trie">CMU15-445 Project#0 字典树trie</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Linux/" title="分类于 Linux">Linux</a>
</div>

    <span><a href="/2023/03/01/Linux/" title="Linux">Linux</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/03/10/STL/" title="STL">STL</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2022 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">AdventureYX @ Adventure</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2023/03/01/Linux/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
