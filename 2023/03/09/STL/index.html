



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="Adventure" href="http://example.com/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Adventure" href="http://example.com/atom.xml" />
<link rel="alternate" type="application/json" title="Adventure" href="http://example.com/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="C++,STL" />


<link rel="canonical" href="http://example.com/2023/03/09/STL/">



  <title>
STL - C++ |
Yume Shoka = Adventure = 心有所向。日复一日，必有精进</title>
<meta name="generator" content="Hexo 6.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">STL
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2023-03-09 20:42:19">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2023-03-09T20:42:19+08:00">2023-03-09</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Yume Shoka</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicit31ffoj20zk0m8naf.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicli9lfebj20zk0m84qp.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicm0n457cj20zk0m8e81.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giciuv0socj20zk0m8qes.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicljitigmj20zk0m87fp.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclwuom7cj20zk0m8dvn.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/C/" itemprop="item" rel="index" title="分类于 C++"><span itemprop="name">C++</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/09/STL/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="AdventureYX">
    <meta itemprop="description" content="心有所向。日复一日，必有精进, ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Adventure">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <p>C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。</p>
<blockquote>
<p>STL 从广义上讲分为三类: algorithm (算法) 、container (容器)、iterator (迭代器)。容器和算法可以通过迭代器进行无缝的连接。</p>
</blockquote>
<p>STL 提供了六大组件，彼此组合套用协同工作。这六大组件分别是：</p>
<ul>
<li>容器（Containers）：各种数据结构，如 vector、list、deque、set、map 等。从实现的角度来看，容器是一种 class template。</li>
<li>算法（Algorithms）：各种常用算法，提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作，比如 sort、search、copy、erase。从实现的角度来看，<strong>STL 算法是一种 function template</strong>。</li>
<li>迭代器（Iterators）：迭代器用于遍历对象集合的元素，扮演容器与算法之间的胶合剂，是所谓的 “泛型指针”，共有 5 种类型，以及其他衍生变化。从实现角度来看，迭代器是一种将 operator*、operator-&gt;、operator++、operator-- 等指针操作予以重载的 class template。所有的 STL 容器附带有自己专属的迭代器，因为只有容器设计者才知道如何遍历自己的元素。</li>
<li>仿函数（Functors）：也称为函数对象（Function object），行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了 operator () 的 class 或者 class template。</li>
<li>适配器（Adaptors）：一种用来修饰容器或者仿函数或迭代器接口的东西。例如 STL 提供的 queue 和 stack，就是一种空间配接器，因为它们的底部完全借助于 deque。</li>
<li>分配器（Allocators）：也称为空间配置器，负责空间的配置与管理。从实现的角度来看，配置器是一个实现了动态配置空间、空间管理、空间释放的 class template。</li>
</ul>
<p>STL 六大组件的交互关系</p>
<p><img data-src="picturestl1.png" alt="img"></p>
<p>使用 STL 的好处：</p>
<ul>
<li>STL 是 C++ 的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</li>
<li>STL 的一个重要特点是数据结构和算法的分离。(内部使用的模板，或者说泛型编程)</li>
<li>程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL。比精力用在开发上</li>
<li>STL 具有高可重用性、高性能、高移植性、跨平台等优点
<ul>
<li>高可重用性: STL 中几乎所有的代码的采用了模板类和模板函数的方式实现，这相当于传统的由函数和类组成的库来说提供了更好的代码重用机会。</li>
<li>高性能：底层使用的数据结构和算法比较优秀，如 map 的红黑树</li>
<li>高移植性：因为是内建在编译器之内，项目 A 中用 STL 编写的模块可以直接移植到项目 B 上。</li>
<li>跨平台：windows 上写的可以在 Linux 上运行 (反之一同)</li>
</ul>
</li>
</ul>
<p>一．</p>
<p>二 vector 扩容原理<br>
 1 新增元素：Vector 通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就会分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。注意不是在原来空间后直接增加空间<br>
 2 对 vector 的任何操作，一旦引起空间重新配置，指向原 vector 的所有迭代器就都失效了。<br>
3 不同的编译器实现的扩容方式不一样，VS2015 中以 1.5 倍扩容，GCC 以 2 倍扩容。</p>
<p>三 vector 扩容为什么以 2 倍增长<br>
 1 时间和空间的权衡，简单来说， 空间分配的多，平摊时间复杂度低，但浪费空间也多。<br>
2 均摊添加每个元素的开销最小。</p>
<p>四 vector 扩容为什么以 1.5 倍增长<br>
理想分配方案是是在第 N 次分配的时候能重用之前 N-1 次释放的内存，如果按照 1.5 分配，1，1.5，3，4.5…… 当你需要分配 4.5 时，前面已分配 5.5，你可以直接利用，把旧数据 move 过去。但选择两倍的增长比如像这样：1，2，4，8，16，32，… 每次需要申请的空间都大于用到前面释放的内存 (4&gt;2+1)，无法重用。</p>
<p>五 vector 常用接口：<br>
・清空 vector 可以使用成员函数 c.clear ()<br>
・判断 vector 是否为空，可以使用成员函数 empty ()，如果为空返回 true，否则返回 false<br>
・vector 输出最后一个元素的引用可以用 back () 成员函数，如果容器为空，则行为未定义<br>
・vector 输出第一个元素的引用可以用 front () 成员函数，如果容器为空，则行为未定义<br>
・vector 支持用下标访问元素，类似数组一样 c [n] 其中 n 是一个无符号整数，如果 n 大于容器的长度，那么行为未定义<br>
・vector 为了防止越界访问，<span class="exturl" data-url="aHR0cDovL3huLS1jLWtxNmEwOGhxcGc4Z2J3M2E0bWZuc2QuYXQ=">其中有成员函数 c.at</span> (n)，返回下标为 n 的元素的引用。如果下标越界，那么抛出 out_of_range 的异常<br>
・pop_back () 成员函数用来删除 vector 中的最后一个元素，如果容器为空会出现未定义行为。<br>
・c.erase (it) 成员函数，删除迭代器 it 所指向的元素，返回一个指向被删除元素之后的迭代器，如果 it 指向最后一个元素，那么返回以为尾后迭代器（通常是 end ()）。若 it 就是 end ()，那么行为未定义。<br>
・c.erase (beg,ed) 删除 [beg,ed) 范围的元素，同时返回最后一个元素的后面的迭代器，如果 ed 就是尾后迭代器，那么还返回一个尾后迭代器。<br>
・vector 中 begin 和 end 函数返回的是什么？<br>
begin 返回的是第一个元素的迭代器，end 返回的是最后一个元素后面位置的迭代器。前闭后开区间【）<br>
・vector 中的 reserve 和 resize 的区别<br>
 reserve 是直接扩充到已经确定的大小，可以减少多次开辟、释放空间的问题（优化 push_back），就可以 提高效率，其次还可以减少多次要拷贝数据的问题。reserve 只是保证 vector 中的空间大小（capacity）最少 达到参数所指定的大小 n。reserve () 只有一个参数。<br>
resize () 可以改变有效空间的大小，也有改变默认值的功能。capacity 的大小也会随着改变。resize () 可以有 多个参数。<br>
・vector 中的 size 和 capacity 的区别<br>
 size 表示当前 vector 中有多少个元素（finish - start）;<br>
capacity 函数则表示它已经分配的内存中可以容纳多少元素（end_of_storage - start）;<br>
・vector 迭代器失效的情况<br>
当插入一个元素到 vector 中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。 当删除容器中一个元素后，该迭代器所指向的元素已经被删除，那么也造成迭代器失效。erase 方法会返回下 一个有效的迭代器，所以当我们要删除某个元素时，需要 it=vec.erase (it)。<br>
・正确释放 vector 的内存 (clear (), swap (), shrink_to_fit ())<br>
 vec.clear ()：清空内容，但是不释放内存。<br>
vector ().swap (vec)：清空内容，且释放内存，想得到一个全新的 vector。 vec.shrink_to_fit ()：请求容器降低其 capacity 和 size 匹配。 vec.clear ();vec.shrink_to_fit ();：清空内容，且释放内存。<br>
・vector 中 erase 方法与 algorithn 中的 remove 方法区别<br>
 vector 中 erase 方法真正删除了元素，迭代器不能访问了。<br>
remove 只是简单地将元素移到了容器的最后面，迭代器还是可以访问到。因为 algorithm 通过迭代器进行操作，不知道容器的内部结构，所以无法进行真正的删除。</p>
<p>六 List 原理</p>
<p>list 是由双向链表实现的，因此内存空间是不连续的。<br>
list 的随机访问效率不好，需要遍历元素，时间复杂度为 o (n)。<br>
3. 底层是双向链表，所以每个元素有两个指针的额外空间开销。<br>
4. 在任何位置都能高效地插入和删除元素。只要改变元素的指针值，不需要拷贝元素。<br>
七 vector、list、queue 选择原则：<br>
1 需要对数据高效地随机访问 (存取)，而不在乎插入和删除的效率，采用 vector<br>
2 需要大量插入、删除数据，而不关心随机访问数据，采用 list<br>
3 需要随机访问数据，而且关心前后增删数据的能力，采用 deque<br>
4 对数据中间的增删操作比较多：采用 list，建议在排序的基础上，批量进行增删可以对运行效率提供最大的保证</p>
<p>八 map 的底层实现<br>
容器的数据结构是采用红黑树进行管理，插入的元素健位不允许重复，所使用的节点元素的比较函数，只对元素的健值进行比较，元素的各项数据可通过健值检索出来。map 容器是一种关联容器。</p>
<p>九 map 和 unordered_map 的实现机理：<br>
map: 是基于红黑树来实现的（红黑树是非常严格的平衡二叉搜索树），红黑树具有自动排序功能，红黑树的每一个节点都代表着 map 中的一个元素，因此对于 map 的查找，删除和插入操作都是对红黑树的操作。<br>
unordered_map: 是基于哈希表来实现的，查找的时间复杂度是 O (1), 在海量数据处理中有着广泛的应用。</p>
<p>十 map 和 unordered_map 的优缺点<br>
 map 的优点：（1）map 是有序的（2）基于红黑树实现，查找的时间复杂度是 O (n)<br>
 map 的缺点：空间占用率比较高，因为内部实现了红黑树，虽然提高了运行效率，但是每个节点都要保存父亲节点和孩子节点和红黑树的性质，使得每一个节点都占用大量的空间。<br>
适用的情况：对于要有序的结构，适用 map<br>
unordered_map 的优点：因为内部是哈希表来实现的，所以查找效率会非常高<br>
 unordered_map 的缺点：哈希表的建立比较费时<br>
适用的情况：对于查找问题，适用 unordered_map 会更好一点。</p>
<p>十一 Map 插入元素方法<br>
 map&lt;int, string&gt; mapStudent;<br>
1 mapStudent.insert(pair&lt;int, string&gt;(1, “student_one”));<br>
2 mapStudent.insert(map&lt;int, string&gt;::value_type (1, “student_one”));<br>
3 mapStudent[1] = “student_one”;<br>
 以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用 insert 函数插入数据，在数据的插入上涉及到集合的唯一性这个概念，即当 map 中有这个关键字时，insert 操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对应的值</p>
<p>十二 为何 map 和 set 的插入删除效率比其他序列容器高<br>
因为不需要内存拷贝和内存移动</p>
<p>十三 当数据元素增多时（从 10000 到 20000），map 的 set 的查找速度会怎样 变化？<br>
RB-TREE 用二分查找法，时间复杂度为 logn，所以从 10000 增到 20000 时，查找次数从 log10000=14 次到 log20000=15 次，多了 1 次而已。</p>
<p>十四 map 、set、multiset、multimap 的特点<br>
 set 和 multiset 会根据特定的排序准则自动将元素排序，set 中元素不允许重复，multiset 可以重复。 map 和 multimap 将 key 和 value 组成的 pair 作为元素，根据 key 的排序准则自动将元素排序（因为红黑树也是 二叉搜索树，所以 map 默认是按 key 排序的），map 中元素的 key 不允许重复，multimap 可以重复。 map 和 set 的增删改查速度为都是 logn，是比较高效的。</p>
<p>十五 为何 map 和 set 每次 insert 之后， 以前保存的 iterator 不会失效？<br>
存储的是结点，不需要内存拷贝和内存移动。 插入操作只是结点指针换来换去，结点内存没有改变。而 iterator 就像指向结点的指针，内存没变，指向内 存的指针也不会变。 6</p>
<p>十六 为何 map 和 set 不能像 vector 一样有个 reserve 函数来预分配数据？<br>
 在 map 和 set 内部存储的已经不是元素本身了，而是包含元素的结点。也就是说 map 内部使用的 Alloc 并不是 map 声明的时候从参数中传入的 Alloc。</p>
<p>十七 set 底层实现<br>
底层是红黑树，set 会根据待定的排序准则，自动将元素排序。不允许元素重复。</p>
<p>十八 set, multiset (map,multimap)<br>
 set 和 multiset 会根据特定的排序准则自动将元素排序，set 中元素不允许重复，multiset 可以重复。因为是排序的，所以 set 中的元素不能被修改，只能删除后再添加。</p>
<p>十九 set 的底层实现实现为什么不用哈希表而使用红黑树？<br>
set 中元素是经过排序的，红黑树也是有序的，哈希是无序的 如果只是单纯的查找元素的话，那么肯定要选哈希表了，因为哈希表在的最好查找时间复杂度为 O (1)，并且 如果用到 set 中那么查找时间复杂度的一直是 O（1），因为 set 中是不允许有元素重复的。而红黑树的查找时 间复杂度为 O (lgn)</p>
<p>二十 hash 表<br>
 hash 表的实现，包括 STL 中的哈希桶长度常数。<br>
hash 表的实现主要涉及两个问题：散列函数和碰撞处理。<br>
1）hash function （散列函数）。最常见的散列函数：f (x) = x % TableSize .<br>
2）碰撞问题（不同元素的散列值相同）。解决碰撞问题的方法有许多种，包括线性探测、二次探测、开链等做法。SGL 版本使用开链法，使用一个链表保持相同散列值的元素。</p>
<p>二十一 你怎样理解迭代器？<br>
Iterator (迭代器) 用于提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示，相当于智能指针。</p>
<p>二十二 迭代器失效问题<br>
 vector 迭代器<br>
当插入一个元素后，插入点之前的迭代器如果未扩容则不受影响，插入点之后的迭代器失效；<br>
当插入一个元素后，capacity 如果有变化，则容器需要重新分配内存，所有迭代器都会失效；<br>
当进行删除操作后，指向删除点及之后元素的迭代器全部失效。<br>
deque 迭代器<br>
在容器 begin/end 插入操作所有迭代器不受影响；<br>
在容器非 begin/end 的位置插入和删除操作都会使指向该容器元素的所有迭代器失效。<br>
在容器 begin/end 删除元素会使指向被删除元素的迭代器失效；<br>
List/forward_list 迭代器<br>
 list insert 操作不会使 list 迭代器失效；<br>
list erase 操作会使当前指向被删除元素的迭代器失效，其它迭代器正常。<br>
set 迭代器<br>
 set 的 insert 操作不会使 set 迭代器失效；<br>
set erase 操作会使当前指向被删除元素的迭代器失效，其它迭代器正常。<br>
map 迭代器<br>
 map 的 insert 操作不会使 map 迭代器失效；<br>
map erase 删除操作会使当前指向被删除元素的迭代器失效</p>
<p>二十三 vector 为何每次 insert 之后，以前保存的 iterator 不会失效？<br>
 答:iterator 这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢 (当然被删除的那个元素本身已经失效了)。相对于 vector 来说，每一次删除和插入，指针都有可能失效，调用 push_back 在尾部插入也是如此。因为为了保证内部数据的连续存放，iterator 指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时 push_back 的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。特别时在和 find 等算法在一起使用的时候，牢记这个原则：不要使用过期的 iterator。</p>
<p>二十四 vector、list、map、deque 用 erase（it）后，迭代器的变化。<br>
vector 和 deque 是序列式容器，其内存分别是连续空间和分段连续空间，删除迭代器 it 后，其后面的迭代器都失效了，此时 it 及其后面的迭代器会自动加 1，使 it 指向被删除元素的下一个元素。<br>
list 删除迭代器 it 时，其后面的迭代器都不会失效，将前面和后面连接起来即可。<br>
map 也是只能使当前删除的迭代器失效，其后面的迭代器依然有效。</p>
<p>二十五 不允许有遍历行为的容器有哪些（不提供迭代器）？<br>
1）queue，除了头部外，没有其他方法存取 deque 的其他元素。<br>
2）stack（底层以 deque 实现），除了最顶端外，没有任何其他方法可以存取 stack 的其他元素。<br>
3）heap，所有元素都必须遵循特别的排序规则，不提供遍历功能。</p>
<p>二十六 stl 中 alloc<br>
SGI 版本 STL 的默认配置器 std::alloc。参见：《STL 源码剖析》<br>
1）考虑到小型区块所可能造成的内存碎片问题，SGI 设计了双层配置器。第一级配置器直接使用 malloc () 和 free ()；第二级则视情况采取不同的策略：当配置区块超过 128bytes 时，视为 “足够大”，便调用第一级配置器；当配置区块小于 128bytes 时，视之为 “过小”，为了降低额外负担，便采用 memory pool（内存池）整理方式，而不在求助于第一级配置器。<br>
2）内存池的核心：内存池和 16 个自由链表（各自管理 8,16，…，128bytes 的小额区块）。在分配一个小区块时，首先在所属自由链表中寻找，如果找到，直接抽出分配；若所属自由链表为空，则请求内存池为所属自由链表分配空间；默认情况下，为该自由链表分配 20 个区块，若内存池剩余容量不足，则分配可分配的最大容量；若内存池连一个区块都无法分配，则调用 chunk_alloc 为内存池分配一大块区块；若内存不足，则尝试调用 malloc 分配，否则返回 bad_alloc 异常。</p>
<p>二十七 STL 线程不安全的情况<br>
在对同一个容器进行多线程的读写、写操作时；<br>
在每次调用容器的成员函数期间都要锁定该容器；<br>
在每个容器返回的迭代器（例如通过调用 begin 或 end）的生存期之内都要锁定该容器； 在每个在容器上调用的算法执行期间锁定该容器。</p>
<p>二十八 priority_queue 的底层原理<br>
 priority_queue：优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是当前队列中优先级最 高的那一个。</p>

      <div class="tags">
          <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C++</a>
          <a href="/tags/STL/" rel="tag"><i class="ic i-tag"></i> STL</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2023-04-07 13:42:39" itemprop="dateModified" datetime="2023-04-07T13:42:39+08:00">2023-04-07</time>
  </span>
  <span id="2023/03/09/STL/" class="item leancloud_visitors" data-flag-title="STL" title="阅读次数">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">阅读次数</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">次</span>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>AdventureYX <i class="ic i-at"><em>@</em></i>Adventure
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2023/03/09/STL/" title="STL">http://example.com/2023/03/09/STL/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aC1DTg=="><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2023/03/06/Linux/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.picgo.net&#x2F;2023&#x2F;04&#x2F;02&#x2F;cover-28d1c78c70833bb4b.jpeg" title="Linux">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> Linux</span>
  <h3>Linux</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2023/03/10/CMU15-445/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.picgo.net&#x2F;2023&#x2F;04&#x2F;02&#x2F;cover-3d001679d9230e286.jpeg" title="CMU15-445">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> DataBase</span>
  <h3>CMU15-445</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li><a href="/2023/02/24/C++Study/" rel="bookmark" title="C++ Study">C++ Study</a></li><li><a href="/2023/03/05/C++%E9%9D%A2%E7%BB%8F/" rel="bookmark" title="C++面经">C++面经</a></li><li class="active"><a href="/2023/03/09/STL/" rel="bookmark" title="STL">STL</a></li><li><a href="/2023/03/10/STL%E5%AE%B9%E5%99%A8/" rel="bookmark" title="STL容器">STL容器</a></li><li><a href="/2023/03/12/STL%E5%87%BD%E6%95%B0/" rel="bookmark" title="STL函数">STL函数</a></li><li><a href="/2023/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="bookmark" title="设计模式">设计模式</a></li><li><a href="/2023/04/02/C++11/" rel="bookmark" title="C++11">C++11</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="AdventureYX"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">AdventureYX</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">11</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">4</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">7</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FkdmVudHVyZS15eA==" title="https:&#x2F;&#x2F;github.com&#x2F;Adventure-yx"><i class="ic i-github"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2023/03/06/Linux/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2023/03/10/CMU15-445/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/03/09/STL/" title="STL">STL</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/03/05/C++%E9%9D%A2%E7%BB%8F/" title="C++面经">C++面经</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Linux/" title="分类于 Linux">Linux</a>
</div>

    <span><a href="/2023/03/06/Linux/" title="Linux">Linux</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/DataBase/" title="分类于 DataBase">DataBase</a>
</div>

    <span><a href="/2023/03/10/CMU15-445/" title="CMU15-445">CMU15-445</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Qt/" title="分类于 Qt">Qt</a>
</div>

    <span><a href="/2023/03/12/QtStudy/" title="Qt Study">Qt Study</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/03/10/STL%E5%AE%B9%E5%99%A8/" title="STL容器">STL容器</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/04/02/C++11/" title="C++11">C++11</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">设计模式</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Qt/" title="分类于 Qt">Qt</a>
</div>

    <span><a href="/2023/03/26/QML&QtQuick/" title="QML &amp; Qt Quick">QML & Qt Quick</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/02/24/C++Study/" title="C++ Study">C++ Study</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2022 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">AdventureYX @ Yume Shoka</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2023/03/09/STL/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
