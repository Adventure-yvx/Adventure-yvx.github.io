



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="" href="https://adventure-yx.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="" href="https://adventure-yx.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="" href="https://adventure-yx.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="C++,STL,算法" />


<link rel="canonical" href="https://adventure-yx.github.io/2023/03/30/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/">



  <title>
算法进阶 - C++ |
Adventure =  = 心有所向。日复一日，必有精进</title>
<meta name="generator" content="Hexo 6.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">算法进阶
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2023-03-30 20:42:19">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2023-03-30T20:42:19+08:00">2023-03-30</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Adventure</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
          <img src="/2023/03/30/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/sky-16.jpg">
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/C/" itemprop="item" rel="index" title="分类于 C++"><span itemprop="name">C++</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="https://adventure-yx.github.io/2023/03/30/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="AdventureYX">
    <meta itemprop="description" content="心有所向。日复一日，必有精进, ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="排序算法总结"><a class="markdownIt-Anchor" href="#排序算法总结">#</a> 排序算法总结</h1>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>英文名称</th>
<th>时间复杂度</th>
<th>最佳情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
<th>排序类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>Bubble Sort</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>In-place</td>
<td>稳定</td>
<td>比较</td>
</tr>
<tr>
<td>插入排序</td>
<td>Insertion Sort</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>In-place</td>
<td>稳定</td>
<td>比较</td>
</tr>
<tr>
<td>选择排序</td>
<td>Selection Sort</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>In-place</td>
<td>不稳定</td>
<td>比较</td>
</tr>
<tr>
<td>希尔排序</td>
<td>Shell Sort</td>
<td>O(n^3/2)</td>
<td>O(nlog²n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>In-place</td>
<td>不稳定</td>
<td>比较</td>
</tr>
<tr>
<td>快速排序</td>
<td>Quick Sort</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n²)</td>
<td>O(logn)</td>
<td>In-place</td>
<td>不稳定</td>
<td>比较</td>
</tr>
<tr>
<td>堆排序</td>
<td>Heap Sort</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>In-place</td>
<td>不稳定</td>
<td>比较</td>
</tr>
<tr>
<td>归并排序</td>
<td>Merge Sort</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>Out-place</td>
<td>稳定</td>
<td>比较</td>
</tr>
<tr>
<td>桶排序</td>
<td>Bucket Sort</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Out-place</td>
<td>稳定</td>
<td>非比较</td>
</tr>
<tr>
<td>基数排序</td>
<td>Radix Sort</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Out-place</td>
<td>稳定</td>
<td>非比较</td>
</tr>
<tr>
<td>计数排序</td>
<td>Counting Sort</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Out-place</td>
<td>稳定</td>
<td>非比较</td>
</tr>
</tbody>
</table>
<ul>
<li>稳定：如果原本序列中 a 在 b 前面且 a=b，排序后 a 仍在 b 前面，顺序不变；</li>
<li>不稳定：如果原本序列中 a 在 b 前面且 a=b，排序后 a 可能在 b 后面，顺序可能发生改变；</li>
<li>内排序：所有排序操作均在内存中完成；</li>
<li>外排序：由于数据量太大，将其放入磁盘中，排序过程中需要磁盘与内存之间的数据传输；</li>
<li>时间复杂度：一个排序算法在执行过程中所耗费的时间量级的度量；</li>
<li>空间复杂度：一个排序算法在运行过程中临时占用存储空间大小的度量；</li>
</ul>
<h2 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序">#</a> 冒泡排序</h2>
<p>遍历所有的数据，每次对相邻元素进行两两比较，如果顺序和预先规定的顺序不一致，则进行位置交换；这样一次遍历会将最大或最小的数据上浮至顶端，之后再重复同样的操作，直到所有的数据有序。数据反序时，耗时最长 O (n²)；数据正序时，耗时最短 O (n)。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 冒泡排序</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>T data<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">int</span> flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token operator">-</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>data<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                T t<span class="token operator">=</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>data<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                data<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序">#</a> 快速排序</h2>
<p>快速排序采用分治法。首先从数列中挑出一个元素作为中间值。依次遍历数据，所有比中间值小的元素放在左边，所有比中间值大的元素放在右边。然后按此方法对左右两个子序列分别进行递归操作，直到所有数据有序。最理想的情况是，每次划分所选择的中间数恰好将当前序列几乎等分（均匀排布），整个算法的时间复杂度为 O (n logn)。 最坏的情况是，每次所选的中间数是当前序列中的最大或最小元素（正序和逆序都是最坏），整个排序算法的时间复杂度为 O (n²)。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 快速排序</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span>T data<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    T pivot<span class="token operator">=</span>data<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token operator">&amp;&amp;</span>data<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">></span>pivot<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            right<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        data<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">=</span>data<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token operator">&amp;&amp;</span>data<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivot<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            left<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        data<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">=</span>data<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    data<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">=</span>pivot<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">return</span> left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span>T data<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">int</span> p<span class="token operator">=</span><span class="token function">Partition</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span>left<span class="token punctuation">,</span>p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h1 id="算法性能分析"><a class="markdownIt-Anchor" href="#算法性能分析">#</a> 算法性能分析</h1>
<h2 id="时间复杂度分析"><a class="markdownIt-Anchor" href="#时间复杂度分析">#</a> 时间复杂度分析</h2>
<h3 id="什么是时间复杂度"><a class="markdownIt-Anchor" href="#什么是时间复杂度">#</a> 什么是时间复杂度</h3>
<p><strong>时间复杂度是一个函数，它定性描述该算法的运行时间</strong>。</p>
<p>我们在软件开发中，时间复杂度就是用来方便开发者估算出程序运行的答题时间。</p>
<p>那么该如何估计程序运行时间呢，通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认 CPU 的每个单元运行消耗的时间都是相同的。</p>
<p>假设算法的问题规模为 n，那么操作单元数量便用函数 f (n) 来表示，随着数据规模 n 的增大，算法执行时间的增长率和 f (n) 的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O (f (n))。</p>
<h3 id="什么是大o"><a class="markdownIt-Anchor" href="#什么是大o">#</a> 什么是大 O</h3>
<p>算法导论给出的解释：<strong>大 O 用来表示上界的</strong>，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。</p>
<p>同样算法导论给出了例子：拿插入排序来说，插入排序的时间复杂度我们都说是 O (n^2) 。</p>
<p>输入数据的形式对程序运算时间是有很大影响的，在数据本来有序的情况下时间复杂度是 O (n)，但如果数据是逆序的话，插入排序的时间复杂度就是 O (n<sup>2)，也就对于所有输入情况来说，最坏是 O (n</sup>2) 的时间复杂度，所以称插入排序的时间复杂度为 O (n^2)。</p>
<p>同样的同理再看一下快速排序，都知道快速排序是 O (nlogn)，但是当数据已经有序情况下，快速排序的时间复杂度是 O (n^2) 的，<strong>所以严格从大 O 的定义来讲，快速排序的时间复杂度应该是 O (n^2)</strong>。</p>
<p><strong>但是我们依然说快速排序是 O (nlogn) 的时间复杂度，这个就是业内的一个默认规定，这里说的 O 代表的就是一般情况，而不是严格的上界</strong>。</p>
<p>我们主要关心的还是一般情况下的数据形式。</p>
<p><strong>面试中说道算法的时间复杂度是多少指的都是一般情况</strong>。但是如果面试官和我们深入探讨一个算法的实现以及性能的时候，就要时刻想着数据用例的不一样，时间复杂度也是不同的，这一点是一定要注意的。</p>
<h3 id="不同数据规模的差异"><a class="markdownIt-Anchor" href="#不同数据规模的差异">#</a> 不同数据规模的差异</h3>
<p><img data-src="20230310124015324.png" alt="时间复杂度，不同数据规模的差异"></p>
<p>如图中可以看出不同算法的时间复杂度在不同数据输入规模下的差异。</p>
<p>在决定使用哪些算法的时候，不是时间复杂越低的越好（因为简化后的时间复杂度忽略了常数项等等），要考虑数据规模，如果数据规模很小甚至可以用 O (n^2) 的算法比 O (n) 的更合适（在有常数项的时候）。</p>
<p>就像上图中 O (5n^2) 和 O (100n) 在 n 为 20 之前 很明显 O (5n^2) 是更优的，所花费的时间也是最少的。</p>
<p>那为什么在计算时间复杂度的时候要忽略常数项系数呢，也就说 O (100n) 就是 O (n) 的时间复杂度，O (5n^2) 就是 O (n^2) 的时间复杂度，而且要默认 O (n) 优于 O (n^2) 呢 ？</p>
<p>这里就又涉及到大 O 的定义，<strong>因为大 O 就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量</strong>。</p>
<p>例如上图中 20 就是那个点，n 只要大于 20 常数项系数已经不起决定性作用了。</p>
<p><strong>所以我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示</strong>：</p>
<p>O (1) 常数阶 &lt; O (logn) 对数阶 &lt; O (n) 线性阶 &lt; O (nlogn) 线性对数阶 &lt; O (n^2) 平方阶 &lt; O (n^3) 立方阶 &lt; O (2^n) 指数阶</p>
<p>但是也要注意大常数，如果这个常数非常大，例如 10^7 ，10^9 ，那么常数就是不得不考虑的因素了。</p>
<h1 id="数组"><a class="markdownIt-Anchor" href="#数组">#</a> 数组</h1>
<p>** 数组是存放在连续内存空间上的相同类型数据的集合。** 数组可以方便的通过下标索引的方式获取到下标下对应的数据。</p>
<ul>
<li><strong>数组下标都是从 0 开始的。</strong></li>
<li><strong>数组内存空间的地址是连续的</strong></li>
</ul>
<p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p>
<p>使用 C++ 的话，要注意 vector 和 array 的区别，vector 的底层实现是 array，严格来讲 vector 是容器，不是数组。</p>
<p><strong>数组的元素是不能删的，只能覆盖。</strong></p>
<h2 id="二分查找"><a class="markdownIt-Anchor" href="#二分查找">#</a> 二分查找</h2>
<h3 id="二分查找-leetcode704"><a class="markdownIt-Anchor" href="#二分查找-leetcode704">#</a> 二分查找 - LeetCode704</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktc2VhcmNoLw==">704. 二分查找 - 力扣（LeetCode）</span></p>
<blockquote>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1:</p>
<p>输入: nums = [-1,0,3,5,9,12], target = 9<br>
 输出: 4<br>
 解释: 9 出现在 nums 中并且下标为 4</p>
<p>示例 2:</p>
<p>输入: nums = [-1,0,3,5,9,12], target = 2<br>
 输出: -1<br>
 解释: 2 不存在 nums 中因此返回 -1</p>
<p>提示：你可以假设 nums 中的所有元素是不重复的。<br>
n 将在 [1, 10000] 之间。<br>
nums 的每个元素都将在 [-9999, 9999] 之间。</p>
</blockquote>
<p><strong>这道题目的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件。</p>
<p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是  <code>while(left &lt; right)</code>  还是  <code>while(left &lt;= right)</code> ，到底是 <code>right = middle</code>  呢，还是要 <code>right = middle - 1</code>  呢？</p>
<p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在 while 寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p>
<p>写二分法，区间的定义一般为两种，左闭右闭即 [left, right]，或者左闭右开即 [left, right)。</p>
<h3 id="二分法第一种写法"><a class="markdownIt-Anchor" href="#二分法第一种写法">#</a> 二分法第一种写法</h3>
<p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是 [left, right] （这个很重要非常重要）</strong>。</p>
<p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义 target 在 [left, right] 区间，所以有如下两点：</strong></p>
<ul>
<li>while (left &lt;= right) 要使用 &lt;= ，因为 left == right 是有意义的，所以使用 &lt;=</li>
<li>if (nums [middle] &gt; target) right 要赋值为 middle - 1，因为当前这个 nums [middle] 一定不是 target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
</ul>
<p>例如在数组：1,2,3,4,7,9,10 中查找元素 2，如图所示：</p>
<p><img data-src="20210311153055723.jpg" alt="704.二分查找"></p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 定义 target 在左闭右闭的区间里，[left, right]</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 当 left==right，区间 [left, right] 依然有效，所以用 &lt;=</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">int</span> middle <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 防止溢出 等同于 (left + right)/2</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                right <span class="token operator">=</span> middle <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//target 在左区间，所以 [left, middle - 1]</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                left <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//target 在右区间，所以 [middle + 1, right]</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// nums[middle] == target</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token keyword">return</span> middle<span class="token punctuation">;</span> <span class="token comment">// 数组中找到目标值，直接返回下标</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 未找到目标值</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li>时间复杂度：O (log n)</li>
<li>空间复杂度：O (1)</li>
</ul>
<h3 id="二分法第二种写法"><a class="markdownIt-Anchor" href="#二分法第二种写法">#</a> 二分法第二种写法</h3>
<p>如果说定义 target 是在一个在左闭右开的区间里，也就是 [left, right) ，那么二分法的边界处理方式则截然不同。</p>
<p>有如下两点：</p>
<ul>
<li>while (left &lt; right)，这里使用 &lt; , 因为 left == right 在区间 [left, right) 是没有意义的</li>
<li>if (nums [middle] &gt; target) right 更新为 middle，因为当前 nums [middle] 不等于 target，去左区间继续寻找，而寻找区间是左闭右开区间，所以 right 更新为 middle，即：下一个查询区间不会去比较 nums [middle]</li>
</ul>
<p>在数组：1,2,3,4,7,9,10 中查找元素 2，如图所示：（<strong>注意和方法一的区别</strong>）</p>
<p><img data-src="20210311153123632.jpg" alt="704.二分查找1"></p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定义 target 在左闭右开的区间里，即：[left, right)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 因为 left == right 的时候，在 [left, right) 是无效的空间，所以使用 &lt;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">int</span> middle <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                right <span class="token operator">=</span> middle<span class="token punctuation">;</span> <span class="token comment">//target 在左区间，在 [left, middle) 中</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                left <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//target 在右区间，在 [middle + 1, right) 中</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// nums[middle] == target</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token keyword">return</span> middle<span class="token punctuation">;</span> <span class="token comment">// 数组中找到目标值，直接返回下标</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 未找到目标值</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li>时间复杂度：O (log n)</li>
<li>空间复杂度：O (1)</li>
</ul>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结">#</a> 总结</h3>
<p>二分法是非常重要的基础算法，为什么会对二分法一看就会，一写就废？其实主要就是对区间的定义没有理解清楚，在循环中没有始终坚持根据查找区间的定义来做边界处理。</p>
<p>区间的定义就是不变量，那么在循环中坚持根据查找区间的定义来做边界处理，就是循环不变量规则。</p>
<h3 id="相关题目"><a class="markdownIt-Anchor" href="#相关题目">#</a> = 相关题目 =</h3>
<h3 id="搜索插入位置-leetcode35"><a class="markdownIt-Anchor" href="#搜索插入位置-leetcode35">#</a> 搜索插入位置 - LeetCode35</h3>
<h3 id="在排序数组中查找元素的第一个和最后一个位置-leetcode34"><a class="markdownIt-Anchor" href="#在排序数组中查找元素的第一个和最后一个位置-leetcode34">#</a> 在排序数组中查找元素的第一个和最后一个位置 - LeetCode34</h3>
<h3 id="x的平方根-leetcode69"><a class="markdownIt-Anchor" href="#x的平方根-leetcode69">#</a> x 的平方根 - LeetCode69</h3>
<h3 id="有效的完全平方数-leetcode367"><a class="markdownIt-Anchor" href="#有效的完全平方数-leetcode367">#</a> 有效的完全平方数 - LeetCode367</h3>
<h2 id="移除元素"><a class="markdownIt-Anchor" href="#移除元素">#</a> 移除元素</h2>
<h3 id="移除元素-leetcode27"><a class="markdownIt-Anchor" href="#移除元素-leetcode27">#</a> 移除元素 - LeetCode27</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZWxlbWVudC8=">27. 移除元素 - 力扣（LeetCode）</span>)</p>
<p>给你一个数组  <code>nums</code>  和一个值  <code>val</code> ，你需要 <strong>原地</strong> 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O (1) 额外空间并 <strong>原地</strong> 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢？</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//nums 是以 “引用” 方式传递的。也就是说，不对实参作任何拷贝</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">removeElement</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 在函数里修改输入数组对于调用者是可见的。</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 根据你的函数返回的长度，它会打印出数组中 该长度范围内 的所有元素。</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote>
<p>示例 1：</p>
<p><strong>输入</strong>：nums = [3,2,2,3], val = 3<br>
<strong> 输出</strong>：2, nums = [2,2]<br>
<strong> 解释</strong>：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</p>
</blockquote>
<blockquote>
<p>示例 2：</p>
<p><strong>输入</strong>：nums = [0,1,2,2,3,0,4,2], val = 2<br>
<strong> 输出</strong>：5, nums = [0,1,4,0,3]<br>
<strong> 解释</strong>：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p>提示：</p>
<ul>
<li>0 &lt;= nums.length &lt;= 100</li>
<li>0 &lt;= nums[i] &lt;= 50</li>
<li>0 &lt;= val &lt;= 100</li>
</ul>
<p><strong>注意：数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。</strong></p>
<h3 id="暴力解法"><a class="markdownIt-Anchor" href="#暴力解法">#</a> 暴力解法</h3>
<p>两层 for 循环，一个 for 循环<strong>遍历数组元素</strong> ，第二个 for 循环<strong>更新数组</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 时间复杂度 O (n^2)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> size <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 发现需要移除的元素，就将数组集体向前移动一位</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                    nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                i<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 因为下标 i 以后的数值都向前移动了一位，所以 i 也向前移动一位</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                size<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 此时数组的大小 - 1</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> size<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="双指针法"><a class="markdownIt-Anchor" href="#双指针法">#</a> 双指针法</h3>
<p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作。</strong></p>
<p>定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 时间复杂度：O (n)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> slowIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> fastIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> fastIndex <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> fastIndex<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">!=</span> nums<span class="token punctuation">[</span>fastIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                nums<span class="token punctuation">[</span>slowIndex<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>fastIndex<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> slowIndex<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</pre></td></tr><tr><td data-num="2"></td><td><pre>* 相向双指针方法，基于元素顺序可以改变的题目描述改变了元素相对位置，确保了移动最少元素</pre></td></tr><tr><td data-num="3"></td><td><pre>* 时间复杂度：O (n)</pre></td></tr><tr><td data-num="4"></td><td><pre>* 空间复杂度：O (1)</pre></td></tr><tr><td data-num="5"></td><td><pre>*/</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">int</span> <span class="token function">removeElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">int</span> leftIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">int</span> rightIndex <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>leftIndex <span class="token operator">&lt;=</span> rightIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token comment">// 找左边等于 val 的元素</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>leftIndex <span class="token operator">&lt;=</span> rightIndex <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>leftIndex<span class="token punctuation">]</span> <span class="token operator">!=</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token operator">++</span>leftIndex<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token comment">// 找右边不等于 val 的元素</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>leftIndex <span class="token operator">&lt;=</span> rightIndex <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>rightIndex<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token operator">--</span> rightIndex<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token comment">// 将右边不等于 val 的元素覆盖左边等于 val 的元素</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>leftIndex <span class="token operator">&lt;</span> rightIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                nums<span class="token punctuation">[</span>leftIndex<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>rightIndex<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">return</span> leftIndex<span class="token punctuation">;</span>   <span class="token comment">//leftIndex 一定指向了最终数组末尾的下一个元素</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="相关题目-2"><a class="markdownIt-Anchor" href="#相关题目-2">#</a> = 相关题目 =</h3>
<h3 id="删除排序数组中的重复项-leetcode26"><a class="markdownIt-Anchor" href="#删除排序数组中的重复项-leetcode26">#</a> 删除排序数组中的重复项 - LeetCode26</h3>
<h3 id="移动零-leetcode283"><a class="markdownIt-Anchor" href="#移动零-leetcode283">#</a> 移动零 - LeetCode283</h3>
<h3 id="比较含退格的字符串-leetcode844"><a class="markdownIt-Anchor" href="#比较含退格的字符串-leetcode844">#</a> 比较含退格的字符串 - LeetCode844</h3>
<h3 id="有序数组的平方-leetcode977"><a class="markdownIt-Anchor" href="#有序数组的平方-leetcode977">#</a> 有序数组的平方 - LeetCode977</h3>
<h1 id="链表"><a class="markdownIt-Anchor" href="#链表">#</a> 链表</h1>
<h2 id="链表理论基础"><a class="markdownIt-Anchor" href="#链表理论基础">#</a> 链表理论基础</h2>
<h3 id="单链表"><a class="markdownIt-Anchor" href="#单链表">#</a> 单链表</h3>
<p>链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向 null。链表的入口节点称为链表的头结点也就是 head。</p>
<p>如图所示：</p>
<p><img data-src="20200806194529815.png" alt="链表1"></p>
<h3 id="双链表"><a class="markdownIt-Anchor" href="#双链表">#</a> 双链表</h3>
<p>单链表中的指针域只能指向节点的下一个节点。</p>
<p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p>
<p>双链表 既可以向前查询也可以向后查询。</p>
<p>如图所示：</p>
<p><img data-src="20200806194559317.png" alt="链表2"></p>
<h3 id="循环链表"><a class="markdownIt-Anchor" href="#循环链表">#</a> 循环链表</h3>
<p>顾名思义，就是链表首尾相连。循环链表可以用来解决约瑟夫环问题。</p>
<h3 id="链表的存储方式"><a class="markdownIt-Anchor" href="#链表的存储方式">#</a> 链表的存储方式</h3>
<p>数组是在内存中是连续分布的，但是链表在内存中不是连续分布的。链表是通过指针域的指针链接在内存中各个节点。所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，<strong>分配机制取决于操作系统的内存管理</strong>。</p>
<h3 id="链表的定义"><a class="markdownIt-Anchor" href="#链表的定义">#</a> 链表的定义</h3>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 单链表</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>  <span class="token comment">// 节点上存储的元素</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    ListNode <span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment">// 指向下一个节点的指针</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token comment">// 节点的构造函数</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>不定义构造函数行不行？</p>
<p>答案是可以的，C++ 默认生成一个构造函数。但是这个构造函数不会初始化任何成员变量，下面举两个例子：</p>
<p>通过自己定义构造函数初始化节点：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>ListNode<span class="token operator">*</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>使用默认构造函数初始化节点：</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>ListNode<span class="token operator">*</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>head<span class="token operator">-></span>val <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值。</p>
<h2 id="移除链表元素-leetcode203"><a class="markdownIt-Anchor" href="#移除链表元素-leetcode203">#</a> 移除链表元素 - LeetCode203</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtbGlua2VkLWxpc3QtZWxlbWVudHMv">203. 移除链表元素 - 力扣（LeetCode）</span></p>
<blockquote>
<p>给你一个链表的头节点  <code>head</code>  和一个整数  <code>val</code>  ，请你删除链表中所有满足  <code>Node.val == val</code>  的节点，并返回 <strong>新的头节点</strong></p>
<p>示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]</p>
<p>示例 2： 输入：head = [], val = 1 输出：[]</p>
<p>示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]</p>
<p><strong>提示：</strong></p>
<ul>
<li>列表中的节点数目在范围  <code>[0, 104]</code>  内</li>
<li><code>1 &lt;= Node.val &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 50</code></li>
</ul>
</blockquote>
<ul>
<li><strong>直接使用原来的链表来进行删除操作。</strong></li>
</ul>
<p><img data-src="D:%5CBlog%5Csource_posts%5C%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%5C2021031609544922.png" alt="203_链表删除元素3"></p>
<p>移除头结点和移除其他节点的操作是不一样的，因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。</p>
<p>所以头结点如何移除呢，其实只要将头结点向后移动一位就可以，这样就从链表中移除了一个头结点，然后将原头结点从内存中删掉。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    ListNode<span class="token operator">*</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 删除头结点</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> head<span class="token operator">-></span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意这里不是 if</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            ListNode<span class="token operator">*</span> tmp <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">delete</span> tmp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 删除非头结点</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-></span>next<span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-></span>next<span class="token operator">-></span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                ListNode<span class="token operator">*</span> tmp <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                cur<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token keyword">delete</span> tmp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">return</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul>
<li><strong>设置一个虚拟头结点在进行删除操作。</strong></li>
</ul>
<p>可以以一种统一的逻辑来移除链表的节点。<strong>设置一个虚拟头结点</strong>，这样原链表的所有节点就都可以按照统一的方式进行移除了。</p>
<p><img data-src="20210316095619221.png" alt="203_链表删除元素6"></p>
<p>这里来给链表添加一个虚拟头结点为新的头结点，此时要移除这个旧头结点元素 1。</p>
<p>最后在题目中，return 头结点的时候，别忘了  <code>return dummyNode-&gt;next;</code> ， 这才是新的头结点</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    ListNode<span class="token operator">*</span> <span class="token function">removeElements</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        ListNode<span class="token operator">*</span> dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置一个虚拟头结点</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        dummyHead<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 将虚拟头结点指向 head，这样方面后面做删除操作</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>next<span class="token operator">-></span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                ListNode<span class="token operator">*</span> tmp <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                cur<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token keyword">delete</span> tmp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        head <span class="token operator">=</span> dummyHead<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">delete</span> dummyHead<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="设计链表-leetcode707"><a class="markdownIt-Anchor" href="#设计链表-leetcode707">#</a> 设计链表 - LeetCode707</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZXNpZ24tbGlua2VkLWxpc3Qv">707. 设计链表 - 力扣（LeetCode）</span></p>
<blockquote>
<p>在链表类中实现这些功能：</p>
<ul>
<li>get (index)：获取链表中第 index 个节点的值。如果索引无效，则返回 - 1。</li>
<li>addAtHead (val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>
<li>addAtTail (val)：将值为 val 的节点追加到链表的最后一个元素。</li>
<li>addAtIndex (index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果 index 小于 0，则在头部插入节点。</li>
<li>deleteAtIndex (index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li>
</ul>
<p>示例：</p>
<p>输入<br>
 [“MyLinkedList”, “addAtHead”, “addAtTail”, “addAtIndex”, “get”, “deleteAtIndex”, “get”]<br>
[[], [1], [3], [1, 2], [1], [1], [1]]<br>
 输出<br>
 [null, null, null, null, 2, null, 3]</p>
<p>解释<br>
 MyLinkedList myLinkedList = new MyLinkedList ();<br>
myLinkedList.addAtHead(1);<br>
myLinkedList.addAtTail(3);<br>
myLinkedList.addAtIndex (1, 2);    // 链表变为 1-&gt;2-&gt;3<br>
myLinkedList.get (1);              // 返回 2<br>
myLinkedList.deleteAtIndex (1);    // 现在，链表变为 1-&gt;3<br>
myLinkedList.get (1);              // 返回 3</p>
<p>提示：</p>
<p>0 &lt;= index, val &lt;= 1000<br>
 请不要使用内置的 LinkedList 库。<br>
调用 get、addAtHead、addAtTail、addAtIndex 和 deleteAtIndex 的次数不超过 2000 。</p>
</blockquote>
<p>这道题目设计链表的五个接口：</p>
<ul>
<li>获取链表第 index 个节点的数值</li>
<li>在链表的最前面插入一个节点</li>
<li>在链表的最后面插入一个节点</li>
<li>在链表第 index 个节点前面插入一个节点</li>
<li>删除链表的第 index 个节点</li>
</ul>
<p>这五个接口，已经覆盖了链表的常见操作</p>
<p><strong>链表操作的两种方式：</strong></p>
<ol>
<li>直接使用原来的链表来进行操作。</li>
<li>设置一个虚拟头结点在进行操作。</li>
</ol>
<p>下面采用的设置一个虚拟头结点（这样更方便一些，看代码就会感受出来）。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">MyLinkedList</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 定义链表节点结构体</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">LinkedNode</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">int</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        LinkedNode<span class="token operator">*</span> next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">LinkedNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 初始化链表</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">MyLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        _dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">LinkedNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        _size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">// 获取到第 index 个节点数值，如果 index 是非法数值直接返回 - 1， 注意 index 是从 0 开始的，第 0 个节点就是头结点</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> <span class="token punctuation">(</span>_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        LinkedNode<span class="token operator">*</span> cur <span class="token operator">=</span> _dummyHead<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>index<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 如果 --index 就会陷入死循环</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">return</span> cur<span class="token operator">-></span>val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token comment">// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">addAtHead</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        LinkedNode<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">LinkedNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        newNode<span class="token operator">-></span>next <span class="token operator">=</span> _dummyHead<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        _dummyHead<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        _size<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token comment">// 在链表最后面添加一个节点</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">addAtTail</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        LinkedNode<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">LinkedNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        LinkedNode<span class="token operator">*</span> cur <span class="token operator">=</span> _dummyHead<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        cur<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        _size<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="46"></td><td><pre></pre></td></tr><tr><td data-num="47"></td><td><pre>    <span class="token comment">// 在第 index 个节点之前插入一个新节点，例如 index 为 0，那么新插入的节点为链表的新头节点。</span></pre></td></tr><tr><td data-num="48"></td><td><pre>    <span class="token comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></pre></td></tr><tr><td data-num="49"></td><td><pre>    <span class="token comment">// 如果 index 大于链表的长度，则返回空</span></pre></td></tr><tr><td data-num="50"></td><td><pre>    <span class="token comment">// 如果 index 小于 0，则在头部插入节点</span></pre></td></tr><tr><td data-num="51"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">addAtIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="52"></td><td><pre></pre></td></tr><tr><td data-num="53"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">></span> _size<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        </pre></td></tr><tr><td data-num="55"></td><td><pre>        LinkedNode<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">LinkedNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>        LinkedNode<span class="token operator">*</span> cur <span class="token operator">=</span> _dummyHead<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>index<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="58"></td><td><pre>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="59"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>        newNode<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="61"></td><td><pre>        cur<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="62"></td><td><pre>        _size<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="64"></td><td><pre></pre></td></tr><tr><td data-num="65"></td><td><pre>    <span class="token comment">// 删除第 index 个节点，如果 index 大于等于链表的长度，直接 return，注意 index 是从 0 开始的</span></pre></td></tr><tr><td data-num="66"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">deleteAtIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="67"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> _size <span class="token operator">||</span> index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="68"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="69"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="70"></td><td><pre>        LinkedNode<span class="token operator">*</span> cur <span class="token operator">=</span> _dummyHead<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="71"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>index<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="72"></td><td><pre>            cur <span class="token operator">=</span> cur <span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="73"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="74"></td><td><pre>        LinkedNode<span class="token operator">*</span> tmp <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="75"></td><td><pre>        cur<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="76"></td><td><pre>        <span class="token keyword">delete</span> tmp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="77"></td><td><pre>        _size<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="78"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="79"></td><td><pre></pre></td></tr><tr><td data-num="80"></td><td><pre>    <span class="token comment">// 打印链表</span></pre></td></tr><tr><td data-num="81"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">printLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="82"></td><td><pre>        LinkedNode<span class="token operator">*</span> cur <span class="token operator">=</span> _dummyHead<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="83"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="84"></td><td><pre>            cout <span class="token operator">&lt;&lt;</span> cur<span class="token operator">-></span>next<span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="85"></td><td><pre>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="86"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="87"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="88"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="89"></td><td><pre><span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="90"></td><td><pre>    <span class="token keyword">int</span> _size<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="91"></td><td><pre>    LinkedNode<span class="token operator">*</span> _dummyHead<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="92"></td><td><pre></pre></td></tr><tr><td data-num="93"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="翻转链表-leetcode206"><a class="markdownIt-Anchor" href="#翻转链表-leetcode206">#</a> 翻转链表 - LeetCode206</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLWxpbmtlZC1saXN0Lw==">206. 反转链表 - 力扣（LeetCode）</span></p>
<p>给你单链表的头节点  <code>head</code>  ，请你反转链表，并返回反转后的链表。</p>
<p>示例：输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是  <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p>** 进阶：** 链表可以选用迭代或递归方式完成反转。</p>
<h3 id="双指针法-2"><a class="markdownIt-Anchor" href="#双指针法-2">#</a> 双指针法</h3>
<p>首先定义一个 <code>cur</code>  指针，指向头节点，再定义一个 <code>pre</code>  指针，初始化为 <code>null</code> 。</p>
<p>然后开始反转，先把 <code>cur-&gt;next</code>  节点用 <code>tmp</code>  指针保存一下，也就是保存一下这个节点。因为接下来要改变 <code>cur-&gt;next</code>  的指向，将 <code>cur-&gt;next</code>  指向 <code>pre</code> ，此时已经反转了第一个节点了。</p>
<p>接下来，就是循环走如下代码逻辑，继续移动 pre 和 cur 指针。</p>
<p>最后 cur 指针已经指向 null，循环结束，连边反转完毕。此时，return pre 指针就可以了，pre 指针指向了新的头节点。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        ListNode<span class="token operator">*</span> temp<span class="token punctuation">;</span>     <span class="token comment">// 保存 cur 的下一个节点</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        ListNode<span class="token operator">*</span> pre <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            temp <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token comment">// 保存一下 cur 的下一个节点，因为接下来要改变 cur->next</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            cur<span class="token operator">-></span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>  <span class="token comment">// 翻转操作</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token comment">// 更新 pre 和 cur 指针</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            cur <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span> pre<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="递归法"><a class="markdownIt-Anchor" href="#递归法">#</a> 递归法</h3>
<p>递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当 cur 为空的时候循环结束，不断将 cur 指向 pre 的过程。</p>
<p>关键是初始化的地方，可以看到双指针法中初始化 cur = head，pre = NULL，在递归法中可以从如下代码看出初始化的逻辑也是一样的，只不过写法变了。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    ListNode<span class="token operator">*</span> <span class="token function">reverse</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> pre<span class="token punctuation">,</span>ListNode<span class="token operator">*</span> cur<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> pre<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        ListNode<span class="token operator">*</span> temp <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        cur<span class="token operator">-></span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// pre = cur;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// cur = temp;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">reverse</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 和双指针法初始化是一样的逻辑</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// ListNode* cur = head;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// ListNode* pre = NULL;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们可以发现，上面的递归写法和双指针法实质上都是从前往后翻转指针指向，其实还有另外一种与双指针法不同思路的递归写法：从后往前翻转指针指向。</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 边缘条件判断</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        </pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 递归调用，翻转第二个节点开始往后的链表</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        ListNode <span class="token operator">*</span>last <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 翻转头节点与第二个节点的指向</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        head<span class="token operator">-></span>next<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 此时的 head 节点为尾节点，next 需要指向 NULL</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        head<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span> last<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="使用虚拟头结点解决链表翻转"><a class="markdownIt-Anchor" href="#使用虚拟头结点解决链表翻转">#</a> 使用虚拟头结点解决链表翻转</h3>
<p>使用虚拟头结点，通过头插法实现链表的翻转（不需要栈）</p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 迭代方法：增加虚头结点，使用头插法实现链表翻转</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> ListNode <span class="token function">reverseList1</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 创建虚头结点</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    ListNode dumpyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    dumpyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 遍历所有节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    ListNode cur <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        ListNode temp <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 头插法</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> dumpyHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        dumpyHead<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        cur <span class="token operator">=</span> temp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">return</span> dumpyHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="使用栈解决反转链表的问题"><a class="markdownIt-Anchor" href="#使用栈解决反转链表的问题">#</a> 使用栈解决反转链表的问题</h3>
<ul>
<li>首先将所有的结点入栈</li>
<li>然后创建一个虚拟虚拟头结点，让 cur 指向虚拟头结点。然后开始循环出栈，每出来一个元素，就把它加入到以虚拟头结点为头结点的链表当中，最后返回即可。</li>
</ul>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 如果链表为空，则返回空</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 如果链表中只有只有一个元素，则直接返回</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 创建栈 每一个结点都入栈</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    Stack<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">Stack</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    ListNode cur <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 创建一个虚拟头结点</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    ListNode pHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    cur <span class="token operator">=</span> pHead<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        ListNode node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token comment">// 最后一个元素的 next 要赋值为空</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    cur<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">return</span> pHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>采用这种方法需要注意一点。就是当整个出栈循环结束以后，cur 正好指向原来链表的第一个结点，而此时结点 1 中的 next 指向的是结点 2，因此最后还需要 <code>cur.next = null</code></p>
<h2 id="两两交换链表中的节点-leetcode24"><a class="markdownIt-Anchor" href="#两两交换链表中的节点-leetcode24">#</a> 两两交换链表中的节点 - LeetCode24</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zd2FwLW5vZGVzLWluLXBhaXJzLw==">24. 两两交换链表中的节点 - 力扣（LeetCode）</span></p>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p>初始时，cur 指向虚拟头结点，然后进行如下三步：</p>
<p><img data-src="2023042401.png" alt="img"></p>
<p>操作之后，链表如下：</p>
<p><img data-src="2023042402.png" alt="img"></p>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    ListNode<span class="token operator">*</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        ListNode<span class="token operator">*</span> dummyHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置一个虚拟头结点</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        dummyHead<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 将虚拟头结点指向 head，这样方面后面做删除操作</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> dummyHead<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-></span>next<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            ListNode<span class="token operator">*</span> tmp <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// 记录临时节点</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            ListNode<span class="token operator">*</span> tmp1 <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// 记录临时节点</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>            cur<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token comment">// 步骤一</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            cur<span class="token operator">-></span>next<span class="token operator">-></span>next <span class="token operator">=</span> tmp<span class="token punctuation">;</span>          <span class="token comment">// 步骤二</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            cur<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token operator">-></span>next <span class="token operator">=</span> tmp1<span class="token punctuation">;</span>   <span class="token comment">// 步骤三</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">//cur 移动两位，准备下一轮交换</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> dummyHead<span class="token operator">-></span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h1 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表">#</a> 哈希表</h1>
<h2 id="哈希表理论基础"><a class="markdownIt-Anchor" href="#哈希表理论基础">#</a> 哈希表理论基础</h2>
<h3 id="哈希表-2"><a class="markdownIt-Anchor" href="#哈希表-2">#</a> 哈希表</h3>
<p>Hash table，译为哈希表或散列表</p>
<blockquote>
<p>哈希表是根据关键码的值而直接进行访问的数据结构。</p>
</blockquote>
<p>实际数组就是一张哈希表。哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：</p>
<p><img data-src="20210104234805168.png" alt="哈希表1"></p>
<p>哈希表能解决什么问题？</p>
<ul>
<li><strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></li>
</ul>
<p>例如要查询一个名字是否在这所学校里。</p>
<p>要枚举的话时间复杂度是 O (n)，但如果使用哈希表的话， 只需要 O (1) 就可以做到。</p>
<p>我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。</p>
<p>将学生姓名映射到哈希表上就涉及到了<strong> hash function ，也就是哈希函数</strong>。</p>
<h3 id="哈希函数"><a class="markdownIt-Anchor" href="#哈希函数">#</a> 哈希函数</h3>
<p>哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。</p>
<p>哈希函数如下图所示，通过 hashCode 把名字转化为数值，一般 hashcode 是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p>
<p><img data-src="D:%5CBlog%5Csource_posts%5C%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%5C2021010423484818.png" alt="哈希表2"></p>
<p>如果 hashCode 得到的数值大于哈希表的大小了，也就是大于 tableSize 了，怎么办？</p>
<p>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个<strong>取模</strong>的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。</p>
<p>此时问题又来了，哈希表我们刚刚说过，就是一个数组。</p>
<p>如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。</p>
<p>接下来<strong>哈希碰撞</strong>登场</p>
<p>如图所示，小李和小王都映射到了索引下标 1 的位置，<strong>这一现象叫做哈希碰撞</strong>。</p>
<p><img data-src="2021010423494884.png" alt="哈希表3"></p>
<p>一般哈希碰撞有两种解决方法， <strong>拉链法</strong>和<strong>线性探测法</strong>。</p>
<ul>
<li>
<p>拉链法</p>
<p>刚刚小李和小王在索引 1 的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了</p>
<p><img data-src="20210104235015226.png" alt="哈希表4"></p>
<p>（数据规模是 dataSize， 哈希表的大小为 tableSize）</p>
<p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p>
</li>
<li>
<p>线性探测法</p>
<p>使用线性探测法，一定要保证 tableSize 大于 dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p>
<p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求 tableSize 一定要大于 dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：</p>
<p><img data-src="20210104235109950.png" alt="哈希表5"></p>
</li>
</ul>
<h3 id="常见的三种哈希结构"><a class="markdownIt-Anchor" href="#常见的三种哈希结构">#</a> 常见的三种哈希结构</h3>
<p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p>
<ul>
<li>array（数组）</li>
<li>set（集合）</li>
<li>map（映射）</li>
</ul>
<p>在 C++ 中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>std::unordered_set 底层实现为哈希表，std::set 和 std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以 key 值是有序的，但 key 不可以修改，改动 key 值会导致整棵树的错乱，所以只能删除和增加。</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::map</td>
<td>红黑树</td>
<td>key 有序</td>
<td>key 不可重复</td>
<td>key 不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key 有序</td>
<td>key 可重复</td>
<td>key 不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key 无序</td>
<td>key 不可重复</td>
<td>key 不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>std::unordered_map 底层实现为哈希表，std::map 和 std::multimap 的底层实现是红黑树。同理，std::map 和 std::multimap 的 key 也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p>
<p>当我们要使用集合来解决哈希问题的时候，优先使用 unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用 set，如果要求不仅有序还要有重复数据的话，那么就用 multiset。</p>
<p>那么再来看一下 map ，在 map 是一个 key value 的数据结构，map 中，对 key 是有限制，对 value 没有限制的，因为 key 的存储方式使用红黑树实现的。</p>
<p>其他语言例如：java 里的 HashMap ，TreeMap 都是一样的原理。可以灵活贯通。</p>
<p>虽然 std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即 key 和 value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map 也是一样的道理。</p>
<h1 id="字符串"><a class="markdownIt-Anchor" href="#字符串">#</a> 字符串</h1>
<h1 id="栈与队列"><a class="markdownIt-Anchor" href="#栈与队列">#</a> 栈与队列</h1>
<h1 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树">#</a> 二叉树</h1>
<h2 id="二叉树理论基础"><a class="markdownIt-Anchor" href="#二叉树理论基础">#</a> 二叉树理论基础</h2>
<h3 id="二叉树的种类"><a class="markdownIt-Anchor" href="#二叉树的种类">#</a> 二叉树的种类</h3>
<ul>
<li>
<p>满二叉树</p>
<p>如果一棵二叉树只有度为 0 的结点和度为 2 的结点，并且度为 0 的结点在同一层上，则这棵二叉树为满二叉树。</p>
<p><img data-src="20200806185805576.png" alt="img"></p>
<p>如图，这棵二叉树为满二叉树，也可以说深度为 k，有 2^k-1 个节点的二叉树。</p>
</li>
<li>
<p>完全二叉树</p>
<p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1) 个节点。</p>
<p><img data-src="20200920221638903.png" alt="img"></p>
<p><strong>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</strong></p>
</li>
<li>
<p>二叉搜索树</p>
<p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
<p>下面这两棵树都是搜索树</p>
<p><img data-src="20200806190304693.png" alt="img"></p>
</li>
<li>
<p>平衡二叉搜索树</p>
<p>又被称为 AVL（Adelson-Velsky and Landis）树，具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</p>
<p><img data-src="20200806190511967.png" alt="img"></p>
<p>最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了 1。</p>
<p><strong>C++ 中 map、set、multimap，multiset 的底层实现都是平衡二叉搜索树</strong>，所以 map、set 的增删操作时间时间复杂度是 logn，注意 unordered_map、unordered_set，unordered_map、unordered_set 底层实现是哈希表。</p>
<p><strong>一定要知道常用的容器底层都是如何实现的，最基本的就是 map、set 等</strong></p>
</li>
</ul>
<h3 id="二叉树的存储方式"><a class="markdownIt-Anchor" href="#二叉树的存储方式">#</a> 二叉树的存储方式</h3>
<p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p>
<p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p>
<p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。</p>
<p>链式存储如图：</p>
<p><img data-src="2020092019554618.png" alt="img"></p>
<p>顺序存储如图：</p>
<p><img data-src="20200920200429452.png" alt="img"></p>
<p>用数组来存储二叉树如何遍历的呢？</p>
<p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p>
<p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p>
<h3 id="二叉树的遍历方式"><a class="markdownIt-Anchor" href="#二叉树的遍历方式">#</a> 二叉树的遍历方式</h3>
<p>二叉树主要有两种遍历方式：</p>
<ol>
<li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li>
<li>广度优先遍历：一层一层的去遍历。</li>
</ol>
<p><strong>这两种遍历是图论中最基本的两种遍历方式</strong></p>
<p>那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p>
<ul>
<li>深度优先遍历
<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
</li>
<li>广度优先遍历
<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ul>
<p>在深度优先遍历中：有三个顺序，前中后序遍历</p>
<p><strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，记住前中后序指的就是中间节点的位置就可以了。</p>
<p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p>
<ul>
<li>前序遍历：中左右</li>
<li>中序遍历：左中右</li>
<li>后序遍历：左右中</li>
</ul>
<p><img data-src="20200806191109896.png" alt="img"></p>
<p>最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。</p>
<p><strong>之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。</p>
<p>而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p>
<h3 id="二叉树的定义"><a class="markdownIt-Anchor" href="#二叉树的定义">#</a> 二叉树的定义</h3>
<figure class="highlight cpp"><figcaption data-lang="C++"><span>p</span></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    TreeNode <span class="token operator">*</span>left<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    TreeNode <span class="token operator">*</span>right<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>二叉树的定义和链表是差不多的，相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子。</p>
<h2 id="二叉树的递归遍历"><a class="markdownIt-Anchor" href="#二叉树的递归遍历">#</a> 二叉树的递归遍历</h2>

      <div class="tags">
          <a href="/tags/C/" rel="tag"><i class="ic i-tag"></i> C++</a>
          <a href="/tags/STL/" rel="tag"><i class="ic i-tag"></i> STL</a>
          <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="ic i-tag"></i> 算法</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2023-05-10 11:20:11" itemprop="dateModified" datetime="2023-05-10T11:20:11+08:00">2023-05-10</time>
  </span>
  <span id="2023/03/30/算法进阶/" class="item leancloud_visitors" data-flag-title="算法进阶" title="阅读次数">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">阅读次数</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">次</span>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>AdventureYX <i class="ic i-at"><em>@</em></i>
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="https://adventure-yx.github.io/2023/03/30/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/" title="算法进阶">https://adventure-yx.github.io/2023/03/30/算法进阶/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aC1DTg=="><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2023/03/26/QML&QtQuick/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.picgo.net&#x2F;2023&#x2F;04&#x2F;02&#x2F;sky-134a7b41dbac28cfdf.jpeg" title="QML &amp; Qt Quick">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> Qt</span>
  <h3>QML & Qt Quick</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2023/04/02/C++11/" itemprop="url" rel="next" data-background-image="&#x2F;2023&#x2F;04&#x2F;02&#x2F;C++11&#x2F;sky-15.jpg" title="C++11&#x2F;14&#x2F;17">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> C++</span>
  <h3>C++11/14/17</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text"> 排序算法总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text"> 冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text"> 快速排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text"> 算法性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text"> 时间复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 什么是时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7o"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 什么是大 O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E8%A7%84%E6%A8%A1%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">2.1.3.</span> <span class="toc-text"> 不同数据规模的差异</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text"> 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">3.1.</span> <span class="toc-text"> 二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-leetcode704"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 二分查找 - LeetCode704</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 二分法第一种写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%86%99%E6%B3%95"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 二分法第二种写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.1.4.</span> <span class="toc-text"> 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="toc-number">3.1.5.</span> <span class="toc-text"> &#x3D; 相关题目 &#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-leetcode35"><span class="toc-number">3.1.6.</span> <span class="toc-text"> 搜索插入位置 - LeetCode35</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-leetcode34"><span class="toc-number">3.1.7.</span> <span class="toc-text"> 在排序数组中查找元素的第一个和最后一个位置 - LeetCode34</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-leetcode69"><span class="toc-number">3.1.8.</span> <span class="toc-text"> x 的平方根 - LeetCode69</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-leetcode367"><span class="toc-number">3.1.9.</span> <span class="toc-text"> 有效的完全平方数 - LeetCode367</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">3.2.</span> <span class="toc-text"> 移除元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-leetcode27"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 移除元素 - LeetCode27</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95"><span class="toc-number">3.2.2.</span> <span class="toc-text"> 暴力解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text"> 双指针法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE-2"><span class="toc-number">3.2.4.</span> <span class="toc-text"> &#x3D; 相关题目 &#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-leetcode26"><span class="toc-number">3.2.5.</span> <span class="toc-text"> 删除排序数组中的重复项 - LeetCode26</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E9%9B%B6-leetcode283"><span class="toc-number">3.2.6.</span> <span class="toc-text"> 移动零 - LeetCode283</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-leetcode844"><span class="toc-number">3.2.7.</span> <span class="toc-text"> 比较含退格的字符串 - LeetCode844</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-leetcode977"><span class="toc-number">3.2.8.</span> <span class="toc-text"> 有序数组的平方 - LeetCode977</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text"> 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">4.1.</span> <span class="toc-text"> 链表理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 单链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 双链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">4.1.3.</span> <span class="toc-text"> 循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.4.</span> <span class="toc-text"> 链表的存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.5.</span> <span class="toc-text"> 链表的定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0-leetcode203"><span class="toc-number">4.2.</span> <span class="toc-text"> 移除链表元素 - LeetCode203</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8-leetcode707"><span class="toc-number">4.3.</span> <span class="toc-text"> 设计链表 - LeetCode707</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-leetcode206"><span class="toc-number">4.4.</span> <span class="toc-text"> 翻转链表 - LeetCode206</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-2"><span class="toc-number">4.4.1.</span> <span class="toc-text"> 双指针法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B3%95"><span class="toc-number">4.4.2.</span> <span class="toc-text"> 递归法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E5%A4%B4%E7%BB%93%E7%82%B9%E8%A7%A3%E5%86%B3%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC"><span class="toc-number">4.4.3.</span> <span class="toc-text"> 使用虚拟头结点解决链表翻转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%88%E8%A7%A3%E5%86%B3%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.4.</span> <span class="toc-text"> 使用栈解决反转链表的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-leetcode24"><span class="toc-number">4.5.</span> <span class="toc-text"> 两两交换链表中的节点 - LeetCode24</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text"> 哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">5.1.</span> <span class="toc-text"> 哈希表理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-2"><span class="toc-number">5.1.1.</span> <span class="toc-text"> 哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.2.</span> <span class="toc-text"> 哈希函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.3.</span> <span class="toc-text"> 常见的三种哈希结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.</span> <span class="toc-text"> 字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text"> 栈与队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text"> 二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">8.1.</span> <span class="toc-text"> 二叉树理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">8.1.1.</span> <span class="toc-text"> 二叉树的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">8.1.2.</span> <span class="toc-text"> 二叉树的存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">8.1.3.</span> <span class="toc-text"> 二叉树的遍历方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">8.1.4.</span> <span class="toc-text"> 二叉树的定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">8.2.</span> <span class="toc-text"> 二叉树的递归遍历</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li><a href="/2023/02/24/C++Study/" rel="bookmark" title="C++ Study">C++ Study</a></li><li><a href="/2023/03/05/C++%E9%9D%A2%E7%BB%8F/" rel="bookmark" title="C++面经">C++面经</a></li><li><a href="/2023/03/10/STL/" rel="bookmark" title="STL">STL</a></li><li><a href="/2023/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="bookmark" title="设计模式">设计模式</a></li><li class="active"><a href="/2023/03/30/%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6/" rel="bookmark" title="算法进阶">算法进阶</a></li><li><a href="/2023/04/02/C++11/" rel="bookmark" title="C++11/14/17">C++11/14/17</a></li><li><a href="/2023/05/25/MFC/" rel="bookmark" title="MFC">MFC</a></li><li><a href="/2023/06/02/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8CVisual%20Studio%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86/" rel="bookmark" title="字符集和Visual Studio中的字符处理">字符集和Visual Studio中的字符处理</a></li><li><a href="/2023/06/05/C++Boost%E5%BA%93%20%E5%87%BD%E6%95%B0%E4%B8%8E%E5%9B%9E%E8%B0%83/" rel="bookmark" title="C++Boost库 函数与回调">C++Boost库 函数与回调</a></li><li><a href="/2023/06/06/C++Boost%E5%BA%93%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="bookmark" title="C++Boost库 内存管理">C++Boost库 内存管理</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="AdventureYX"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">AdventureYX</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">22</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">6</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">14</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FkdmVudHVyZS15eA==" title="https:&#x2F;&#x2F;github.com&#x2F;Adventure-yx"><i class="ic i-github"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2023/03/26/QML&QtQuick/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2023/04/02/C++11/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/DataBase/" title="分类于 DataBase">DataBase</a>
</div>

    <span><a href="/2023/03/08/CMU15-445%20Project1/" title="CMU15-445：Project#1 Buffer Pool">CMU15-445：Project#1 Buffer Pool</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Linux/" title="分类于 Linux">Linux</a>
</div>

    <span><a href="/2023/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%97%E5%A4%A72023%EF%BC%89/" title="操作系统（南大2023）">操作系统（南大2023）</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Qt/" title="分类于 Qt">Qt</a>
</div>

    <span><a href="/2023/04/20/qtchat/" title="基于Qt框架实现网络聊天室">基于Qt框架实现网络聊天室</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/03/05/C++%E9%9D%A2%E7%BB%8F/" title="C++面经">C++面经</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Qt/" title="分类于 Qt">Qt</a>
</div>

    <span><a href="/2023/03/26/QML&QtQuick/" title="QML &amp; Qt Quick">QML & Qt Quick</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/02/24/C++Study/" title="C++ Study">C++ Study</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/Qt/" title="分类于 Qt">Qt</a>
</div>

    <span><a href="/2023/05/04/showimg/" title="基于Qt的图片浏览器">基于Qt的图片浏览器</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/XML/" title="分类于 XML">XML</a>
</div>

    <span><a href="/2023/05/29/XML/" title="XML &amp; TinyXML">XML & TinyXML</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/C/" title="分类于 C++">C++</a>
</div>

    <span><a href="/2023/06/06/C++Boost%E5%BA%93%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="C++Boost库 内存管理">C++Boost库 内存管理</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/DataBase/" title="分类于 DataBase">DataBase</a>
</div>

    <span><a href="/2023/03/06/CMU15-445%20Project0/" title="CMU15-445 Project#0 字典树trie">CMU15-445 Project#0 字典树trie</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2022 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">AdventureYX @ Adventure</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2023/03/30/算法进阶/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
