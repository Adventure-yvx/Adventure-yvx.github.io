{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"linux\" category",
    "description": "",
    "home_page_url": "https://adventure-yx.github.io",
    "items": [
        {
            "id": "https://adventure-yx.github.io/2023/03/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%97%E5%A4%A72023%EF%BC%89/",
            "url": "https://adventure-yx.github.io/2023/03/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8D%97%E5%A4%A72023%EF%BC%89/",
            "title": "操作系统（南大2023）",
            "date_published": "2023-03-09T09:56:33.000Z",
            "content_html": "<p>南京大学 2022《操作系统：设计与实现》- 蒋炎岩</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUNtNHkxZDdVcg==\">https://www.bilibili.com/video/BV1Cm4y1d7Ur</span></p>\n<h1 id=\"操作系统概述\"><a class=\"markdownIt-Anchor\" href=\"#操作系统概述\">#</a> 操作系统概述</h1>\n<h2 id=\"什么是操作系统\"><a class=\"markdownIt-Anchor\" href=\"#什么是操作系统\">#</a> 什么是操作系统？</h2>\n<blockquote>\n<p>Operating System: A body of software, in fact, that is responsible for making it easy to run programs(even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that.     ——《OSTEP》</p>\n</blockquote>\n<p>操作系统发展历程：……</p>\n<p><strong>今天的操作系统：通过 “虚拟化硬件” 资源为程序运行提供服务的软件</strong></p>\n<ul>\n<li>更复杂的的处理器和内存\n<ul>\n<li>非对称对处理器（ARM big.LITTLE；Intel P/E-cores）</li>\n<li>Non-uniform Memory Access (NUMA)</li>\n<li>更多的硬件机制</li>\n</ul>\n</li>\n<li>更多的设备和资源\n<ul>\n<li>网卡、SSD、GPU、FPGA……</li>\n</ul>\n</li>\n<li>复杂的应用需求和应用环境\n<ul>\n<li>服务器、个人电脑、智能手机、手环、IoT……</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"理解操作系统\"><a class=\"markdownIt-Anchor\" href=\"#理解操作系统\">#</a> 理解操作系统</h2>\n<p>三个根本问题：</p>\n<ol>\n<li>操作系统服务谁？\n<ul>\n<li><strong>程序 = 状态机</strong></li>\n<li>本课程涉及：多线程 Linux 应用程序</li>\n</ul>\n</li>\n<li>操作系统为程序提供什么服务？（设计 / 应用视角）\n<ul>\n<li><strong>操作系统 = 对象 + API</strong></li>\n<li>本课程涉及：POSIX + 部分 Linux 特性</li>\n</ul>\n</li>\n<li>如何实现操作系统提供的服务（实现 / 硬件视角）？\n<ul>\n<li><strong>操作系统 = C 程序</strong>\n<ul>\n<li>完成初始化后就成为 interrupt/trap/fault handler</li>\n</ul>\n</li>\n<li>本课程涉及：xv6，自制迷你操作系统</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"应用视角的操作系统\"><a class=\"markdownIt-Anchor\" href=\"#应用视角的操作系统\">#</a> 应用视角的操作系统</h1>\n<p><strong>背景回顾</strong>：操作系统有三条主线：“软件 (应用)”、“硬件 (计算机)”、“操作系统 (软件直接访问硬件带来麻烦太多而引入的中间件)”。想要理解操作系统，对操作系统的服务对象 (应用程序) 有精确的理解是必不可少的。</p>\n<p>操作系统 = 对象 + API (应用视角 / 设计) = C 程序 (硬件视角 / 实现)</p>\n<p><strong>本讲内容</strong>：指令序列和高级语言的状态机模型；回答以下问题：</p>\n<ul>\n<li>什么是软件 (程序)？</li>\n<li>如何在操作系统上构造最小 / 一般 / 图形界面应用程序？</li>\n<li>什么是编译器？编译器把一段程序翻译成什么样的指令序列才算 “正确”？</li>\n</ul>\n<h2 id=\"什么是程序源代码视角\"><a class=\"markdownIt-Anchor\" href=\"#什么是程序源代码视角\">#</a> 什么是程序（源代码视角）</h2>\n<p><strong>C 程序的状态机模型</strong>（语义，semantics）</p>\n<ul>\n<li>状态 = 堆 + 栈</li>\n<li>初始状态 = main 的第一条语句</li>\n<li>迁移 = 执行一条简单语句\n<ul>\n<li>任何 C 程序都可以改写成 “非复合语句” 的 C 代码</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>这还只是粗浅的理解</p>\n<p>任何真正的理解都应该落实到可以执行的代码</p>\n</blockquote>\n<ul>\n<li>状态 = stack frame 的列表（每个 frame 有 PC）+ 全局变量</li>\n<li>初始状态 = main (argc, argv), 全局变量初始化</li>\n<li>迁移 = 执行 top stack frame PC 的语句；PC++（PC 是计数器，存下一条指令地址）\n<ul>\n<li>函数调用 = push frame (frame.PC = 入口)</li>\n<li>函数返回 = pop frame</li>\n</ul>\n</li>\n</ul>\n<p>C 语言程序是由很多栈帧组成的，每次函数调用创建一个新的栈帧</p>\n<p>应用：将任何递归程序就地转为非递归（还是一样的 call ()，但放入不同的 frame）</p>\n<h2 id=\"什么是程序二进制代码视角\"><a class=\"markdownIt-Anchor\" href=\"#什么是程序二进制代码视角\">#</a> 什么是程序（二进制代码视角）</h2>\n<ul>\n<li>状态 = 内存 M + 寄存器 R</li>\n<li>初始状态</li>\n<li>迁移 = 执行一条指令</li>\n</ul>\n<p>操作系统上的程序</p>\n<ul>\n<li>所有的指令都只能<strong>计算</strong>\n<ul>\n<li>deterministic: mov, add, sub, call…</li>\n<li>non-deterministic: rdrand …</li>\n<li>但这些指令甚至都无法使程序停下来（NEMU：加条 trap 指令）</li>\n</ul>\n</li>\n<li>一条特殊的指令：调用操作系统 <code>syscall</code>\n<ul>\n<li>把（M,R）完全交给操作系统，任其修改</li>\n<li>实现与操作系统中的其它对象交互\n<ul>\n<li>读写文件 / 操作系统状态（例如把文件内容写入 M）</li>\n<li>改变进程（运行中状态机）的状态，例如创建进程 / 销毁自己</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>程序 = 计算 + syscall</strong></li>\n</ul>\n<h2 id=\"如何在程序的两个视角之间切换\"><a class=\"markdownIt-Anchor\" href=\"#如何在程序的两个视角之间切换\">#</a> 如何在程序的两个视角之间切换</h2>\n<p><strong>编译器</strong>：源代码 S（状态机） → 二进制代码 C（状态机）</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>C</mi><mo>=</mo><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>e</mi><mtext>（</mtext><mi>S</mi><mtext>）</mtext></mrow><annotation encoding=\"application/x-tex\">C = complie（S）\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">e</span><span class=\"mord cjk_fallback\">（</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord cjk_fallback\">）</span></span></span></span></span></p>\n<h2 id=\"操作系统中的一般程序\"><a class=\"markdownIt-Anchor\" href=\"#操作系统中的一般程序\">#</a> 操作系统中的一般程序</h2>\n<p>系统中常见的应用程序</p>\n<ul>\n<li>\n<p>Core Utilities(coreutils)</p>\n<ul>\n<li>standard programs for text and file manipulation</li>\n<li>系统中安装的是 GNU Coreutils</li>\n</ul>\n</li>\n<li>\n<p>系统 / 工具程序</p>\n<ul>\n<li>bash, binutils, apt, ip, ssh, vim, tmux, jdk, python, …</li>\n</ul>\n</li>\n<li>\n<p>其他应用程序</p>\n<ul>\n<li>浏览器、音乐播放器</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>面试题 (1)：一个普通的、人畜无害的 Hello World C 程序执行的第一条指令在哪里？</p>\n</blockquote>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>gdb a.out</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span>gdb<span class=\"token punctuation\">)</span> start</pre></td></tr></table></figure><p>main () 之前发生了什么？</p>\n<p><code>ld-linux-x86-64.so</code>  加载了 libc</p>\n<p>之后 libc 完成了自己的初始化</p>\n<ul>\n<li>RTFM: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9odXJkL2dsaWJjL3N0YXJ0dXAuaHRtbA==\">libc startup</span> on Hurd</li>\n<li><code>main()</code>  的开始 / 结束并不是整个程序的开始 / 结束</li>\n<li>例子：hello-goodbye.c</li>\n</ul>\n<blockquote>\n<p>面试题 (2)：main 执行之前、执行中、执行后，发生了哪些操作系统 API 调用？</p>\n</blockquote>\n<blockquote>\n<p>In general, trace refers to the process of following <em>anything</em> from the beginning to the end. For example, the  <code>traceroute</code>  command follows each of the network hops as your computer connects to another computer.</p>\n</blockquote>\n<p>这门课中很重要的工具：strace</p>\n<ul>\n<li>system call trace</li>\n<li>理解程序运行时使用的系统调用\n<ul>\n<li>demo:  <code>strace ./hello-goodbye</code></li>\n<li>在这门课中，你能理解 strace 的输出并在你自己的操作系统里实现相当一部分系统调用 (mmap, execve, …)</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>本质上，所有程序都和 Hello World 类似</p>\n<p>程序 = 状态机 = 计算 → syscall → 计算 →</p>\n<ul>\n<li>被操作系统加载\n<ul>\n<li>通过另一个进程执行 execve 设置为初始状态</li>\n</ul>\n</li>\n<li>状态机执行\n<ul>\n<li>进程管理：fork, execve, exit, …</li>\n<li>文件 / 设备管理：open, close, read, write, …</li>\n<li>存储管理：mmap, brk, …</li>\n</ul>\n</li>\n<li>直到 _exit (exit_group) 退出</li>\n</ul>\n<hr>\n<p>(初学者对这一点会感到有一点惊讶)</p>\n<p>说好的浏览器、游戏、杀毒软件、病毒呢？都是这些 API 吗</p>\n<p>Yes! - 这些 API 就是操作系统的全部</p>\n<p>编译器 (gcc)，代表其他工具程序</p>\n<ul>\n<li>\n<p>主要的系统调用：execve, read, write</p>\n</li>\n<li>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">strace</span> <span class=\"token parameter variable\">-f</span> gcc a.c</pre></td></tr></table></figure><p>(gcc 会启动其他进程)</p>\n<ul>\n<li>可以管道给编辑器  <code>vim -</code></li>\n<li>编辑器里还可以  <code>%!grep</code>  (细节 / 技巧)</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>图形界面程序 (xedit)，代表其他图形界面程序 (例如 vscode)</p>\n<ul>\n<li>\n<p>主要的系统调用：poll, recvmsg, writev</p>\n</li>\n<li>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">strace</span> xedit</pre></td></tr></table></figure><ul>\n<li>图形界面程序和 X-Window 服务器按照 X11 协议通信</li>\n<li>虚拟机中的 xedit 将 X11 命令通过 ssh (X11 forwarding) 转发到 Host</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>本次课回答的问题</p>\n<ul>\n<li>\n<p><strong>Q</strong>: 到底什么是 “程序”？</p>\n</li>\n<li>\n<p>程序 = 状态机</p>\n<ul>\n<li>源代码 <em>S</em>: 状态迁移 = 执行语句</li>\n<li>二进制代码 <em>C</em>: 状态迁移 = 执行指令</li>\n<li>编译器 C = compile (S)</li>\n</ul>\n</li>\n<li>\n<p>应用视角的操作系统</p>\n<ul>\n<li><strong>就是一条 syscall 指令</strong></li>\n</ul>\n</li>\n<li>\n<p>计算机系统不存在玄学；一切都建立在确定的机制上</p>\n<ul>\n<li>理解操作系统的重要工具：gcc, binutils, gdb, strace</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"硬件视角的操作系统\"><a class=\"markdownIt-Anchor\" href=\"#硬件视角的操作系统\">#</a> 硬件视角的操作系统</h1>\n<p><strong>本讲内容</strong>：计算机硬件的状态机模型；回答以下问题：</p>\n<ul>\n<li>什么是计算机硬件？</li>\n<li>计算机硬件和程序员之间是如何约定的？</li>\n<li>听说操作系统也是程序。那到底是鸡生蛋还是蛋生鸡？</li>\n</ul>\n<blockquote>\n<p>状态机复习</p>\n<p>数字逻辑电路：</p>\n<ul>\n<li>状态 = 寄存器保存的值（flip-flop）</li>\n<li>初始状态 = RESET (implementation dependent)</li>\n<li>迁移 = 组合逻辑电路计算寄存器下一周期的值</li>\n</ul>\n</blockquote>\n<p>数字系统本身是状态机</p>\n<p>所有的程序都是运行在数字系统上的，<strong>程序也是状态机</strong></p>\n<h1 id=\"调试理论与实践\"><a class=\"markdownIt-Anchor\" href=\"#调试理论与实践\">#</a> 调试理论与实践</h1>\n<h2 id=\"调试理论\"><a class=\"markdownIt-Anchor\" href=\"#调试理论\">#</a> 调试理论</h2>\n<p><strong>本讲内容</strong>：调试理论：Fault, Error 和 Failure；GDB 使用技巧。</p>\n<p>“软件” 的两层含义</p>\n<ul>\n<li>人类需求在信息世界的投影\n<ul>\n<li>理解错需求 → bug</li>\n</ul>\n</li>\n<li>计算过程的精确 (数学) 描述\n<ul>\n<li>实现错误 → bug</li>\n</ul>\n</li>\n</ul>\n<p>调试 (debugging)</p>\n<ul>\n<li>已知程序有 bug，如何找到？</li>\n</ul>\n<p><strong>调试困难的根本原因</strong></p>\n<p>因为 bug 的触发经历了漫长的过程</p>\n<ul>\n<li>需求 → 设计 → 代码 (状态机) → Fault (bug) → Error (程序状态错) → Failure\n<ul>\n<li>我们只能观测到 failure (可观测的结果错)</li>\n<li>我们可以检查状态的正确性 (但非常费时)</li>\n<li>无法预知 bug 在哪里 (每一行 “看起来” 都挺对的)</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>调试理论：如果我们能判定任意程序状态的正确性，那么给定一个 failure，我们可以通过二分查找定位到第一个 error 的状态，此时的代码就是 fault (bug)。</p>\n</blockquote>\n<p>调试理论：推论</p>\n<ul>\n<li>\n<p>为什么我们喜欢 “单步调试”？</p>\n<ul>\n<li>从一个假定正确的状态出发</li>\n<li>每个语句的行为有限，容易判定是否是 error</li>\n</ul>\n</li>\n<li>\n<p>为什么调试理论看起来很没用？</p>\n<ul>\n<li>\n<p>因为判定程序状态的正确性非常困难</p>\n<p>(是否在调试 DP 题 / 图论算法时陷入时间黑洞？)</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>实际中的调试：观察状态机执行 (trace) 的某个侧面</p>\n<ul>\n<li>缩小错误状态 (error) 可能产生的位置</li>\n<li>作出适当的假设</li>\n<li>再进行细粒度的定位和诊断</li>\n</ul>\n<p><strong>最重要的两个工具</strong></p>\n<ul>\n<li>printf → 自定义 log 的 trace\n<ul>\n<li>灵活可控、能快速定位问题大概位置、适用于大型软件</li>\n<li>无法精确定位、大量的 logs 管理起来比较麻烦</li>\n</ul>\n</li>\n<li>gdb → 指令 / 语句级 trace\n<ul>\n<li>精确、指令级定位、任意查看程序内部状态</li>\n<li>耗费大量时间</li>\n</ul>\n</li>\n</ul>\n<p>调试理论给了大家在遇到 “任何问题” 时候 self-check 的列表：</p>\n<ol>\n<li>是怎样的程序 (状态机) 在运行？</li>\n<li>我们遇到了怎样的 failure？</li>\n<li>我们能从状态机的运行中从易到难得到什么信息？</li>\n<li>如何二分检查这些信息和 error 之间的关联？</li>\n</ol>\n<h2 id=\"编程基本准则回顾\"><a class=\"markdownIt-Anchor\" href=\"#编程基本准则回顾\">#</a> 编程基本准则：回顾</h2>\n<blockquote>\n<p>Programs are meant to be read by humans (AIs) and only incidentally for computers to execute. — <em>D. E. Knuth</em></p>\n<p>(程序首先是拿给人读的，其次才是被机器执行。)</p>\n</blockquote>\n<p>好的程序</p>\n<ul>\n<li>\n<p>不言自明：能知道是做什么的 (specification)</p>\n<ul>\n<li>因此代码风格很重要</li>\n</ul>\n</li>\n<li>\n<p>不言自证：能确认代码和 specification 一致</p>\n<ul>\n<li>因此代码中的逻辑流很重要</li>\n</ul>\n</li>\n<li>\n<p>人类新纪元的评判标准</p>\n<ul>\n<li>AI 是否能正确理解 / 维护你的代码</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"调试理论的最重要应用\"><a class=\"markdownIt-Anchor\" href=\"#调试理论的最重要应用\">#</a> 调试理论的最重要应用</h2>\n<blockquote>\n<p>写好读、易验证的代码</p>\n<p>在代码中添加更多的断言 (assertions)</p>\n</blockquote>\n<p>断言的意义</p>\n<ul>\n<li>把代码中隐藏的 specification 写出来\n<ul>\n<li>Fault → Error (靠测试)</li>\n<li>Error → Failure (靠断言)\n<ul>\n<li>Error 暴露的越晚，越难调试</li>\n<li>追溯导致 assert failure 的变量值 (slice) 通常可以快速定位到 bug</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"python-建模操作系统\"><a class=\"markdownIt-Anchor\" href=\"#python-建模操作系统\">#</a> Python 建模操作系统</h1>\n<h1 id=\"并发\"><a class=\"markdownIt-Anchor\" href=\"#并发\">#</a> = 并发 =</h1>\n<h1 id=\"多处理器编程\"><a class=\"markdownIt-Anchor\" href=\"#多处理器编程\">#</a> 多处理器编程</h1>\n<h2 id=\"并发-2\"><a class=\"markdownIt-Anchor\" href=\"#并发-2\">#</a> 并发</h2>\n<blockquote>\n<p>Concurrent: existing, happening, or done <em>at the same time</em>.</p>\n<p>In computer science, concurrency refers to the ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in partial order, without affecting the final outcome. (Wikipedia)</p>\n</blockquote>\n<p>操作系统作为 “状态机的管理者”，引入了共享的状态</p>\n<ul>\n<li>带来了并发</li>\n<li>(操作系统是最早的并发程序)</li>\n</ul>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">Tprint</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    sys_write<span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f'</span><span class=\"token interpolation\"><span class=\"token punctuation\">&#123;</span>name<span class=\"token punctuation\">&#125;</span></span><span class=\"token string\">'</span></span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">for</span> name <span class=\"token keyword\">in</span> <span class=\"token string\">'AB'</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        sys_spawn<span class=\"token punctuation\">(</span>Tprint<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><ul>\n<li>使用 model checker 绘制状态图</li>\n</ul>\n<hr>\n<p><strong>多线程共享内存并发</strong></p>\n<p>线程：共享内存的执行流</p>\n<ul>\n<li>执行流拥有独立的堆栈 / 寄存器</li>\n</ul>\n<p>简化的线程 API (thread.h)</p>\n<ul>\n<li><code>spawn(fn)</code>\n<ul>\n<li>创建一个入口函数是 <code>fn</code>  的线程，并立即开始执行\n<ul>\n<li><code>void fn(int tid) &#123; ... &#125;</code></li>\n<li>参数  <code>tid</code>  从 1 开始编号</li>\n</ul>\n</li>\n<li>行为： <code>sys_spawn(fn, tid)</code></li>\n</ul>\n</li>\n<li><code>join()</code>\n<ul>\n<li>等待所有运行线程的返回 (也可以不调用)</li>\n<li>行为： <code>while (done != T) sys_sched()</code></li>\n</ul>\n</li>\n</ul>\n<p>多处理器编程：一个 API 搞定</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"thread.h\"</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Ta</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Tb</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token function\">create</span><span class=\"token punctuation\">(</span>Ta<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token function\">create</span><span class=\"token punctuation\">(</span>Tb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ul>\n<li>这个程序可以利用系统中的多处理器\n<ul>\n<li>操作系统会自动把线程放置在不同的处理器上</li>\n<li>CPU 使用率超过了 100%</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"原子性\"><a class=\"markdownIt-Anchor\" href=\"#原子性\">#</a> 原子性</h2>\n<h2 id=\"执行顺序\"><a class=\"markdownIt-Anchor\" href=\"#执行顺序\">#</a> 执行顺序</h2>\n<h2 id=\"处理器间的可见性\"><a class=\"markdownIt-Anchor\" href=\"#处理器间的可见性\">#</a> 处理器间的可见性</h2>\n<h1 id=\"并发控制基础\"><a class=\"markdownIt-Anchor\" href=\"#并发控制基础\">#</a> 并发控制基础</h1>\n<p><strong>背景回顾</strong>：虽然 “线程库” 入门简单，但多处理器编程 + 编译优化会给我们带来很多意想不到的惊喜。在编写多线程程序时，必须放弃许多对顺序程序编程时的基本假设，这也是并发编程困难的原因。</p>\n<p><strong>本讲内容</strong>：并发编程困难不代表我们只能摆烂 —— 我们还可以创造出新的手段，帮助我们编写正确的并发程序：</p>\n<ul>\n<li>互斥问题和 Peterson 算法</li>\n<li>Peterson 算法的正确性和模型检验</li>\n<li>Peterson 算法在现代多处理器系统上的实现</li>\n<li>实现并发控制的硬件和编译器机制</li>\n</ul>\n<h1 id=\"并发控制互斥\"><a class=\"markdownIt-Anchor\" href=\"#并发控制互斥\">#</a> 并发控制：互斥</h1>\n<h1 id=\"并发控制同步\"><a class=\"markdownIt-Anchor\" href=\"#并发控制同步\">#</a> 并发控制：同步</h1>\n<h1 id=\"真实世界的并发编程\"><a class=\"markdownIt-Anchor\" href=\"#真实世界的并发编程\">#</a> 真实世界的并发编程</h1>\n<h1 id=\"并发-bugs\"><a class=\"markdownIt-Anchor\" href=\"#并发-bugs\">#</a> 并发 Bugs</h1>\n<h1 id=\"多处理器系统与中断机制\"><a class=\"markdownIt-Anchor\" href=\"#多处理器系统与中断机制\">#</a> 多处理器系统与中断机制</h1>\n<h1 id=\"虚拟化\"><a class=\"markdownIt-Anchor\" href=\"#虚拟化\">#</a> = 虚拟化 =</h1>\n<h1 id=\"操作系统上的进程\"><a class=\"markdownIt-Anchor\" href=\"#操作系统上的进程\">#</a> 操作系统上的进程</h1>\n<h1 id=\"linux-操作系统\"><a class=\"markdownIt-Anchor\" href=\"#linux-操作系统\">#</a> Linux 操作系统</h1>\n<h1 id=\"linux-进程的地址空间\"><a class=\"markdownIt-Anchor\" href=\"#linux-进程的地址空间\">#</a> Linux 进程的地址空间</h1>\n<h1 id=\"系统调用和-unix-shell\"><a class=\"markdownIt-Anchor\" href=\"#系统调用和-unix-shell\">#</a> 系统调用和 UNIX Shell</h1>\n<h1 id=\"c-标准库的实现\"><a class=\"markdownIt-Anchor\" href=\"#c-标准库的实现\">#</a> C 标准库的实现</h1>\n<h1 id=\"可执行文件的加载\"><a class=\"markdownIt-Anchor\" href=\"#可执行文件的加载\">#</a> 可执行文件的加载</h1>\n<h1 id=\"处理器调度\"><a class=\"markdownIt-Anchor\" href=\"#处理器调度\">#</a> 处理器调度</h1>\n<h1 id=\"进程-线程与系统调用\"><a class=\"markdownIt-Anchor\" href=\"#进程-线程与系统调用\">#</a> 进程、线程与系统调用</h1>\n<h1 id=\"持久化\"><a class=\"markdownIt-Anchor\" href=\"#持久化\">#</a> = 持久化 =</h1>\n<h1 id=\"存储设备原理\"><a class=\"markdownIt-Anchor\" href=\"#存储设备原理\">#</a> 存储设备原理</h1>\n<h1 id=\"输入输出设备\"><a class=\"markdownIt-Anchor\" href=\"#输入输出设备\">#</a> 输入输出设备</h1>\n<h1 id=\"设备驱动程序\"><a class=\"markdownIt-Anchor\" href=\"#设备驱动程序\">#</a> 设备驱动程序</h1>\n<h1 id=\"文件系统-api\"><a class=\"markdownIt-Anchor\" href=\"#文件系统-api\">#</a> 文件系统 API</h1>\n<h1 id=\"fat-和-unix-文件系统\"><a class=\"markdownIt-Anchor\" href=\"#fat-和-unix-文件系统\">#</a> FAT 和 UNIX 文件系统</h1>\n<h1 id=\"持久数据的可靠性\"><a class=\"markdownIt-Anchor\" href=\"#持久数据的可靠性\">#</a> 持久数据的可靠性</h1>\n",
            "tags": [
                "Linux",
                "操作系统"
            ]
        },
        {
            "id": "https://adventure-yx.github.io/2023/03/08/Linux/",
            "url": "https://adventure-yx.github.io/2023/03/08/Linux/",
            "title": "Linux",
            "date_published": "2023-03-08T14:03:56.000Z",
            "content_html": "<h1 id=\"linux-配置\"><a class=\"markdownIt-Anchor\" href=\"#linux-配置\">#</a> Linux 配置</h1>\n<p>windows powershell</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>wsl <span class=\"token parameter variable\">--installl</span> <span class=\"token parameter variable\">-d</span> Ubuntu-20.04</pre></td></tr></table></figure><p>linux</p>\n<p>uname -r ： 显示操作系统的发行版号<br>\n uname -a ：显示系统名、节点名称、操作系统的发行版号、内核版本等等。</p>\n<p><img data-src=\"image-20230420174648351.png\" alt=\"image-20230420174648351\"></p>\n<blockquote>\n<p><strong>系统名：</strong></p>\n<p>Linux</p>\n<p><strong>节点名称：</strong></p>\n<p>LAPTOP-G8CK4FEN</p>\n<p><strong>操作系统的发行版号：</strong></p>\n<p>5.10.16.3-microsoft-standard-WSL2</p>\n<p><strong>硬件平台：</strong><br>\nx86_64</p>\n<p><strong>机器硬件名：</strong><br>\nx86_64</p>\n<p><strong>系统处理器的体系结构：</strong><br>\nx86_64</p>\n<p><strong>操作系统：</strong><br>\nGNU/Linux</p>\n</blockquote>\n<p>更新软件包</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">apt-get</span> update</pre></td></tr></table></figure><p>安装最常用 linux 桌面程序 gedit</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">apt</span> <span class=\"token function\">install</span> gedit</pre></td></tr></table></figure><p>安装编译工具 gcc+cmake</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">apt</span> <span class=\"token function\">install</span> build-essential</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">apt</span> <span class=\"token function\">install</span> cmake</pre></td></tr></table></figure><figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> <span class=\"token function\">vim</span></pre></td></tr></table></figure><h1 id=\"linux-系统目录结构\"><a class=\"markdownIt-Anchor\" href=\"#linux-系统目录结构\">#</a> Linux 系统目录结构</h1>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">ls</span> /</pre></td></tr></table></figure><p><img data-src=\"image-20230309080718084.png\" alt=\"image-20230309080718084\"></p>\n<p>树状目录结构：</p>\n<p><img data-src=\"d0c50-linux2bfile2bsystem2bhierarchy.jpg\" alt=\"img\"></p>\n<p><strong>系统启动必须：</strong></p>\n<ul>\n<li>\n<p><code>/boot</code> ：存放的启动 Linux 时使用的内核文件，包括连接文件以及镜像文件。</p>\n</li>\n<li>\n<p><code>/etc</code> ：<strong>存放</strong>所有<strong>的系统需要的</strong>配置文件<strong>和</strong>子目录列表，** 更改目录下的文件可能会导致系统不能启动。</p>\n</li>\n<li>\n<p><code>/lib</code> ：存放基本代码库（比如 c++ 库），其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p>\n</li>\n<li>\n<p><code>/sys</code> ： 这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面 3 种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中</p>\n</li>\n</ul>\n<p><strong>指令集合：</strong></p>\n<ul>\n<li>\n<p><code>/bin</code> ：存放着最常用的程序和指令</p>\n</li>\n<li>\n<p><code>/sbin</code> ：只有系统管理员能使用的程序和指令。是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p>\n</li>\n</ul>\n<p><strong>外部文件管理：</strong></p>\n<ul>\n<li>\n<p><code>/dev</code>  ：Device (设备) 的缩写，存放的是 Linux 的外部设备。<strong>注意</strong>：在 Linux 中访问设备和访问文件的方式是相同的。</p>\n</li>\n<li>\n<p><code>/media</code> ：类 windows 的<strong>其他设备</strong>，例如 U 盘、光驱等等，识别后 linux 会把设备放到这个目录下。</p>\n</li>\n<li>\n<p><code>/mnt</code> ：临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</p>\n</li>\n</ul>\n<p><strong>临时文件：</strong></p>\n<ul>\n<li>\n<p><code>/run</code> ：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p>\n</li>\n<li>\n<p><code>/lost+found</code> ：一般情况下为空的，系统非法关机后，这里就存放一些文件。</p>\n</li>\n<li>\n<p><code>/tmp</code> ：这个目录是用来存放一些临时文件的。</p>\n</li>\n</ul>\n<p><strong>账户：</strong></p>\n<ul>\n<li>\n<p><code>/root</code> ：系统管理员的用户主目录。</p>\n</li>\n<li>\n<p><code>/home</code> ：用户的主目录，以用户的账号命名的。</p>\n</li>\n<li>\n<p><code>/usr</code> ： usr 是 unix shared resources (共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p>\n</li>\n<li>\n<p><code>/usr/bin</code> ：系统用户使用的应用程序与指令。</p>\n</li>\n<li>\n<p><code>/usr/sbin</code> ：超级用户使用的比较高级的管理程序和系统守护程序。</p>\n</li>\n<li>\n<p><code>/usr/src</code> ：内核源代码默认的放置目录。</p>\n</li>\n</ul>\n<p><strong>运行过程中要用：</strong></p>\n<ul>\n<li>\n<p><code>/var</code> ：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。</p>\n</li>\n<li>\n<p><code>/proc</code> ：管理 ** 内存空间！** 虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</p>\n</li>\n</ul>\n<p><strong>扩展用的：</strong></p>\n<ul>\n<li>\n<p><code>/opt</code> ：默认是空的，我们安装额外软件可以放在这个里面。</p>\n</li>\n<li>\n<p><code>/srv</code> ：存放服务启动后需要提取的数据 **（不用服务器就是空）**</p>\n</li>\n</ul>\n<h1 id=\"linux-文件基本属性\"><a class=\"markdownIt-Anchor\" href=\"#linux-文件基本属性\">#</a> Linux 文件基本属性</h1>\n<p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。</p>\n<p>为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p>\n<p>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p>\n<ul>\n<li><code>chown</code>  (change owner) ： 修改所属用户与组。</li>\n<li><code>chmod</code>  (change mode) ： 修改用户的权限。</li>\n</ul>\n<p>在 Linux 中我们可以使用  <code>ll</code>  或者  <code>ls –l</code>  命令来显示一个文件的属性以及文件所属的用户和组，如：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>root@LAPTOP-G8CK4FEN:/<span class=\"token comment\"># ll</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>total <span class=\"token number\">1480</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>drwxr-xr-x  <span class=\"token number\">19</span> root root    <span class=\"token number\">4096</span> Mar  <span class=\"token number\">9</span> 08:01 ./</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>drwxr-xr-x  <span class=\"token number\">19</span> root root    <span class=\"token number\">4096</span> Mar  <span class=\"token number\">9</span> 08:01 <span class=\"token punctuation\">..</span>/</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>lrwxrwxrwx   <span class=\"token number\">1</span> root root       <span class=\"token number\">7</span> Apr <span class=\"token number\">23</span>  <span class=\"token number\">2020</span> bin -<span class=\"token operator\">></span> usr/bin/</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>drwxr-xr-x   <span class=\"token number\">2</span> root root    <span class=\"token number\">4096</span> Apr <span class=\"token number\">23</span>  <span class=\"token number\">2020</span> boot/</pre></td></tr></table></figure><p>实例中，<strong>boot</strong> 文件的第一个属性用 <strong>d</strong> 表示。<strong>d</strong> 在 Linux 中代表该文件是一个目录文件。</p>\n<p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p>\n<ul>\n<li>当为 <strong>d</strong> 则是目录</li>\n<li>当为 <strong>-</strong> 则是文件；</li>\n<li>若是 <strong>l</strong> 则表示为链接文档 (link file)；</li>\n<li>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备 (可随机存取装置)；</li>\n<li>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标 (一次性读取装置)。</li>\n</ul>\n<p>接下来的字符中，以三个为一组，且均为 <strong>rwx</strong> 的三个参数的组合。其中， <strong>r</strong> 代表可读 (read)、 <strong>w</strong> 代表可写 (write)、 <strong>x</strong> 代表可执行 (execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 <strong>-</strong> 而已。</p>\n<p><img data-src=\"file-llls22.jpg\" alt=\"img\"></p>\n<p><img data-src=\"363003_1227493859FdXT.png\" alt=\"363003_1227493859FdXT\"></p>\n<p>从左至右用 <strong>0-9</strong> 这些数字来表示。</p>\n<p>第 <strong>0</strong> 位确定文件类型，第 <strong>1-3</strong> 位确定属主（该文件的所有者）拥有该文件的权限。</p>\n<p>第 4-6 位确定属组（所有者的同组用户）拥有该文件的权限，第 7-9 位确定其他用户拥有该文件的权限。</p>\n<p>其中，第 <strong>1、4、7</strong> 位表示读权限，如果用 <strong>r</strong> 字符表示，则有读权限，如果用 <strong>-</strong> 字符表示，则没有读权限；第 <strong>2、5、8</strong> 位表示写权限，如果用 <strong>w</strong> 字符表示，则有写权限，如果用 <strong>-</strong> 字符表示没有写权限；第 <strong>3、6、9</strong> 位表示可执行权限，如果用 <strong>x</strong> 字符表示，则有执行权限，如果用 <strong>-</strong> 字符表示，则没有执行权限。</p>\n<h1 id=\"linux-文件与目录管理\"><a class=\"markdownIt-Anchor\" href=\"#linux-文件与目录管理\">#</a> Linux 文件与目录管理</h1>\n<p>我们知道 Linux 的目录结构为树状结构，最顶级的目录为根目录 <strong>/</strong>。</p>\n<p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p>\n<ul>\n<li><strong>绝对路径：</strong><br>\n路径的写法，由根目录 <strong>/</strong> 写起，例如： <code>/usr/share/doc</code>  这个目录。</li>\n<li><strong>相对路径：</strong><br>\n路径的写法，不是由 <strong>/</strong> 写起，例如由  <code>/usr/share/doc</code>  要到  <code>/usr/share/man</code>  底下时，可以写成：  <code>cd ../man</code>  这就是相对路径的写法。</li>\n</ul>\n<p><strong>“/” 在系统文件中表示绝对路径；</strong></p>\n<p>“/” 处于 Linux 文件系统<strong>树形结构</strong>的最顶端，我们称它为 Linux 文件系统的 root，<strong>它是 Linux 文件系统的入口</strong>；<br>\n所有的目录、文件、设备都在 “/” 之下，它是 Linux 文件系统最顶层的唯一的目录；<br>\n一般建议在根目录下面只有目录，不要直接存放文件；<br>\n根目录是 linux 系统启动时系统第一个载入的分区，所以启动过程中用到的文件应该都放在这个分区中；<br>\n其中 <code>/etc</code> 、 <code>/bin</code> 、 <code>/dev</code> 、 <code>/lib</code> 、 <code>/sbin</code>  这 5 个子目录都应该要与根目录连在一起，不可独立成为某个分区。</p>\n<p><strong>“./” 代表的意思是</strong>： ./ 代表当前文件目录，某一个文件（或者目录）的查找路径是从当前目录 “.” 下面开始进行查找。</p>\n<p><strong>“~” 代表的意思是</strong>：表示代码主目录，也就是当前登录用户的用户目录。</p>\n<p><strong>“…” 代表的意思是</strong>：“…” 表示上级目录</p>\n<h2 id=\"处理目录的常用命令\"><a class=\"markdownIt-Anchor\" href=\"#处理目录的常用命令\">#</a> 处理目录的常用命令</h2>\n<ul>\n<li><code>ls</code> （英文全拼：list files）: 列出目录及文件名</li>\n<li><code>cd</code> （英文全拼：change directory）：切换目录</li>\n<li><code>pwd</code> （英文全拼：print work directory）：显示目前的目录</li>\n<li><code>mkdir</code> （英文全拼：make directory）：创建一个新的目录</li>\n<li><code>rmdir</code> （英文全拼：remove directory）：删除一个空的目录</li>\n<li><code>cp</code> （英文全拼：copy file）: 复制文件或目录</li>\n<li><code>rm</code> （英文全拼：remove）: 删除文件或目录</li>\n<li><code>mv</code> （英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li>\n</ul>\n<p>可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p>\n<h3 id=\"ls-列出目录\"><a class=\"markdownIt-Anchor\" href=\"#ls-列出目录\">#</a> ls (列出目录)</h3>\n<p>在 Linux 系统当中， ls 命令可能是最常被运行的。</p>\n<p>选项与参数：</p>\n<ul>\n<li>-a ：全部的文件，连同隐藏文件 (开头为。的文件) 一起列出来 (常用)</li>\n<li>-d ：仅列出目录本身，而不是列出目录内的文件数据 (常用)</li>\n<li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li>\n</ul>\n<h3 id=\"cd-切换目录\"><a class=\"markdownIt-Anchor\" href=\"#cd-切换目录\">#</a> cd (切换目录)</h3>\n<p>cd 是 Change Directory 的缩写，这是用来变换工作目录的命令。</p>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">cd</span> <span class=\"token punctuation\">[</span>相对路径或绝对路径<span class=\"token punctuation\">]</span></pre></td></tr></table></figure><figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#使用 mkdir 命令创建 runoob 目录</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># mkdir runoob</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">#使用绝对路径切换到 runoob 目录</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cd /root/runoob/</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">#使用相对路径切换到 runoob 目录</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cd ./runoob/</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\"># 表示回到自己的家目录，亦即是 /root 这个目录</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">[</span>root@www runoob<span class=\"token punctuation\">]</span><span class=\"token comment\"># cd ~</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\"># 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cd ..</span></pre></td></tr></table></figure><h3 id=\"pwd-显示目前所在的目录\"><a class=\"markdownIt-Anchor\" href=\"#pwd-显示目前所在的目录\">#</a> pwd (显示目前所在的目录)</h3>\n<p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># pwd [-P]</span></pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li><strong>-P</strong> ：显示出确实的路径，而非使用链接 (link) 路径。</li>\n</ul>\n<h3 id=\"mkdir-创建新目录\"><a class=\"markdownIt-Anchor\" href=\"#mkdir-创建新目录\">#</a> mkdir (创建新目录)</h3>\n<p>如果想要创建新的目录的话，那么就使用 mkdir (make directory) 吧。</p>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">mkdir</span> <span class=\"token punctuation\">[</span>-mp<span class=\"token punctuation\">]</span> 目录名称</pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li>\n<li>-p ：帮助你直接将所需要的目录 (包含上一级目录) 递归创建起来！</li>\n</ul>\n<p>实例：请到 /tmp 底下尝试创建数个新目录看看：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cd /tmp</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># mkdir test    &lt;== 创建一名为 test 的新目录</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># mkdir test1/test2/test3/test4</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>mkdir: cannot create directory `test1/test2/test3/test4': </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>No such <span class=\"token function\">file</span> or directory       <span class=\"token operator\">&lt;=</span><span class=\"token operator\">=</span> 没办法直接创建此目录啊！</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># mkdir -p test1/test2/test3/test4</span></pre></td></tr></table></figure><h3 id=\"rmdir-删除空的目录\"><a class=\"markdownIt-Anchor\" href=\"#rmdir-删除空的目录\">#</a> rmdir (删除空的目录)</h3>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">rmdir</span> <span class=\"token punctuation\">[</span>-p<span class=\"token punctuation\">]</span> 目录名称</pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>**-p ：** 从该目录起，一次删除多级空目录</li>\n</ul>\n<p>删除 runoob 目录</p>\n<pre><code>[root@www tmp]# rmdir runoob/\n</code></pre>\n<p>将 mkdir 实例中创建的目录 (/tmp 底下) 删除掉！</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># ls -l   &lt;== 看看有多少目录存在？</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>drwxr-xr-x  <span class=\"token number\">3</span> root  root <span class=\"token number\">4096</span> Jul <span class=\"token number\">18</span> <span class=\"token number\">12</span>:50 <span class=\"token builtin class-name\">test</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>drwxr-xr-x  <span class=\"token number\">3</span> root  root <span class=\"token number\">4096</span> Jul <span class=\"token number\">18</span> <span class=\"token number\">12</span>:53 test1</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>drwx--x--x  <span class=\"token number\">2</span> root  root <span class=\"token number\">4096</span> Jul <span class=\"token number\">18</span> <span class=\"token number\">12</span>:54 test2</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># rmdir test   &lt;== 可直接删除掉，没问题</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># rmdir test1  &lt;== 因为尚有内容，所以无法删除！</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>rmdir: `test1': Directory not empty</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># rmdir -p test1/test2/test3/test4</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># ls -l        &lt;== 您看看，底下的输出中 test 与 test1 不见了！</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>drwx--x--x  <span class=\"token number\">2</span> root  root <span class=\"token number\">4096</span> Jul <span class=\"token number\">18</span> <span class=\"token number\">12</span>:54 test2</pre></td></tr></table></figure><p>利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。</p>\n<p>不过要注意的是，这个 <strong>rmdir 仅能删除空的目录</strong>，你可以使用 <strong>rm 命令来删除非空目录</strong>。</p>\n<h3 id=\"cp-复制文件或目录\"><a class=\"markdownIt-Anchor\" href=\"#cp-复制文件或目录\">#</a> cp (复制文件或目录)</h3>\n<p>cp 即拷贝文件和目录。</p>\n<p>语法:</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cp [-adfilprsu] 来源档 (source) 目标档 (destination)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cp [options] source1 source2 source3 .... directory</span></pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>**-a：** 相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li>\n<li>**-d：** 若来源档为链接档的属性 (link file)，则复制链接档属性而非文件本身；</li>\n<li>**-f：** 为强制 (force) 的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li>\n<li>**-i：** 若目标档 (destination) 已经存在时，在覆盖时会先询问动作的进行 (常用)</li>\n<li>**-l：** 进行硬式链接 (hard link) 的链接档创建，而非复制文件本身；</li>\n<li>**-p：** 连同文件的属性一起复制过去，而非使用默认属性 (备份常用)；</li>\n<li>**-r：** 递归持续复制，用於目录的复制行为；(常用)</li>\n<li>**-s：** 复制成为符号链接档 (symbolic link)，亦即『捷径』文件；</li>\n<li>**-u：** 若 destination 比 source 旧才升级 destination ！</li>\n</ul>\n<p>用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cp ~/.bashrc /tmp/bashrc</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cp -i ~/.bashrc /tmp/bashrc</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>cp: overwrite `/tmp/bashrc'? n  <span class=\"token operator\">&lt;=</span><span class=\"token operator\">=</span>n不覆盖，y为覆盖</pre></td></tr></table></figure><h3 id=\"rm-移除文件或目录\"><a class=\"markdownIt-Anchor\" href=\"#rm-移除文件或目录\">#</a> rm (移除文件或目录)</h3>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">rm</span> <span class=\"token punctuation\">[</span>-fir<span class=\"token punctuation\">]</span> 文件或目录</pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li>\n<li>-i ：互动模式，在删除前会询问使用者是否动作</li>\n<li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>\n</ul>\n<p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># rm -i bashrc</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>rm: remove regular <span class=\"token function\">file</span> `bashrc'? y</pre></td></tr></table></figure><p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p>\n<h3 id=\"mv-移动文件与目录或修改名称\"><a class=\"markdownIt-Anchor\" href=\"#mv-移动文件与目录或修改名称\">#</a> mv (移动文件与目录，或修改名称)</h3>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># mv [-fiu] source destination</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># mv [options] source1 source2 source3 .... directory</span></pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>\n<li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li>\n<li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li>\n</ul>\n<p>复制一文件，创建一目录，将文件移动到目录中</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cd /tmp</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># cp ~/.bashrc bashrc</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># mkdir mvtest</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># mv bashrc mvtest</span></pre></td></tr></table></figure><p>将某个文件移动到某个目录去，就是这样做！</p>\n<p>将刚刚的目录名称更名为 mvtest2</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www tmp<span class=\"token punctuation\">]</span><span class=\"token comment\"># mv mvtest mvtest2</span></pre></td></tr></table></figure><h2 id=\"linux-文件内容查看\"><a class=\"markdownIt-Anchor\" href=\"#linux-文件内容查看\">#</a> Linux 文件内容查看</h2>\n<p>Linux 系统中使用以下命令来查看文件的内容：</p>\n<ul>\n<li><code>cat</code>  由第一行开始显示文件内容</li>\n<li><code>tac</code>  从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>\n<li><code>nl</code>   显示的时候，顺道输出行号！</li>\n<li><code>more</code>  一页一页的显示文件内容</li>\n<li><code>less</code>  与  <code>more</code>  类似，但是比 more 更好的是，他可以往前翻页！</li>\n<li><code>head</code>  只看头几行</li>\n<li><code>tail</code>  只看尾巴几行</li>\n</ul>\n<p>你可以使用 *man [命令]* 来查看各个命令的使用文档，如 ：man cp。</p>\n<h3 id=\"cat\"><a class=\"markdownIt-Anchor\" href=\"#cat\">#</a> cat</h3>\n<p>由第一行开始显示文件内容</p>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">cat</span> <span class=\"token punctuation\">[</span>-AbEnTv<span class=\"token punctuation\">]</span></pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>\n<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>\n<li>-E ：将结尾的断行字节 $ 显示出来；</li>\n<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>\n<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>\n<li>-v ：列出一些看不出来的特殊字符</li>\n</ul>\n<p>检看 /etc/issue 这个文件的内容：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># cat /etc/issue</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>CentOS release <span class=\"token number\">6.4</span> <span class=\"token punctuation\">(</span>Final<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Kernel <span class=\"token punctuation\">\\</span>r on an <span class=\"token punctuation\">\\</span>m</pre></td></tr></table></figure><h3 id=\"tac\"><a class=\"markdownIt-Anchor\" href=\"#tac\">#</a> tac</h3>\n<p>tac 与 cat 命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># tac /etc/issue</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Kernel <span class=\"token punctuation\">\\</span>r on an <span class=\"token punctuation\">\\</span>m</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>CentOS release <span class=\"token number\">6.4</span> <span class=\"token punctuation\">(</span>Final<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h3 id=\"nl\"><a class=\"markdownIt-Anchor\" href=\"#nl\">#</a> nl</h3>\n<p>显示行号</p>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">nl</span> <span class=\"token punctuation\">[</span>-bnw<span class=\"token punctuation\">]</span> 文件</pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>-b ：指定行号指定的方式，主要有两种：<br>\n-b a ：表示不论是否为空行，也同样列出行号 (类似 cat -n)；<br>\n-b t ：如果有空行，空的那一行不要列出行号 (默认值)；</li>\n<li>-n ：列出行号表示的方法，主要有三种：<br>\n-n ln ：行号在荧幕的最左方显示；<br>\n-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>\n-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li>\n<li>-w ：行号栏位的占用的位数。</li>\n</ul>\n<p>实例一：用 nl 列出 /etc/issue 的内容</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># nl /etc/issue</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>     <span class=\"token number\">1</span>  CentOS release <span class=\"token number\">6.4</span> <span class=\"token punctuation\">(</span>Final<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     <span class=\"token number\">2</span>  Kernel <span class=\"token punctuation\">\\</span>r on an <span class=\"token punctuation\">\\</span>m</pre></td></tr></table></figure><h3 id=\"more\"><a class=\"markdownIt-Anchor\" href=\"#more\">#</a> more</h3>\n<p>一页一页翻动</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># more /etc/man_db.config </span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">#</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># Generated automatically from man.conf.in by the</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># configure script.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">#</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\"># man.conf from man-1.6d</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">(</span>中间省略<span class=\"token punctuation\">)</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>--More--<span class=\"token punctuation\">(</span><span class=\"token number\">28</span>%<span class=\"token punctuation\">)</span>  <span class=\"token operator\">&lt;=</span><span class=\"token operator\">=</span> 重点在这一行喔！你的光标也会在这里等待你的命令</pre></td></tr></table></figure><p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>\n<ul>\n<li>空白键 (space)：代表向下翻一页；</li>\n<li>Enter     ：代表向下翻『一行』；</li>\n<li>/ 字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>\n<li>:f      ：立刻显示出档名以及目前显示的行数；</li>\n<li>q      ：代表立刻离开 more ，不再显示该文件内容。</li>\n<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>\n</ul>\n<h3 id=\"less\"><a class=\"markdownIt-Anchor\" href=\"#less\">#</a> less</h3>\n<p>一页一页翻动，以下实例输出 /etc/man.config 文件的内容：</p>\n<pre><code>[root@www ~]# less /etc/man.config\n#\n# Generated automatically from man.conf.in by the\n# configure script.\n#\n# man.conf from man-1.6d\n....(中间省略)....\n:   &lt;== 这里可以等待你输入命令！\n</code></pre>\n<p>less 运行时可以输入的命令有：</p>\n<ul>\n<li>空白键  ：向下翻动一页；</li>\n<li>[pagedown]：向下翻动一页；</li>\n<li>[pageup] ：向上翻动一页；</li>\n<li>/ 字串   ：向下搜寻『字串』的功能；</li>\n<li>? 字串   ：向上搜寻『字串』的功能；</li>\n<li>n     ：重复前一个搜寻 (与 / 或？有关！)</li>\n<li>N     ：反向的重复前一个搜寻 (与 / 或？有关！)</li>\n<li>q     ：离开 less 这个程序；</li>\n</ul>\n<h3 id=\"head\"><a class=\"markdownIt-Anchor\" href=\"#head\">#</a> head</h3>\n<p>取出文件前面几行</p>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">head</span> <span class=\"token punctuation\">[</span>-n number<span class=\"token punctuation\">]</span> 文件</pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>-n ：后面接数字，代表显示几行的意思</li>\n</ul>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># head /etc/man.config</span></pre></td></tr></table></figure><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># head -n 20 /etc/man.config</span></pre></td></tr></table></figure><h3 id=\"tail\"><a class=\"markdownIt-Anchor\" href=\"#tail\">#</a> tail</h3>\n<p>取出文件后面几行</p>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">tail</span> <span class=\"token punctuation\">[</span>-n number<span class=\"token punctuation\">]</span> 文件</pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li>-n ：后面接数字，代表显示几行的意思</li>\n<li>-f ：表示持续侦测后面所接的档名，要等到按下 [ctrl]-c 才会结束 tail 的侦测</li>\n</ul>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># tail /etc/man.config</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span>root@www ~<span class=\"token punctuation\">]</span><span class=\"token comment\"># tail -n 20 /etc/man.config</span></pre></td></tr></table></figure><h1 id=\"linux-链接概念\"><a class=\"markdownIt-Anchor\" href=\"#linux-链接概念\">#</a> Linux 链接概念</h1>\n<p>Linux 链接分两种，一种被称为<strong>硬链接（Hard Link）</strong>，另一种被称为<strong>符号链接（Symbolic Link）</strong>。默认情况下，<strong>ln</strong> 命令产生硬链接。</p>\n<h2 id=\"硬连接\"><a class=\"markdownIt-Anchor\" href=\"#硬连接\">#</a> 硬连接</h2>\n<p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号 (Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p>\n<p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止 “误删” 的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>\n<h2 id=\"软连接\"><a class=\"markdownIt-Anchor\" href=\"#软连接\">#</a> 软连接</h2>\n<p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是 “主从” 关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p>\n<p><strong>通过实验加深理解</strong></p>\n<pre><code>[oracle@Linux]$ touch f1          #创建一个测试文件f1\n[oracle@Linux]$ ln f1 f2          #创建f1的一个硬连接文件f2\n[oracle@Linux]$ ln -s f1 f3       #创建f1的一个符号连接文件f3\n[oracle@Linux]$ ls -li            # -i参数显示文件的inode节点信息\ntotal 0\n9797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f1\n9797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f2\n9797649 lrwxrwxrwx  1 oracle oinstall 2 Apr 21 08:11 f3 -&gt; f1\n</code></pre>\n<p>从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 9797648，然而符号连接文件的 inode 节点不同。</p>\n<pre><code>[oracle@Linux]$ echo &quot;I am f1 file&quot; &gt;&gt;f1\n[oracle@Linux]$ cat f1\nI am f1 file\n[oracle@Linux]$ cat f2\nI am f1 file\n[oracle@Linux]$ cat f3\nI am f1 file\n[oracle@Linux]$ rm -f f1\n[oracle@Linux]$ cat f2\nI am f1 file\n[oracle@Linux]$ cat f3\ncat: f3: No such file or directory\n</code></pre>\n<p>通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f3 文件无效</p>\n<p><strong>总结</strong></p>\n<p>依此您可以做一些相关的测试，可以得到以下全部结论：</p>\n<ul>\n<li>1). 删除符号连接 f3, 对 f1,f2 无影响；</li>\n<li>2). 删除硬连接 f2，对 f1,f3 也无影响；</li>\n<li>3). 删除原文件 f1，对硬连接 f2 没有影响，导致符号连接 f3 失效；</li>\n<li>4). 同时删除原文件 f1, 硬连接 f2，整个文件会真正的被删除。</li>\n</ul>\n<h1 id=\"linux-用户和用户组管理\"><a class=\"markdownIt-Anchor\" href=\"#linux-用户和用户组管理\">#</a> Linux 用户和用户组管理</h1>\n<p>Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>\n<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>\n<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>\n<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p>\n<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>\n<ul>\n<li>用户账号的添加、删除与修改。</li>\n<li>用户口令的管理。</li>\n<li>用户组的管理。</li>\n</ul>\n<h1 id=\"linux-磁盘管理\"><a class=\"markdownIt-Anchor\" href=\"#linux-磁盘管理\">#</a> Linux 磁盘管理</h1>\n<p>Linux 磁盘管理好坏直接关系到整个系统的性能问题。</p>\n<p>Linux 磁盘管理常用三个命令为  <code>df</code> 、 <code>du</code>  和  <code>fdisk</code> 。</p>\n<ul>\n<li><code>df</code> （英文全称：disk free）：列出文件系统的整体磁盘使用量</li>\n<li><code>du</code> （英文全称：disk used）：检查磁盘空间使用量</li>\n<li><code>fdisk</code> ：用于磁盘分区</li>\n</ul>\n<h2 id=\"df\"><a class=\"markdownIt-Anchor\" href=\"#df\">#</a> df</h2>\n<p>df 命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">df</span> <span class=\"token punctuation\">[</span>-ahikHTm<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>目录或文件名<span class=\"token punctuation\">]</span></pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li><code>-a</code>  ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；</li>\n<li><code>-k</code>  ：以 KBytes 的容量显示各文件系统；</li>\n<li><code>-m</code>  ：以 MBytes 的容量显示各文件系统；</li>\n<li><code>-h</code>  ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li>\n<li><code>-H</code>  ：以 M=1000K 取代 M=1024K 的进位方式；</li>\n<li><code>-T</code>  ：显示文件系统类型，连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li>\n<li><code>-i</code>  ：不用硬盘容量，而以 inode 的数量来显示</li>\n</ul>\n<h2 id=\"du\"><a class=\"markdownIt-Anchor\" href=\"#du\">#</a> du</h2>\n<p>Linux du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看，还是和 df 命令有一些区别的，这里介绍 Linux du 命令。</p>\n<p>语法：</p>\n<pre><code>du [-ahskm] 文件或目录名称\n</code></pre>\n<p>选项与参数：</p>\n<ul>\n<li><code>-a</code>  ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li>\n<li><code>-h</code>  ：以人们较易读的容量格式 (G/M) 显示；</li>\n<li><code>-s</code>  ：列出总量而已，而不列出每个各别的目录占用容量；</li>\n<li><code>-S</code>  ：不包括子目录下的总计，与 -s 有点差别。</li>\n<li><code>-k</code>  ：以 KBytes 列出容量显示；</li>\n<li><code>-m</code>  ：以 MBytes 列出容量显示；</li>\n</ul>\n<h2 id=\"fdisk\"><a class=\"markdownIt-Anchor\" href=\"#fdisk\">#</a> fdisk</h2>\n<p>fdisk 是 Linux 的磁盘分区表操作工具。</p>\n<p>语法：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">fdisk</span> <span class=\"token punctuation\">[</span>-l<span class=\"token punctuation\">]</span> 装置名称</pre></td></tr></table></figure><p>选项与参数：</p>\n<ul>\n<li><code>-l</code>  ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。</li>\n</ul>\n<h1 id=\"linux-vivim\"><a class=\"markdownIt-Anchor\" href=\"#linux-vivim\">#</a> Linux vi/vim</h1>\n<p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p>\n<p>但是目前我们使用比较多的是 vim 编辑器。</p>\n<p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p>\n<h2 id=\"什么是-vim\"><a class=\"markdownIt-Anchor\" href=\"#什么是-vim\">#</a> 什么是 vim？</h2>\n<p>Vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>\n<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p>\n<p>连 vim 的官方网站 (<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudmltLm9yZy8=\">https://www.vim.org/</span>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p>\n<p><img data-src=\"vi-vim-cheat-sheet-sch.gif\" alt=\"img\"></p>\n<h2 id=\"vivim-的使用\"><a class=\"markdownIt-Anchor\" href=\"#vivim-的使用\">#</a> vi/vim 的使用</h2>\n<p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）<strong>和</strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是：</p>\n<h3 id=\"命令模式\"><a class=\"markdownIt-Anchor\" href=\"#命令模式\">#</a> 命令模式：</h3>\n<p>用户刚刚启动 vi/vim，便进入了命令模式。</p>\n<p>此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符。比如我们此时按下 i，并不会输入一个字符，i 被当作了一个命令。</p>\n<p>以下是常用的几个命令：</p>\n<ul>\n<li><code>i</code>  切换到输入模式，以输入字符。</li>\n<li><code>x</code>  删除当前光标所在处的字符。</li>\n<li><code>:</code>  切换到底线命令模式，以在最底一行输入命令。</li>\n</ul>\n<p>若想要编辑文本：启动 Vim，进入了命令模式，按下 i，切换到输入模式。</p>\n<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>\n<h3 id=\"输入模式\"><a class=\"markdownIt-Anchor\" href=\"#输入模式\">#</a> 输入模式</h3>\n<p>在命令模式下按下 i 就进入了输入模式。</p>\n<p>在输入模式中，可以使用以下按键：</p>\n<ul>\n<li><strong>字符按键以及 Shift 组合</strong>，输入字符</li>\n<li><strong>ENTER</strong>，回车键，换行</li>\n<li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li>\n<li><strong>DEL</strong>，删除键，删除光标后一个字符</li>\n<li><strong>方向键</strong>，在文本中移动光标</li>\n<li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首 / 行尾</li>\n<li><strong>Page Up</strong>/<strong>Page Down</strong>，上 / 下翻页</li>\n<li><strong>Insert</strong>，切换光标为输入 / 替换模式，光标将变成竖线 / 下划线</li>\n<li><strong>ESC</strong>，退出输入模式，切换到命令模式</li>\n</ul>\n<h3 id=\"底线命令模式\"><a class=\"markdownIt-Anchor\" href=\"#底线命令模式\">#</a> 底线命令模式</h3>\n<p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>\n<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>\n<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>\n<ul>\n<li><code>q</code>  退出程序</li>\n<li><code>w</code>  保存文件</li>\n</ul>\n<p>按 ESC 键可随时退出底线命令模式。</p>\n<p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>\n<p><img data-src=\"vim-vi-workmodel.png\" alt=\"img\"></p>\n<h2 id=\"vivim-使用实例\"><a class=\"markdownIt-Anchor\" href=\"#vivim-使用实例\">#</a> vi/vim 使用实例</h2>\n<p><strong>使用 vi/vim 进入一般模式</strong></p>\n<p>如果你想要使用 vi 来建立一个名为 runoob.txt 的文件时，你可以这样做：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ <span class=\"token function\">vim</span> runoob.txt</pre></td></tr></table></figure><p>直接输入 <strong>vi 文件名</strong> 就能够进入 vi 的一般模式了。请注意，记得 <strong>vi 后面一定要加文件名，不管该文件存在与否！</strong></p>\n<p><img data-src=\"078207F0-B204-4464-AAEF-982F45EDDAE9.jpg\" alt=\"img\"></p>\n<p><strong>按下 i 进入输入模式 (也称为编辑模式)，开始编辑文字</strong></p>\n<p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p>\n<p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p>\n<p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p>\n<p><img data-src=\"1C928383-471E-4AF1-A61E-9E2CCBD5A913.jpg\" alt=\"img\"></p>\n<p><strong>按下 ESC 按钮回到一般模式</strong></p>\n<p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p>\n<p><strong>在一般模式中按下 :wq 储存后离开 vi</strong></p>\n<p>OK，我们要存档了，存盘并离开的指令很简单，输入  <code>:wq</code>  即可保存离开！</p>\n<p><img data-src=\"B2FB5146-327C-4019-AC96-DD7A8EE7460C.jpg\" alt=\"img\"></p>\n<p>OK! 这样我们就成功创建了一个 runoob.txt 的文件。</p>\n<h1 id=\"linux-yum-命令\"><a class=\"markdownIt-Anchor\" href=\"#linux-yum-命令\">#</a> Linux yum 命令</h1>\n<p><code>yum</code> （ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。</p>\n<p>基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p>\n<p><code>yum</code>  提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>\n<h1 id=\"linux-apt-命令\"><a class=\"markdownIt-Anchor\" href=\"#linux-apt-命令\">#</a> Linux apt 命令</h1>\n<p><code>apt</code> （Advanced Packaging Tool）是一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。</p>\n<p><code>apt</code>  命令提供了查找、安装、升级、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>\n<p><code>apt</code>  命令执行需要超级管理员权限 (root)。</p>\n",
            "tags": [
                "Linux"
            ]
        }
    ]
}