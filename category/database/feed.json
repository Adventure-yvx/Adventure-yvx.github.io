{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"database\" category",
    "description": "",
    "home_page_url": "https://adventure-yx.github.io",
    "items": [
        {
            "id": "https://adventure-yx.github.io/2023/03/06/CMU15-445/",
            "url": "https://adventure-yx.github.io/2023/03/06/CMU15-445/",
            "title": "CMU15-445",
            "date_published": "2023-03-05T16:03:56.000Z",
            "content_html": "<p>Schedule | CMU 15-445/645 :: Intro to Database Systems (Fall 2022)](<span class=\"exturl\" data-url=\"aHR0cHM6Ly8xNTQ0NS5jb3Vyc2VzLmNzLmNtdS5lZHUvZmFsbDIwMjIvc2NoZWR1bGUuaHRtbA==\">https://15445.courses.cs.cmu.edu/fall2022/schedule.html</span>)</p>\n<h1 id=\"lesson01-关系模型关系代数relational-model-relational-algebra\"><a class=\"markdownIt-Anchor\" href=\"#lesson01-关系模型关系代数relational-model-relational-algebra\">#</a> Lesson#01. 关系模型 &amp; 关系代数（Relational Model &amp; Relational Algebra）</h1>\n<h2 id=\"1-database\"><a class=\"markdownIt-Anchor\" href=\"#1-database\">#</a> 1. Database</h2>\n<p>数据库 (Database,DB) 是一个有组织的、互相关联的、对现实世界的某些方面进行建模的集合。</p>\n<p>严格来讲，数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度 ()、较高的数据独立性 () 和易扩展性 ()，并可为各种用户共享。</p>\n<p>本笔记中，用一个存储着艺术家和对应的专辑信息的数据库作为例子，亦即数字音乐商店 (A database that models a digital music store)。</p>\n<h2 id=\"2-flat-file-strawman\"><a class=\"markdownIt-Anchor\" href=\"#2-flat-file-strawman\">#</a> 2. Flat File Strawman</h2>\n<p>数据库常常以 CSV (comma-separated value) 文件的形式存储，由 DBMS 进行管理。每次应用程序要读取或者更新记录时，都必须解析文件 (parse files)。</p>\n<p>以数字音乐商店的例子，会有两个文件，一是艺术家，二是专辑。</p>\n<p>每个实体都有自己的属性集，所以在每个文件中，不同的记录都用新的行来划分，而一条记录中的每个相应属性都用逗号隔开。</p>\n<p>例子：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Name</th>\n<th style=\"text-align:left\">Year</th>\n<th style=\"text-align:left\">Country</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Wu-Tang Clan</td>\n<td style=\"text-align:left\">1992</td>\n<td style=\"text-align:left\">USA</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Notorious BIG</td>\n<td style=\"text-align:left\">1992</td>\n<td style=\"text-align:left\">USA</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GZE</td>\n<td style=\"text-align:left\">1990</td>\n<td style=\"text-align:left\">USA</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Issues with Flat File</strong></p>\n<ul>\n<li>\n<p>Data Integrity</p>\n<p>数据完整性</p>\n</li>\n<li>\n<p>Implementation<br>\n 执行</p>\n</li>\n<li>\n<p>Durability<br>\n 耐受性</p>\n</li>\n</ul>\n<h2 id=\"3-database-management-systemdbms\"><a class=\"markdownIt-Anchor\" href=\"#3-database-management-systemdbms\">#</a> 3. Database Management System(DBMS)</h2>\n<p>一个 DBMS 是一个能让应用在数据库中保存与分析数据的软件</p>\n<p>通常，DBMS 设计的目的是允许定义、创建、查询、更新和管理符合某种数据模型的数据库。</p>\n<ul>\n<li>\n<p><strong>Data model：</strong><br>\n数据模型是描述数据库中数据的概念的集合。A data model is a collection of concepts for describing the data in database.</p>\n<p>Example: Relational (most common), NoSQL (key/value, graph, Document, Column-family), array/matrix/vectors</p>\n<ul>\n<li><strong>Relational</strong></li>\n<li>Key/Value (Redis)</li>\n<li>Graph</li>\n<li>Document</li>\n<li>Column-family 列族数据库</li>\n<li>Array/Matrix (machine learning)</li>\n</ul>\n</li>\n<li>\n<p><strong>Schema：</strong><br>\n模式是对基于数据模型的特定数据集合的描述。</p>\n</li>\n</ul>\n<p>Early DBMSs</p>\n<p>早期，数据库应用很难建立和维护，因为逻辑层和物理层之间存在着高度耦合 (a tight coupling between logical and physical layers)。</p>\n<ul>\n<li>逻辑层：<br>\n描述了数据库有哪些实体和属性。</li>\n<li>物理层：<br>\n是这些实体和属性的存储方式。</li>\n</ul>\n<p>所以早期的数据库，一旦改变了物理层，逻辑层也得跟着变。</p>\n<h2 id=\"4-relational-model\"><a class=\"markdownIt-Anchor\" href=\"#4-relational-model\">#</a> 4. Relational Model</h2>\n<p>人们每次改变物理层都要重新写数据管理系统，故 Ted Codd 注意到后提出了关系模型。</p>\n<ul>\n<li>\n<p><strong>Relational Model：</strong></p>\n<p>关系模型定义了一个基于关系的数据库抽象概念，有 3 个关键点：</p>\n<ul>\n<li>Store database in simple data structures (relations).</li>\n<li>Access data through high-level language, DBMS figures out best execution strategy.</li>\n<li>Physical storage left up to the DBMS implementation.</li>\n</ul>\n<p>简单来说就是：用简单的数据结构保存，用高级语言来访问，并让 DBMS 来执行最优策略以及处理物理层存储。</p>\n</li>\n<li>\n<p><strong>关系模型定义的三个概念：</strong></p>\n<ul>\n<li><strong>Structure：</strong><br>\n关系定义和内容。也就是关系具有的属性以及可以有的值。</li>\n<li><strong>Integrity：</strong><br>\n确保数据库的内容满足约束条件。比如：年份必须是数字。</li>\n<li><strong>Manipulation：</strong><br>\n如何访问和修改数据库的内容。</li>\n</ul>\n</li>\n<li>\n<p><strong>关系 (relation)：</strong><br>\n关系是一个<strong>无序的集合 (an unordered set)</strong>，包含代表的实体的属性关系。因为是无序的，所以 DBMS 可以用它想要的任何方式存储它们，并允许优化。</p>\n</li>\n<li>\n<p><strong>元组 (tuple)：</strong><br>\n元组指的是<strong>关系中的一组属性值 (a set of attribute values in the relation, also known as its domain)</strong>。</p>\n<p>Originally, values had to be atomic or scalar, but now values can also be lists or nested data structures. Every attribute can be a special value, NULL, which means for a given tuple the attribute is undefined.</p>\n<p>起初，值必须是<strong>原子的 (atomic)<strong> 或者</strong>标量 (scalar)</strong>，但现在值也可以是一个特殊的值 <code>NULL</code> ，表示为定义。</p>\n</li>\n<li>\n<p><strong>有 n 个属性的关系，叫做：n-ary relation</strong>。</p>\n</li>\n<li>\n<p>一张二维表，每行对应一个元组，每列对应一个域。</p>\n</li>\n<li>\n<p><strong>Keys：</strong><br>\n一个关系的<strong> primary key</strong> 唯一的定义了单个元组。很多 DBMS 都支持 auto-generated keys，所以程序就不需要手动增加了，但 primary key 还是在某些 DBMS 是需要的。</p>\n<ul>\n<li>Primary key / 主键：唯一的定义了单个元组。</li>\n<li>Foreign key / 外键：指定一个关系中的属性必须映射到另一个关系中的元组。</li>\n</ul>\n<p><img data-src=\"image-20230312011848991.png\" alt=\"image-20230312011848991\"></p>\n</li>\n</ul>\n<h2 id=\"5-data-manipulation-languages-dml\"><a class=\"markdownIt-Anchor\" href=\"#5-data-manipulation-languages-dml\">#</a> 5. Data Manipulation Languages (DML)</h2>\n<p>DML（data manipulation language）是数据操纵语言：它们是 SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这 4 条命令是用来对数据库里的数据进行操作的语言。</p>\n<p>DDL（data definition language）是数据定义语言：DDL 比 DML 要多，主要的命令有 CREATE、ALTER、DROP 等，DDL 主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。</p>\n<p>DCL（Data Control Language）是数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke 等）语句。</p>\n<p>有两类语言去保存和检索在数据库中的信息。</p>\n<ul>\n<li>Procedural：<br>\nThe query specifies the (high-level) strategy the DBMS should use to find the desired result based on sets / bags. (<strong>relational algebra</strong>)</li>\n<li>Non-Procedural (Declarative 声明式的)：<br>\nThe query specifies only what data is wanted and not how to find it. (<strong>relational calculus</strong>)</li>\n</ul>\n<p>一般现在都是用第二种的，我不管 DBMS 用什么策略，我只需要你给我我想要的数据。</p>\n<h2 id=\"6-relational-algebra\"><a class=\"markdownIt-Anchor\" href=\"#6-relational-algebra\">#</a> 6. Relational Algebra</h2>\n<p>关系代数 (Relational Algebra) 就是一组基本操作，用于检索和操作关系中的图元。</p>\n<p>每个操作符都需要一个或多个关系作为输入，并输出一个新的关系。为了编写查询，我们可以把这些运算符 &quot;链&quot; 在一起，以创建更复杂的操作。</p>\n<p><img data-src=\"image-20230312012338736.png\" alt=\"image-20230312012338736\"></p>\n<p><strong>Select</strong> takes in a relation and outputs a subset of the tuples from that relation that satisfy a selection predicate. The predicate acts like a filter, and we can combine multiple predicates using conjunctions and disjunctions.</p>\n<p><img data-src=\"image-20230312012550025.png\" alt=\"image-20230312012550025\"></p>\n<p><strong>Projection</strong> takes in a relation and outputs a relation with tuples that contain only specified attributes. You can rearrange the ordering of the attributes in the input relation as well as manipulate the values.</p>\n<p><img data-src=\"image-20230312012612509.png\" alt=\"image-20230312012612509\"></p>\n<p><strong>Union</strong> takes in two relations and outputs a relation that contains all tuples that appear in at least one of the input relations. Note: The two input relations have to have the exact same attributes.</p>\n<p><img data-src=\"image-20230312012638191.png\" alt=\"image-20230312012638191\"></p>\n<p><strong>Intersection</strong> takes in two relations and outputs a relation that contains all tuples that appear in both of the input relations. Note: The two input relations have to have the exact same attributes.</p>\n<p><img data-src=\"image-20230312012655770.png\" alt=\"image-20230312012655770\"></p>\n<p><strong>Difference</strong> takes in two relations and outputs a relation that contains all tuples that appear in the first relation but not the second relation. Note: The two input relations have to have the exact same attributes.</p>\n<p><img data-src=\"image-20230312012712525.png\" alt=\"image-20230312012712525\"></p>\n<p><strong>Product</strong> (笛卡尔积) takes in two relations and outputs a relation that contains all possible combinations for tuples from the input relations.</p>\n<p><img data-src=\"image-20230312012728132.png\" alt=\"image-20230312012728132\"></p>\n<p><strong>Join</strong> takes in two relations and outputs a relation that contains all the tuples that are a combination of two tuples where for each attribute that the two relations share, the values for that attribute of both tuples is the same.</p>\n<p><img data-src=\"image-20230312012750042.png\" alt=\"image-20230312012750042\"></p>\n<h1 id=\"lesson02-高级sqladvanced-sql\"><a class=\"markdownIt-Anchor\" href=\"#lesson02-高级sqladvanced-sql\">#</a> Lesson#02. 高级 SQL（Advanced SQL）</h1>\n<p><strong>SQL</strong> (Structured Query Language: 结构化查询语言) 是用于管理关系数据库管理系统（RDBMS）。 SQL 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。</p>\n<p>DML（data manipulation language）是数据操纵语言：它们是 SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这 4 条命令是用来对数据库里的数据进行操作的语言。</p>\n<p>DDL（data definition language）是数据定义语言：DDL 比 DML 要多，主要的命令有 CREATE、ALTER、DROP 等，DDL 主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。</p>\n<p>DCL（Data Control Language）是数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke 等）语句。</p>\n<p>用户只需要使用声明性语言（即 SQL）来指定他们想要的结果。DBMS 负责确定产生该答案的最有效计划。</p>\n<p>关系代数基于 sets (unordered, no duplicates)。<br>\nSQL 基于 bags (unordered, allows duplicates)</p>\n<h2 id=\"1sql基础语法\"><a class=\"markdownIt-Anchor\" href=\"#1sql基础语法\">#</a> 1.SQL 基础语法</h2>\n<ul>\n<li>\n<p><strong>SELECT 语句</strong></p>\n<p>SELECT 语句用于从数据库中选取数据。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> table_name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> table_name<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>SELECT DISTINCT 语句用于返回唯一不同的值。在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。</p>\n<p><strong>DISTINCT 关键词</strong>用于返回唯一不同的值。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">DISTINCT</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> table_name<span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p><strong>WHERE 子句</strong></p>\n<p>WHERE 子句用于提取那些满足指定条件的记录。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> table_name</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> condition<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> Websites <span class=\"token keyword\">WHERE</span> country<span class=\"token operator\">=</span><span class=\"token string\">'CN'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>WHERE 子句中的运算符</p>\n<p>下面的运算符可以在 WHERE 子句中使用：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">运算符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">=</td>\n<td style=\"text-align:left\">等于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;&gt;</td>\n<td style=\"text-align:left\">不等于。注释：在 SQL 的一些版本中，该操作符可被写成！=</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&gt;</td>\n<td style=\"text-align:left\">大于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;</td>\n<td style=\"text-align:left\">小于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&gt;=</td>\n<td style=\"text-align:left\">大于等于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&lt;=</td>\n<td style=\"text-align:left\">小于等于</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">BETWEEN</td>\n<td style=\"text-align:left\">在某个范围内</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LIKE</td>\n<td style=\"text-align:left\">搜索某种模式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IN</td>\n<td style=\"text-align:left\">指定针对某个列的多个可能值</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p><strong>AND &amp; OR 运算符</strong></p>\n<p>AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。</p>\n<p>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</p>\n<p>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> Websites</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">WHERE</span> alexa <span class=\"token operator\">></span> <span class=\"token number\">15</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">AND</span> <span class=\"token punctuation\">(</span>country<span class=\"token operator\">=</span><span class=\"token string\">'CN'</span> <span class=\"token operator\">OR</span> country<span class=\"token operator\">=</span><span class=\"token string\">'USA'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p><strong>ORDER BY 关键字</strong></p>\n<p>ORDER BY 关键字用于对结果集进行排序，对结果集按照一个列或者多个列进行排序。</p>\n<p>默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> table_name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">ASC</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> column1<span class=\"token punctuation\">,</span> column2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token keyword\">DESC</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p><strong>INSERT INTO 语句</strong></p>\n<p>INSERT INTO 语句用于向表中插入新记录。</p>\n<p>第一种形式无需指定要插入数据的列名，只需提供被插入的值即可（<strong>需要列出插入行的每一列数据</strong>）：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> table_name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span>value1<span class=\"token punctuation\">,</span>value2<span class=\"token punctuation\">,</span>value3<span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>第二种形式需要指定列名及被插入的值：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> table_name <span class=\"token punctuation\">(</span>column1<span class=\"token punctuation\">,</span>column2<span class=\"token punctuation\">,</span>column3<span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span>value1<span class=\"token punctuation\">,</span>value2<span class=\"token punctuation\">,</span>value3<span class=\"token punctuation\">,</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p><strong>UPDATE 语句</strong></p>\n<p>UPDATE 语句用于更新表中已存在的记录。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">UPDATE</span> table_name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SET</span> column1 <span class=\"token operator\">=</span> value1<span class=\"token punctuation\">,</span> column2 <span class=\"token operator\">=</span> value2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> condition<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">UPDATE</span> Websites </pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">SET</span> alexa<span class=\"token operator\">=</span><span class=\"token string\">'5000'</span><span class=\"token punctuation\">,</span> country<span class=\"token operator\">=</span><span class=\"token string\">'USA'</span> </pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">WHERE</span> name<span class=\"token operator\">=</span><span class=\"token string\">'菜鸟教程'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>如果我们省略了 WHERE 子句，执行以上代码会将 Websites 表中所有数据的 alexa 改为 5000，country 改为 USA。</p>\n</li>\n<li>\n<p><strong>DELETE 语句</strong></p>\n<p>DELETE 语句用于删除表中的行。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> table_name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">WHERE</span> condition<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>删除所有数据</p>\n<p>您可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> table_name<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>** 注释：** 在删除记录时要格外小心！因为您不能重来！</p>\n</li>\n</ul>\n<h2 id=\"2-joins\"><a class=\"markdownIt-Anchor\" href=\"#2-joins\">#</a> 2. Joins</h2>\n<p>结合一个或多个表的列，产生一个新的表。用来表达涉及跨越多个表的数据的查询，</p>\n<ul>\n<li>\n<p>本节课举例用的例子：</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> student <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    sid <span class=\"token keyword\">INT</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    name <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    login <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">UNIQUE</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    age <span class=\"token keyword\">SMALLINT</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    gpa <span class=\"token keyword\">FLOAT</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> course <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    cid <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    name <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> enrolled <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    sid <span class=\"token keyword\">INT</span> <span class=\"token keyword\">REFERENCES</span> student <span class=\"token punctuation\">(</span>sid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    cid <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">REFERENCES</span> course <span class=\"token punctuation\">(</span>cid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    grade <span class=\"token keyword\">CHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>哪个学生在 15-721 拿到了 A?</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> s<span class=\"token punctuation\">.</span>name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">FROM</span> enrolled <span class=\"token keyword\">AS</span> e<span class=\"token punctuation\">,</span> student <span class=\"token keyword\">AS</span> s</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">WHERE</span> e<span class=\"token punctuation\">.</span>grade <span class=\"token operator\">=</span> <span class=\"token string\">'A'</span> <span class=\"token operator\">AND</span> e<span class=\"token punctuation\">.</span>cid <span class=\"token operator\">=</span> <span class=\"token string\">'15-721'</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token operator\">AND</span> e<span class=\"token punctuation\">.</span>sid <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span>sid<span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"3-aggregate函数\"><a class=\"markdownIt-Anchor\" href=\"#3-aggregate函数\">#</a> 3. Aggregate 函数</h2>\n<p>聚合函数接受一组列表，然后产生一个单一的标量值作为其输出。基本上只能在 SELECT 输出列表中使用！</p>\n<ul>\n<li>\n<p>AVG(COL): The average of the values in COL</p>\n</li>\n<li>\n<p>MIN(COL): The minimum value in COL</p>\n</li>\n<li>\n<p>MAX(COL): The maximum value in COL</p>\n</li>\n<li>\n<p>SUM(COL)</p>\n</li>\n<li>\n<p>COUNT(COL): The number of tuples in the relation</p>\n</li>\n<li>\n<p>例子 1：</p>\n<p>Get # of students with a ‘@cs’ login.</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> login <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%@cs'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span>login<span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> login <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%@cs'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> login <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%@cs'</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>例子 2：</p>\n<p>Get # of students and their average GPA with a ‘@cs’ login.</p>\n<p>得到 <code>@cs</code>  登录的学生的人数和平均 GPA</p>\n<pre><code class=\"language-SQL\">SELECT AVG(gpa), COUNT(sid)\n  FROM student WHERE login LIKE '%@cs';\n</code></pre>\n<p>有些聚合函数支持 <code>DISTINCT</code>  关键字</p>\n<p>Get # of unique students and their average GPA with a ‘@cs’ login.</p>\n<p>得到通过 <code>@cs</code>  登录的学生数量，以及他们的 GPA, 要求学生不能重复！</p>\n<pre><code class=\"language-SQL\">SELECT COUNT(DISTINCT login)\n  FROM student WHERE login LIKE '%@cs';\n</code></pre>\n</li>\n<li>\n<p>Non-aggregated values in SELECT output clause must appear in GROUP BY clause</p>\n<p>例子 3：Get the average GPA of students in each course.</p>\n<p>得到在每个课上的学生的平均 GPA</p>\n<pre><code class=\"language-SQL\">SELECT AVG(s.gpa), e.cid\n  FROM enrolled AS e, student AS s\n WHERE e.sid = s.sid\n GROUP BY e.cid;\n</code></pre>\n</li>\n<li>\n<p>HAVING 子句在聚合计算的基础上过滤输出结果。这使得 HAVING 的行为像一个 GROUP BY 的 WHERE 子句。</p>\n<p>The HAVING clause filters output results based on aggregation computation.</p>\n<p>This make HAVING behave like a WHERE clause for a GROUP BY.</p>\n<p>例子 5：获取学生平均 GPA 大于 3.9 的课程。</p>\n<pre><code class=\"language-SQL\">SELECT AVG(s.gpa) AS avg_gpa, e.cid\n  FROM enrolled AS e, student AS s\n WHERE e.sid = s.sid\n GROUP BY e.cid\nHAVING avg_gpa &gt; 3.9;\n</code></pre>\n<p>上述查询语法被许多主要的数据库系统所支持，但不符合 SQL 标准。</p>\n<p>为了使查询符合标准，我们必须在 AVG (S.GPA) 的主体中重复使用 HAVING 子句</p>\n<pre><code class=\"language-SQL\">SELECT AVG(s.gpa), e.cid\nFROM enrolled AS e, student AS s\nWHERE e.sid = s.sid\nGROUP BY e.cid\nHAVING AVG(s.gpa) &gt; 3.9;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"4-string-operations\"><a class=\"markdownIt-Anchor\" href=\"#4-string-operations\">#</a> 4. String Operations</h2>\n<p>SQL 标准是区分大小写的，而且只能是单引号！有一些函数可以处理字符串，可以在查询的任何部分使用。</p>\n<ul>\n<li>\n<p>Pattern Matching:</p>\n<p><strong>LIKE 操作符</strong>用于在 WHERE 子句中搜索列中的指定模式。</p>\n<pre><code class=\"language-SQL\">SELECT column1, column2, ...\nFROM table_name\nWHERE column LIKE pattern;\n</code></pre>\n</li>\n<li>\n<p>通配符</p>\n<ul>\n<li><code>%</code>  替代 0 个或多个字符</li>\n<li><code>_</code> 替代一个字符</li>\n</ul>\n</li>\n<li>\n<p><strong>String Function:</strong><br>\n <code>SUBSTRING(S, B, E)</code> <br>\n <code>UPPER(S)</code></p>\n</li>\n<li>\n<p><strong>Concatenation:</strong><br>\n<img data-src=\"image-20230313134548756.png\" alt=\"image-20230313134548756\"></p>\n</li>\n</ul>\n<h2 id=\"5-date-and-time\"><a class=\"markdownIt-Anchor\" href=\"#5-date-and-time\">#</a> 5. Date and Time</h2>\n<ul>\n<li>\n<p>时间函数</p>\n<ol>\n<li>当前日期时间<br>\n <code>NOW()</code> ,  <code>CURRENT_TIMESTAMP()</code></li>\n<li>当前 UNIX 时间戳<br>\n <code>UNIX_TIMESTAMP()</code></li>\n<li>当前日期<br>\n <code>CURRENT_DATE()</code></li>\n<li>当前时间<br>\n <code>CURRENT_TIME()</code></li>\n</ol>\n</li>\n<li>\n<p>日期时间转换函数</p>\n<ol>\n<li>\n<p>当前时间戳转换为北京时间<br>\n <code>FROM_UNIXTIME()</code></p>\n</li>\n<li>\n<p>北京时间转换为时间戳<br>\n <code>UNIX_TIMESTAMP()</code></p>\n</li>\n<li>\n<p>时间中解析年月日时间<br>\n <code>DATE_FORMAT(date, format)</code></p>\n<pre><code>select DATE_FORMAT('2021-01-01 08:30:50','%Y-%m-%d')\n</code></pre>\n</li>\n</ol>\n</li>\n<li>\n<p>日期时间运算函数</p>\n<ol>\n<li>\n<p>在某个时间的基础上加上或者减去某个时间<br>\n <code>DATE_ADD(date,INTERVAL expr unit)</code> <br>\n <code>DATE_SUB(date,INTERVAL expr unit)</code></p>\n</li>\n<li>\n<p>返回两个日期值之间的天数<br>\n <code>DATEDIFF(expr1,expr2))</code></p>\n<pre><code>select DATEDIFF('2021-01-02','2021-01-01')\n</code></pre>\n</li>\n<li>\n<p>时间差函数<br>\n <code>TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)</code></p>\n<p>unit：天 (DAY)、小时 (HOUR），分钟 (MINUTE) 和秒 (SECOND)，TIMESTAMPDIFF 函数比 DATEDIFF 函数用起来更加灵活</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"6-output-redirection输出重定向\"><a class=\"markdownIt-Anchor\" href=\"#6-output-redirection输出重定向\">#</a> 6. Output Redirection (输出重定向)</h2>\n<p>你可以告诉 DBMS 将查询结果存储到另一个表中，而不是将查询结果返回给客户端（例如，终端）。结果存储到另一个表中。然后你可以在随后的查询中访问这些数据</p>\n<ul>\n<li>\n<p>New Table: 将查询的输出存储到一个新的（永久）表中</p>\n<pre><code>SELECT DISTINCT cid INTO CourseIds FROM enrolled;\n</code></pre>\n</li>\n<li>\n<p>Exustubg Table:</p>\n<p>将查询的输出存储到数据库中已经存在的表中。该表 目标表必须有与目标表相同数量和相同类型的列，但输出查询中的列名不需要匹配。</p>\n<pre><code>INSERT INTO CourseIds (SELECT DISTINCT cid FROM enrolled)\n</code></pre>\n</li>\n</ul>\n<h2 id=\"7-output-control\"><a class=\"markdownIt-Anchor\" href=\"#7-output-control\">#</a> 7. Output Control</h2>\n<p>因为 SQL 是无序的，我们可以用 ORDER BY 来对输出进行排序</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> sid<span class=\"token punctuation\">,</span> grade <span class=\"token keyword\">FROM</span> enrolled <span class=\"token keyword\">WHERE</span> cid <span class=\"token operator\">=</span> <span class=\"token string\">'15-721'</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> grade<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>后面可以加 <code>DESC</code> ,  <code>ASC</code>  来指定排序策略</p>\n<p>输出的数量可以用 <code>LIMIT n</code>  进行指定</p>\n<p>当然也可以用 <code>OFFSET</code>  来提供一个 bias。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> sid<span class=\"token punctuation\">,</span> name <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">WHERE</span> login <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%@cs'</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">LIMIT</span> <span class=\"token number\">20</span> <span class=\"token keyword\">OFFSET</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"8-nested-queries内部查询查询嵌套\"><a class=\"markdownIt-Anchor\" href=\"#8-nested-queries内部查询查询嵌套\">#</a> 8. Nested Queries（内部查询 / 查询嵌套）</h2>\n<p>在其他查询中调用查询，在单个查询中执行更复杂的逻辑。嵌套查询往往难以优化。</p>\n<p>外部查询的范围包括在内部查询中（即内部查询可以访问来自外部<br>\n查询），反之不行。</p>\n<ul>\n<li>\n<p>内部查询几乎可以出现在一个查询的任何部分。</p>\n<p><code>SELECT</code>  Output Targets</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> one <span class=\"token keyword\">FROM</span> student<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><code>FROM</code>  Clause:</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">FROM</span> student <span class=\"token keyword\">AS</span> s<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> sid <span class=\"token keyword\">FROM</span> enrolled<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> e</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">WHERE</span> s<span class=\"token punctuation\">.</span>sid <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>sid<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><code>WHERE</code>  Clause</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> name <span class=\"token keyword\">FROM</span> student</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">WHERE</span> sid <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span> <span class=\"token keyword\">SELECT</span> sid <span class=\"token keyword\">FROM</span> enrolled <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p>例子： 获取在 15-445 中注册的学生名字</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> name <span class=\"token keyword\">FROM</span> student</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">WHERE</span> sid <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">SELECT</span> sid <span class=\"token keyword\">FROM</span> enrolled</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">WHERE</span> cid <span class=\"token operator\">=</span> <span class=\"token string\">'15-445'</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n<p>请注意，根据它在查询中出现的位置，sid 有不同的范围。</p>\n<ul>\n<li>\n<p>例子：<br>\n找到注册了至少一门课的最大的学生 id</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> student<span class=\"token punctuation\">.</span>sid<span class=\"token punctuation\">,</span> name</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token keyword\">FROM</span> student</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">JOIN</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">SELECT</span> <span class=\"token function\">MAX</span><span class=\"token punctuation\">(</span>sid<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> sid</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">FROM</span> enrolled<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> max_e</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">ON</span> student<span class=\"token punctuation\">.</span>sid <span class=\"token operator\">=</span> max_e<span class=\"token punctuation\">.</span>sid<span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n<p>Nested Query Results Expressions:</p>\n<ul>\n<li>\n<p>关键字：</p>\n<ul>\n<li><code>ALL</code> <br>\nMust satisfy expression for all rows in sub-query</li>\n<li><code>ANY</code> <br>\nMust satisfy expression for at least one row in sub-query.</li>\n<li><code>IN</code> <br>\nEquivalent to =ANY().</li>\n<li><code>EXISTS</code> <br>\nAt least one row is returned.</li>\n</ul>\n</li>\n<li>\n<p>例子：</p>\n<p>找到所有没有学生注册的课</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> course</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">WHERE</span> <span class=\"token operator\">NOT</span> <span class=\"token keyword\">EXISTS</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> enrolled</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">WHERE</span> course<span class=\"token punctuation\">.</span>cid <span class=\"token operator\">=</span> enrolled<span class=\"token punctuation\">.</span>cid</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"10-window-function\"><a class=\"markdownIt-Anchor\" href=\"#10-window-function\">#</a> 10. Window Function</h2>\n<p>A window function perform “sliding” calculation across a set of tuples that are related. Like an aggregation but tuples are not grouped into a single output tuple.</p>\n<ul>\n<li>\n<p>函数： 窗口函数可以是我们上面讨论的任何一个聚合函数。也有一些特殊的窗口函数。</p>\n<ol>\n<li><code>ROW_NUMBER</code> : 当前列的数字</li>\n<li><code>RANK</code> : 当前列的顺序</li>\n</ol>\n</li>\n<li>\n<p>Grouping: <strong>OVER 子句指定了在计算窗口函数时如何对图元进行分组</strong>。使用 PARTITION BY 来指定分组</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> cid<span class=\"token punctuation\">,</span> sid<span class=\"token punctuation\">,</span> ROW_NUMBER<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">OVER</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">PARTITION</span> <span class=\"token keyword\">BY</span> cid<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token keyword\">FROM</span> enrolled <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> cid<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们也可以在 OVER 中放入 ORDER BY，以确保结果的确定性排序，即使数据库内部发生变化。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> ROW_NUMBER<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">OVER</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> cid<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">FROM</span> enrolled <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> cid<span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n<li>\n<p><strong>重要提示：</strong></p>\n</li>\n<li>\n<p>DBMS 在窗函数排序后计算 <code>RANK</code> ，而在排序前计算 <code>ROW_NUMBER</code> 。</p>\n<ul>\n<li>\n<p>找到每门课程中成绩第二高的学生</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> RANK<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">OVER</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">PARTITION</span> <span class=\"token keyword\">BY</span> cid</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> grade <span class=\"token keyword\">ASC</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> rank</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">FROM</span> enrolled<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> ranking</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">WHERE</span> ranking<span class=\"token punctuation\">.</span>rank <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"11-commom-table-expressions\"><a class=\"markdownIt-Anchor\" href=\"#11-commom-table-expressions\">#</a> 11. Commom Table Expressions</h2>\n<p>在编写更复杂的查询时，通用表表达式（CTE）是窗口或嵌套查询的一种替代方法。复杂的查询时，可以替代窗口或嵌套查询。它们提供了一种方法来为用户在一个更大的查询中编写辅助语句.</p>\n<p>可以理解为一个辅助表。</p>\n<p><code>WITH</code>  子句将内部查询的输出与一个具有该名称的临时结果绑定。</p>\n<ul>\n<li>\n<p>例子：<br>\n生成一个名为 cteName 的 CTE，其中包含一个单一属性设置为 &quot;1&quot; 的元组。从这个 CTE 中选择所有属性。</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">WITH</span> cteName <span class=\"token keyword\">AS</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">SELECT</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> cteName<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们可以在 AS 之前将输出列绑定到名称上</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">WITH</span> cteName <span class=\"token punctuation\">(</span>col1<span class=\"token punctuation\">,</span> col2<span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">SELECT</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">SELECT</span> col1 <span class=\"token operator\">+</span> col2 <span class=\"token keyword\">FROM</span> cteName<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>一个查询可能包含多个 CTE 声明</p>\n<pre><code>WITH cte1 (col1) AS (SELECT 1), cte2 (col2) AS (SELECT 2)\nSELECT * FROM cte1, cte2;\n</code></pre>\n</li>\n<li>\n<p>递归能力<br>\n在 WITH 后面添加 RECURSIVE 关键字允许 CTE 引用自己。这使得在 SQL 查询中可以实现递归。有了递归的 CTE，SQL 被证明是图灵完备的，这意味着它在计算上的表现力不亚于更多的通用编程语言</p>\n</li>\n<li>\n<p>例子：打印从 1 到 10 的数字</p>\n<pre><code>WITH RECURSIVE cteSource (counter) AS (\n    ( SELECT 1 )\n    UNION\n    ( SELECT counter + 1 FROM cteSource\n    \tWHERE counter &lt; 10 )\n)\nSELECT * FROM cteSource;\n</code></pre>\n</li>\n</ul>\n<h1 id=\"lesson0304-存储引擎\"><a class=\"markdownIt-Anchor\" href=\"#lesson0304-存储引擎\">#</a> Lesson#03&amp;04. 存储引擎</h1>\n<h2 id=\"1-storage\"><a class=\"markdownIt-Anchor\" href=\"#1-storage\">#</a> 1. Storage</h2>\n<ul>\n<li>\n<p>我们将关注一个 &quot;面向磁盘 (disk-oriented)&quot; 的 DBMS 架构，它假定数据库的主要存储位置是在非易失性磁盘上。越接近 CPU，存储就越快，容量越小，也更贵。</p>\n<ul>\n<li>Volatile Devices （MEMORY）</li>\n<li>Non-Volatile Devices （DISK）</li>\n</ul>\n</li>\n<li>\n<p>注意：<br>\n这课不讨论 NVMe SSD – non-volatile memory express.</p>\n</li>\n<li>\n<p>We will focus on hiding the latency of the disk rather than optimizations with registers and caches since getting data from disk is so slow. 我们将专注于隐藏磁盘的延迟，而不是使用寄存器和缓存进行优化，因为从磁盘获取数据非常缓慢。</p>\n<p><img data-src=\"image-20230313140745881.png\" alt=\"image-20230313140745881\"></p>\n</li>\n</ul>\n<h2 id=\"2-disk-oriented-dbms-overview\"><a class=\"markdownIt-Anchor\" href=\"#2-disk-oriented-dbms-overview\">#</a> 2. Disk-Oriented DBMS Overview</h2>\n<ul>\n<li>数据库都在磁盘上，数据库文件中的数据被组织成页，第一页是目录页。为了对数据进行操作，DBMS 需要将数据引入内存。\n<ul>\n<li>它通过拥有<strong>一个缓冲池来管理数据在磁盘和内存之间的交换</strong></li>\n<li>DBMS 也有一个执行查询的执行引擎。执行引擎将要求缓冲池提供一个特定的页面，而缓冲池将负责把该页面带入内存，并给执行引擎一个指向内存中该页面的指针<br>\n缓冲池管理器将确保在执行引擎对该部分内存进行操作时，该页就在那里。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-dbms-vs-os\"><a class=\"markdownIt-Anchor\" href=\"#3-dbms-vs-os\">#</a> 3. DBMS vs. OS</h2>\n<ul>\n<li>DBMS 的一个高级设计目标是支持超过可用内存量的数据库。因为访问 disk 的代价很大，所以使用 disk 应该要小心。我们不希望从磁盘上访问数据时停顿太久，从而拖慢其他一切。我们希望 DBMS 能够处理在等待从磁盘获取数据时，能够处理其他查询。</li>\n<li>这个高层次的设计目标就像虚拟内存一样，有一个大的地址空间和一个供操作系统从磁盘引入页面的地方。</li>\n<li>实现这种虚拟内存的方法之一是使用 mmap 来映射进程地址空间中的文件内容，这使得操作系统负责在磁盘和内存之间来回移动页面。<br>\n但不幸的是，如果 mmap 遇到页面故障，进程将会被阻塞。\n<ul>\n<li>如果你需要写入，你永远不想在你的 DBMS 中使用 mmap。</li>\n<li>DBMS（几乎）总是想自己控制事情，而且可以做得更好，因为它知道更多关于被访问的数据和被处理的查询。</li>\n<li>操作系统不是你的朋友。</li>\n</ul>\n</li>\n<li>可以通过使用操作系统：\n<ul>\n<li><code>madvise</code> : 告诉操作系统你打算何时读某些页面。</li>\n<li><code>mlock</code> : 告诉操作系统不要把内存范围换到磁盘上。</li>\n<li><code>msync</code> : 告诉操作系统将内存范围刷新到磁盘。</li>\n</ul>\n</li>\n</ul>\n<p><strong>出于正确性和性能的考虑，我们不建议在 DBMS 中使用 <code>mmap</code> 。</strong></p>\n<blockquote>\n<p>Even though the system will have functionalities that seem like something the OS can provide, having the DBMS implement these procedures itself gives it better control and performance</p>\n</blockquote>\n<h2 id=\"4-file-storage\"><a class=\"markdownIt-Anchor\" href=\"#4-file-storage\">#</a> 4. File Storage</h2>\n<ul>\n<li>在其最基本的形式中，DBMS 将数据库存储为磁盘上的文件。有些可能使用文件层次结构，有些则可能使用单个文件</li>\n<li>操作系统对这些文件的内容一无所知。只有 DBMS 知道如何解读它们的内容，因为它是以 DBMS 特有的方式编码的。</li>\n<li>DBMS 的存储管理器负责管理数据库的文件。它将文件表示为一个 页的集合。它还跟踪哪些数据被读和写到了页面上，以及这些页面有多少可用空间。这些页面中还有多少可用空间。</li>\n</ul>\n<h2 id=\"5-database-pages\"><a class=\"markdownIt-Anchor\" href=\"#5-database-pages\">#</a> 5. Database Pages</h2>\n<ul>\n<li>\n<p>DBMS 将数据库组织在一个或多个文件中的固定大小的数据块，称为页。页面可以包含不同种类的数据（tuple、indexes 等）。</p>\n</li>\n<li>\n<p>大多数系统不会将这些类型混合在一页中。<br>\n有些系统会要求页面是自成一体（self-contained）的，也就是说，阅读每个页面所需的所有信息都在页面本身。读取每一页的所有信息都在页面本身</p>\n</li>\n<li>\n<p>每个页面都有一个独特的标识符 identifier</p>\n<ul>\n<li>\n<p>如果数据库是一个单一的文件，那么页面 ID 可以是文件的偏移量。</p>\n</li>\n<li>\n<p>大多数 DBMS 有一个中介层（indirection layer），将页面 ID 映射到文件路径和偏移量。 系统的上层会要求提供一个特定的页号。然后，存储管理程序将把这个页号变成一个文件和一个偏移量以找到该页。</p>\n</li>\n<li>\n<p>大多数 DBMS 使用固定大小的页面，以避免支持可变大小页面所需的工程开销。</p>\n<p>因为，对于可变大小的页面，删除一个页面会在文件中产生一个 hole，而 DBMS 难以用新的页面来填补。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>页在 DBMS 的 3 个概念</p>\n<ol>\n<li>Hardware page (usually 4 KB).</li>\n<li>OS page (4 KB).</li>\n<li>Database page (1-16 KB）</li>\n</ol>\n</li>\n<li>\n<p>存储设备保证写的操作是 atomic 原子的。<br>\n这意味着，如果我们的数据库页面比我们的硬件页面大，DBMS 将不得不采取额外的措施 以确保数据被安全地写出来。 因为当系统崩溃时，程序可能已经完成了将数据库页面写入磁盘的一部分</p>\n</li>\n</ul>\n<h2 id=\"6-database-heap\"><a class=\"markdownIt-Anchor\" href=\"#6-database-heap\">#</a> 6. Database Heap</h2>\n<ul>\n<li>\n<p>有几种方法可以找到 DBMS 在磁盘上想要的页面的位置，堆文件组织是其中一种方法<br>\n堆文件是一个无序的页面集合，其中的图元是按照 随机顺序存储。</p>\n</li>\n<li>\n<p>DBMS 可以通过使用页面的链接列表或页面目录在磁盘上找到一个给定的页面 ID</p>\n<ol>\n<li>\n<p>Linked List:<br>\nHeader page 持有指向自由页列表和数据页列表的指针。然而，如果 DBMS 正在寻找一个特定的页面，它必须在数据页列表上进行顺序扫描，直到它找到它要找的页面。</p>\n</li>\n<li>\n<p>Page Directory:</p>\n<p>DBMS 维护特殊的页面，跟踪数据页的位置以及每页的可用空间。</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"7-page-layout\"><a class=\"markdownIt-Anchor\" href=\"#7-page-layout\">#</a> 7. Page Layout</h2>\n<ul>\n<li>\n<p>每个页面都包括一个 header，记录关于页面内容的元数据。</p>\n<ul>\n<li>Page size</li>\n<li>Checksum</li>\n<li>DBMS version</li>\n<li>Transaction visibility</li>\n<li>Self-containment (Some systems like Oracle require this.)</li>\n</ul>\n</li>\n<li>\n<p>放置数据的一个 strawman 方法是 追踪 DBMS 在一个页面中存储了多少个 tuples，然后在每次添加新的 tuples 的时候追加到最后面。然而，问题出现在当 tuples 被删除或者是变长 variable-length 属性的时候</p>\n</li>\n<li>\n<p>有 2 个主流方法去在一个 page 中放置数据：</p>\n<ol>\n<li>\n<p><strong>slotted-page</strong><br>\n 页面将 slots 映射到 offsets</p>\n<ul>\n<li>Most common approach used in DBMSs today.</li>\n<li>Header keeps track of the number of used slots, the offset of the starting location of the last used slot, and a slot array, which keeps track of the location of the start of each tuple.</li>\n<li>To add a tuple, the slot array will grow from the beginning to the end, and the data of the tuples will grow from end to the beginning. The page is considered full when the slot array and the tuple data meet</li>\n</ul>\n</li>\n<li>\n<p><strong>log-structured</strong></p>\n<p>下一课介绍。</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"8-tuple-layout\"><a class=\"markdownIt-Anchor\" href=\"#8-tuple-layout\">#</a> 8. Tuple Layout</h2>\n<p>tuples 本质上是一个字节序列。DBMS 的工作是将这些字节解释为属性类型和值。</p>\n<ul>\n<li>\n<p>Tuple Header：包含了 tuple 的元数据</p>\n<ul>\n<li>DBMS 的并发控制协议的可见性信息。关于哪个事务创建 / 修改了该元组</li>\n<li>NULL 值的位图。</li>\n<li>注意，DBMS 不需要在这里存储关于数据库模式的元数据。</li>\n</ul>\n</li>\n<li>\n<p>Tuple Data：数据的实际属性</p>\n<ul>\n<li>属性通常按照你创建表时指定的顺序存储</li>\n<li>大多数 DBMS 不允许一个 tuple 超过一个页面的大小。</li>\n</ul>\n</li>\n<li>\n<p>Unique Identifier</p>\n<ul>\n<li>数据库中的每个 tuple 都被分配一个唯一的标识符</li>\n<li>一般是： <code>page_id + (offset or slow)</code></li>\n<li>一个应用程序<strong>不能</strong>依赖这些 ID 来表示任何东西</li>\n</ul>\n</li>\n<li>\n<p>De-normalized Tuple Data:</p>\n<p>如果两个表是相关的，DBMS 可以 &quot;pre-join&quot; 它们，所以这些表最终会出现在<br>\n在同一个页面上。这使得读取速度加快，因为 DBMS 只需要加载一个页面而不是两个<br>\n独立的页面。然而，这使得更新更加昂贵，因为 DBMS 需要更多的空间给每个<br>\n tuples</p>\n</li>\n</ul>\n",
            "tags": [
                "DataBase"
            ]
        }
    ]
}